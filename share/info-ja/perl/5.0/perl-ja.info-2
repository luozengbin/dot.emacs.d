Info file: perl-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `perl-ja.texi'
using `texinfmt.el' version 2.42 of  7 Jul 2006.






File: perl-ja.info, Node: フッタ, Next: 内部のフォーマット動作へのアクセス, Prev: フォーマット変数, Up: フォーマット文

フッタ
======

`$FORMAT_TOP_NAME' には、その時点のページ先頭フォーマット（ヘッダフォー
マット）の名前が納められていますが、フッタに対して自動的に同じことをす
るための、対応する機構は用意されていません。フォーマットを評価するまで
は、どのくらいの大きさになるのかがわからないことも、大きな問題と言えま
す。これは、Todo のリストに入っています。

1 つの方法をあげておきます: 固定サイズのフッタであれば、`write()' を行
なう前ごとに `$FORMAT_LINES_LEFT' をチェックして、必要なときにフッタを
`print' することで、フッタを付けることができます。

もう 1 つ別の方法です: `open(MESELF, "|-")' を使って、自分自身にパイプ
を `open' し (*Note 組み込み関数::,の `open()' の項を参照してください)、
常に STDOUT の代わりに MESELF に `write()' するようにします。チャイルド
プロセス側では、STDIN からの入力をフォーマットし直して、好きな形にヘッ
ダやフッタを整えるようにします。簡単とは言えませんが、実行は可能です。





File: perl-ja.info, Node: 内部のフォーマット動作へのアクセス, Prev: フッタ, Up: フォーマット文

内部のフォーマット動作へのアクセス
==================================

フォーマット機構に対する低レベルのアクセスのため、`formline()' を使い、
`$^A' (`$ACCUMULATOR') を直接アクセスすることができます。

たとえば、

     $str = formline <<'END', 1,2,3;
     @<<<  @|||  @>>>
     END

     print "Wow, I just stored `$^A' in the accumulator!\n";

もしくは、`printf()' に対する `sprintf()' のような
`write()' に対するサブルーティン `swrite()' を作るため:

     use English;
     use Carp;
     sub swrite {
         croak "usage: swrite PICTURE ARGS" unless @ARG;
         local($ACCUMULATOR);
         formline(@ARG);
         return $ACCUMULATOR;
     }
     $string = swrite(<<'END', 1, 2, 3);
     Check me out
     @<<<  @|||  @>>>
     END
     print $string;

のようにします。


WARNING
-------

`format' の実行中には、グローバルな変数と `local()' で宣言された動的ス
コープの変数だけが見えます。`my()' で宣言された字句スコープの変数は、
`format' と同じスコープにあるとはみなされず、使用することができません。




File: perl-ja.info, Node: プロセス間通信, Next: セキュリティ, Prev: フォーマット文, Up: Top

プロセス間通信
**************

Perl の IPC 機能は、バークレイのソケット機構の上に構築されています。ソ
ケットが無い場合には、この節は無視してください。呼び出す関数の名前は対
応するシステムコールの名前と同一ですが、2 つの理由により引数は異なる傾
向にあります。まず、Perl のファイルハンドルは C のファイルディスクリプ
タと異なる動作をすること。もう一つは、Perl は常に文字列の長さを知ってい
るので、長さの情報を改めて渡す必要がないことです。

* Menu:

* クライアント/サーバ通信::
* SysV IPC::





File: perl-ja.info, Node: クライアント/サーバ通信, Next: SysV IPC, Prev: プロセス間通信, Up: プロセス間通信

クライアント/サーバ通信
=======================

TCP クライアントの例を示します。

     ($them,$port) = @ARGV;
     $port = 2345 unless $port;
     $them = 'localhost' unless $them;

     $SIG{'INT'} = 'dokill';
     sub dokill { kill 9,$child if $child; }

     use Socket;

     $sockaddr = 'S n a4 x8';
     chop($hostname = `hostname`);

     ($name, $aliases, $proto) = getprotobyname('tcp');
     ($name, $aliases, $port) = getservbyname($port, 'tcp')
         unless $port =~ /^\d+$/;
     ($name, $aliases, $type, $len, $thisaddr) =
                     gethostbyname($hostname);
     ($name, $aliases, $type, $len, $thataddr) = gethostbyname($them);

     $this = pack($sockaddr, &AF_INET, 0, $thisaddr);
     $that = pack($sockaddr, &AF_INET, $port, $thataddr);

     socket(S, &PF_INET, &SOCK_STREAM, $proto) || die "socket: $!";
     bind(S, $this) || die "bind: $!";
     connect(S, $that) || die "connect: $!";

     select(S); $| = 1; select(stdout);

     if ($child = fork) {
         while (<>) {
             print S;
         }
         sleep 3;
         do dokill();
     }
     else {
         while (<S>) {
             print;
         }
     }

そしてサーバです:

     ($port) = @ARGV;
     $port = 2345 unless $port;

     use Socket;

     $sockaddr = 'S n a4 x8';

     ($name, $aliases, $proto) = getprotobyname('tcp');
     ($name, $aliases, $port) = getservbyname($port, 'tcp')
         unless $port =~ /^\d+$/;

     $this = pack($sockaddr, &AF_INET, $port, "\0\0\0\0");

     select(NS); $| = 1; select(stdout);

     socket(S, &PF_INET, &SOCK_STREAM, $proto) || die "socket: $!";
     bind(S, $this) || die "bind: $!";
     listen(S, 5) || die "connect: $!";

     select(S); $| = 1; select(stdout);

     for (;;) {
         print "Listening again\n";
         ($addr = accept(NS,S)) || die $!;
         print "accept ok\n";

         ($af,$port,$inetaddr) = unpack($sockaddr,$addr);
         @inetaddr = unpack('C4',$inetaddr);
         print "$af $port @inetaddr\n";

         while (<NS>) {
             print;
             print NS;
         }
     }





File: perl-ja.info, Node: SysV IPC, Prev: クライアント/サーバ通信, Up: プロセス間通信

SysV IPC
========

共有メモリ使用状況を示す例です:

     $IPC_PRIVATE = 0;
     $IPC_RMID = 0;
     $size = 2000;
     $key = shmget($IPC_PRIVATE, $size , 0777 );
     die if !defined($key);

     $message = "Message #1";
     shmwrite($key, $message, 0, 60 ) || die "$!";
     shmread($key,$buff,0,60) || die "$!";

     print $buff,"\n";

     print "deleting $key\n";
     shmctl($key ,$IPC_RMID, 0) || die "$!";

セマフォの例です:

     $IPC_KEY = 1234;
     $IPC_RMID = 0;
     $IPC_CREATE = 0001000;
     $key = semget($IPC_KEY, $nsems , 0666 | $IPC_CREATE );
     die if !defined($key);
     print "$key\n";

このコードを独立したファイルに納めて、少なくとも一つのプロセスで実行す
るようにします。このファイルを `take' とします。(訳注: 意味が通じないの
で想像を含めています。)

     # セマフォの生成

     $IPC_KEY = 1234;
     $key = semget($IPC_KEY,  0 , 0 );
     die if !defined($key);

     $semnum = 0;
     $semflag = 0;

     # セマフォの「取得」'take'
     # セマフォが 0 になるのを待つ
     $semop = 0;
     $opstring1 = pack("sss", $semnum, $semop, $semflag);

     # セマフォのカウントをインクリメント
     $semop = 1;
     $opstring2 = pack("sss", $semnum, $semop,  $semflag);
     $opstring = $opstring1 . $opstring2;

     semop($key,$opstring) || die "$!";

このコードを独立したファイルに納めて、少なくとも一つのプロセスで実行す
るようにします。このファイルを `give' とします。(訳注: 意味が通じないの
で想像を含めています。)

     # セマフォの「提供」'give'
     # これを元のプロセスで実行すると、続くプロセスが、引き継
     # ぎます。

     $IPC_KEY = 1234;
     $key = semget($IPC_KEY, 0, 0);
     die if !defined($key);

     $semnum = 0;
     $semflag = 0;

     # セマフォのカウントをデクリメント
     $semop = -1;
     $opstring = pack("sss", $semnum, $semop, $semflag);

     semop($key,$opstring) || die "$!";




File: perl-ja.info, Node: セキュリティ, Next: 不注意によるわな, Prev: プロセス間通信, Up: Top

セキュリティ
************

Perl は安全な setuid スクリプトや setgid スクリプトを書くことが簡単にで
きるように設計されています。シェルはスクリプト内の各々の行に対して置換
を何回も行ないますが、Perl は見えない「内部動作」を少なくした、より伝統
的な評価機構を使っています。さらに、この言語では、より多くの組み込み機
能を備えており、目的達成のために、外部の (そして、信頼のおけない可能性
のある) プログラムに頼らなければならないことが、少なくなっています。

多くの OS で、スクリプトのような柔軟なシステムに対して、特別な権限を与
えることによる明らかな問題以前に、setuid スクリプトは、スタート時点から
本質的に安全ではありません。これは、特にシステム上にシンボリックリンク
がある場合には、カーネルが何を実行するのかを調べるためにファイルをオー
プンしてから、setuid インタプリタが変更を行なって、そのファイルを解釈す
るために再オープンするまでに、何かが変更される可能性があるからです。

幸いにも、カーネルの「機能」は、禁止することができる場合があります。不
幸にも、禁止する方法は2通りあります。一つは、システムが setuid ビットが
設定されているスクリプトを扱えないようにするもので、こちらは余り役に立
つことがありません。もう一つは、単にスクリプトに付いた setuid ビットを
無視するというものです。もし、後者であれば、Perl スクリプトに付けた、意
味のなくなった setuid/setgid ビットを Perl が見つけたときに、setuid と
setgid の機構をエミュレートすることができます。これは、必要なときに自動
的に呼ばれる、suidperl という特別な実行ファイルによって行なわれます。

しかし、カーネルの setuid スクリプトの機能が禁止されていなければ、Perl
は、この setuid スクリプトが安全ではないと警告を発します。カーネルの
setuid スクリプトの機能を禁止するか、スクリプトに C ラッパーを被せる必
要があります。どのようにこれを行なうかについては、Perl 配布キットの eg
ディレクトリの wrapsuid プログラムを参照してください。

setuid スクリプトが、この本質的な非安全性のバグから免れているシステムも
存在します。たとえば、Solaris の最近のリリースでは大丈夫なようです。この
ようなシステムでは、カーネルがインタプリタへオープンする setuid スクリプ
トの名前を渡すとき、そのものを表わすパス名を渡すのではなく、代わりに
/dev/fd/3を渡します。これは、既にスクリプトに対してオープンされた特殊ファ
イルですから、横取りをするような悪意を持った競合条件を避けることになりま
す。こういったシステムでは、Perl をコンパイルするときに
-DSETUID_SCRIPTS_ARE_SECURE_NOW をつけておくとよいでしょう。Perl を作る
Configure プログラムは、自分でこれを見つけようとします。

Perl が setuid スクリプトを実行するとき、明らかな罠に填ったりしないよう
に、特別な予防策がとられます。(いくつかの点で、Perl スクリプトは同じこ
とをする C プログラムよりも安全であるといえます。)すべてのコマンドライ
ンの引数、環境変数、入力は、「汚染」マークが付けられ、サブシェルを起動
するコマンドや、ファイルやディレクトリやプロセスに修正を加えるコマンド
には、直接的にも間接的にも使用できないようになっています。汚染マークが
付けられた値を含んだ式で、設定を行なった変数もすべて、(たとえ、論理的に
汚染された値が、その変数に影響を与えることが不可能であっても) 汚染され
たことになります。たとえば:

     $foo = shift;               # $foo は汚染された
     $bar = $foo,'bar';          # $bar も汚染された
     $xxx = <>;                  # 汚染された
     $path = $ENV{'PATH'};       # 汚染されたが、以下も参照
     $abc = 'abc';               # 汚染されていない

     system "echo $foo";         # 安全ではない
     system "/bin/echo", $foo;   # 安全 (sh を使いません)
     system "echo $bar";         # 安全ではない
     system "echo $abc";         # PATH が設定されるまでは、
                                 # 安全ではない

     $ENV{'PATH'} = '/bin:/usr/bin';
     $ENV{'IFS'} = " if $ENV{'IFS'} ne ";

     $path = $ENV{'PATH'};       # 汚染されていない
     system "echo $abc";         # これで安全 !

     open(FOO,"$foo");           # OK
     open(FOO,">$foo");          # OK ではない

     open(FOO,"echo $foo|");     # OK ではありませんが ...
     open(FOO,"-|") || exec 'echo', $foo;        # OK

     $zzz = `echo $foo`;         # 安全ではなく、zzz は汚染

     unlink $abc,$foo;           # 安全ではない
     umask $foo;                 # 安全ではない

     exec "echo $foo";           # 安全ではない
     exec "echo", $foo;          # 安全 (sh を使いません)
     exec "sh", '-c', $foo;      # 安全と解釈されてしまいます

汚染状況は、スカラ値ごとに管理されますから、配列要素の一部の要素だけが
汚染され、他は大丈夫ということもあります。

もし、何か安全とはいえないことをしようとしたならば、"Insecure
dependency" とか "Insecure PATH" といった致命的エラーになります。それで
も、安全でないシステムコールや `exec' を書くことができることに注意しな
くてはなりませんが、実行するためには、上記の最後の例のように、明示的に
行なうことが必要になっています。サブパターンを参照することでも、この汚
染チェックの仕組みの裏をかくことができます。`$1', `$2' といった部分文字
列を使うときには、Perl は、使っているみなさん自身が、パターンを書く時点
で、自分で何をしているのかが分かっているものと、仮定するのです:

     $ARGV[0] =~ /^-P(\w+)$/;
     $printer = $1;              # 汚染されません

これは、`\w+' がシェルのメタ文字にマッチしませんから、かなり安全です。
`/.+/' は安全とはいえないものですが、Perl はそれをチェックしてくれませ
んから、パターンの内容にも注意しないといけません。これは、(`$>' を
`$<' に合わせないのであれば) ファイル名を与えて、そのファイルに何か操作
を行ないたい場合に、汚染のマークを取り除く「唯一」の手段でもあります。

"Insecure PATH" というメッセージには、`$ENV{'PATH'}' に既知の値を設定し、
パスの中のディレクトリは、一般の権限では書き込みができないようになって
いることが必要です。よく言われる文句には、実行ファイルのパス名をフルパ
スで書いても、このメッセージが出るというものがあります。しかし Perl は、
その実行ファイルが PATH に依存して別のプログラムを実行しないと判断する
ことはできないのです。

汚染された値を使うことには関与しない操作で、問題が起こることもあります。
ユーザが指定したファイル名を扱うときには、ファイルテストを賢く利用して
ください。可能ならば、`open' などは、`$> = $<' を設定してから行なってく
ださい。(グループ ID の方も忘れないでください。) Perl は、汚染されたファ
イル名を読み込みのために `open' することは咎めませんので、出力に気を付
けてください。汚染チェックの仕組みは、setuid の過ちを防ぐことを目的とし
ているのであって、何も考えなくてもよいということではありません。




File: perl-ja.info, Node: 不注意によるわな, Next: スタイルガイド, Prev: セキュリティ, Up: Top

不注意によるわな
================

もっとも大きなわなは、`-w' スイッチを忘れることです。
*Note 実行とオプション::,を参照してください。プログラムで

     use strict;

と指定した上で、実行できるようにしておけば、突然の事故を未然に防いでく
れますが、その場限りのプログラムにはめんどうすぎる要求でしょう。

* Menu:

* Awk のわな::
* C のわな::
* Sed のわな::
* Shell のわな::
* Perl のわな::
* Perl4 のわな::

訳注: 原文には、Accustomed awk users、Cerebral C Programmers、Seasoned
sed programmers、Sharp shell programmers、Practicing Perl Programmers、
Penitent perl 4 Programmers といった言葉の遊びがみられますが、力及ばず
訳出できませんでした。





File: perl-ja.info, Node: Awk のわな, Next: C のわな, Prev: 不注意によるわな, Up: 不注意によるわな

Awk のわな
==========

Awk になれた方は、以下のようなことに、特に注意してください:

   * `English' モジュールを

          use English;

     としてロードすれば、awk でのようにして特殊変数を (`$RS' のように)
     参照することができます。詳しくは、*Note 定義済み変数::,を参照して
     ください。

   * Perl では、(ブロックの最後を除いて) すべての単純実行文にセミコロン
     が必要です。改行が実行文の区切り文字とはみなされません。

   * `if' や `while' には、中括弧が必須です。

   * Perl では、変数は "$" や "@" で始まります。

   * 配列のインデクスは0からです。`substr()' や `index()' での文字列中
     の位置も同様です。

   * 配列のインデクスを、数値にするか文字列にするかを決めなくてはなりま
     せん。

   * 連想配列の値は、単に参照するだけでは存在することになりません。

   * 文字列比較を行なうのか、数値比較を行なうのかを決めなければなりませ
     ん。

   * 入力を読み込むだけでは、`split' は行なわれません。自分で
     `split' を行なって、明示的に配列に入れる必要があります。また、
     `split()' 演算子は、引数が違います。

   * 現在行は通常、`$0' ではなく、`$_' に入れられています。一般に、行末
     の改行文字は削除されていません。(`$0' は、実行されているプログラム
     の名前です。)*Note 定義済み変数::,を参照してください。

   * `$<数字>' は、フィールドを参照するものではありません。これは、最後
     のパターンマッチで、マッチした部分文字列を参照するものです。

   * `$,' や `$\' を設定しない限り、`print()' 文はフィールドセパレータ
     やレコードセパレータを付与しません。`English' モジュールを使えば、
     `$OFS' や `$ORS' を設定することができます。

   * ファイルへ `print' するときには、前もって `open' しなければなりな
     せん。

   * 範囲演算子はコンマではなく `..' です。コンマ演算子は、C と同じよう
     に動作します。

   * マッチの拘束演算子は、"~" ではなく、`=~' です。(`~' はC と同じよう
     に1の補数をとる演算子です。)

   * 指数演算子は、"^" ではなく、`**' です。`^' は C と同じく XOR 演算
     子です。(awk が基本的に C と互換性がないことにお気付きかもしれませ
     んね。)

   * 連結演算子は、空文字列ではなく、`.' です。(空文字列を使うと、
     `/par/ /pat/' が解析できなくなります。3番目のスラッシュが除算演算
     子と解釈されるからです。Perl の字句解析部は、`/', `?', `>' のよう
     な演算子に対し、多少文脈依存となっています。実際、`.' 自身も、数値
     の開始になることもあります。

   * キーワード `next'、`exit'、`continue' の働きが異なります。

   * 以下の変数の働きが異なります:

          Awk       Perl
          ARGC      $#ARGV or scalar @ARGV
          ARGV[0]   $0
          FILENAME  $ARGV
          FNR       $. - something
          FS        (whatever you like)
          NF        $#Fld, or some such
          NR        $.
          OFMT      $#
          OFS       $,
          ORS       $\
          RLENGTH   length($&)
          RS        $/
          RSTART    length($`)
          SUBSEP    $;

   * `$RS' にパターンを設定することはできず、文字列だけです。

   * 疑わしいときには、awk の構文を a2p に通して、出力されたものを見て
     みましょう。





File: perl-ja.info, Node: C のわな, Next: Sed のわな, Prev: Awk のわな, Up: 不注意によるわな

C のわな
========

知的な C プログラマは、以下のことに注意すべきです:

   * `if' や `while' には、中括弧が必要です。

   * "else if" ではなく、`elsif' を使わなくてはなりません。

   * C のキーワード "break" と "continue" に相当するものは、Perlでは、それぞ
     れ `last' と `next' になっています。C とは違って、これらは
     `do { } while' 構造では使えません。

   * switch 文はありません。(しかし、大急ぎで作ることも簡単です。)

   * Perl では、変数は "$" や "@" で始めます。

   * `printf()' では、フィールド長を展開する "*" フォーマットはインプリ
     メントされていませんが、ダブルクォート文字列のフォーマット内で変数
     を展開すれば、同じことができます。

   * コメントは "/*" ではなく、"#" で開始します。

   * 任意のもののアドレスを得ることはできません。Perl 5 における同様の
     演算子はバックスラッシュですが、これはリファレンスを生成するもので
     す。

   * ARGV は大文字で書かなければなりません。

   * `link()', `unlink()', `rename()' といったシステムコールは、成功時
     に (0 ではなく)、0 以外を返します。

   * シグナルハンドラは、数字ではなくシグナル名を扱います。使用できるシ
     グナル名は、`kill -l' として確かめてください。





File: perl-ja.info, Node: Sed のわな, Next: Shell のわな, Prev: C のわな, Up: 不注意によるわな

Sed のわな
==========

熟練した sed プログラマは、以下のことに注意すべきです:

   * 置換文字列中の後方参照では "\" ではなく、"$" を使います。

   * パターンマッチのメタ文字 "(", ")", "|" は、前にバックスラッシュを
     置いてエスケープする必要はありません。

   * 範囲演算子は、コンマではなく "..." です。




File: perl-ja.info, Node: Shell のわな, Next: Perl のわな, Prev: Sed のわな, Up: 不注意によるわな

Shell のわな
============

鋭いシェルのプログラマは、以下のことに注意すべきです:

   * バッククォート演算子は、コマンド内にシングルクォートがあっても変数
     の展開を行ないます。

   * バッククォート演算子は、csh とは異なり、返された値を変換しません。

   * シェル (特に csh) は、コマンドラインごとに、何段階もの置換を行ない
     ます。Perl はダブルクォート、バッククォート、山括弧、検索パターン
     といった特定の構造でだけ置換を行ないます。

   * シェルは、一時に少しづつ解釈を行ないます。Perl は、実行前にプログ
     ラム全体をコンパイルします (コンパイル時に実行される BEGIN ブロッ
     クを除く)。

   * 引数は、$1, $2 などではなく、@ARGV から得られます。

   * 環境変数は、自動的には独立したスカラ変数として利用できるようになり
     ません。(訳注: `Env' モジュールが使用できます。)




File: perl-ja.info, Node: Perl のわな, Next: Perl4 のわな, Prev: Shell のわな, Up: 不注意によるわな

Perl のわな
===========

実践的な Perl プログラマは、以下のことに注意すべきです:

   * 多くの演算子が、スカラコンテキストとリストコンテキストとでは、動作
     が異なることを忘れないでください。詳しくは、*Note データ構造::,を
     参照してください。

   * 裸の単語、特に全てが小文字のものは、できる限り使わないでください。
     見た目だけでは、その「裸の単語」が関数なのか、文字列なのかが判断で
     きません。文字列にはクォートを、関数呼び出しには括弧を付ければ、迷
     うこともないでしょう。

   * どの組み込み関数が (`chop()' や `chdir()' のような) 単項演算子
     で、どれが (`print()' や `unlink()' のような) リスト演算子かは、
     単に眺めるだけではわかりません。(ユーザ定義のサブルーティンは、リスト演
     算子にすることができますが、単項演算子にはなりません。)
     *Note 演算子と優先順位::,を参照してください。

   * いくつかの関数が `$_' や `@ARGV' などをデフォルトにしていますが、
     同じことを期待する他の関数がデフォルトになっていないことを覚えるの
     に、辛いタイピングが必要でしょう。(have a hard time の "time" と
     type" をかけているのは、どう訳そう(^^;)

   * `=~' が必要なところで `=' を使わない事を忘れないようにしてください。
     この 2 つの構文はかなり違います:

          $x =  /foo/;
          $x =~ /foo/;

   * `do {}' 構造は本物のループではないので、ループ制御を行なえません。
     (訳注: 原文はそう言っていない気もするが。)

   * ローカル変数は、`my()' で済むところでは、これで済ませること (使え
     ない場所については、*Note フォーマット文::,を参照してください)。
     `local()' を使えば、グローバル変数に対するローカルな値を与えますが、
     動的スコープの不慮の副作用の可能性は、そのままです。





File: perl-ja.info, Node: Perl4 のわな, Prev: Perl のわな, Up: 不注意によるわな

Perl4 のわな
============

悔い改めた Perl 4 のプログラマは、以下に示すリリース 4 とリリース 5 の
間の互換性のない修正点に注意すべきです:

   * ダブルクォートタイプの文字列で、@ は必ず配列を展開します。@ を展開
     しないようにするように、バックスラッシュを使わなければならないプロ
     グラムもあるでしょう。

   * Perl にとって文字列のように見えていた裸の単語は、それ以前に、その
     名前のサブルーティンが定義されていれば、サブルーティンコールと解釈
     されるようになりました。たとえば:

          sub SeeYa { die "Hasta la vista, baby!" }
          $SIG{QUIT} = SeeYa;

     Perl 4 では、シグナルハンドラを設定しますが、Perl 5 では、実際に関
     数を呼び出し、その結果を設定します `!-w' スイッチを使えば、このよ
     うなものを探してくれます。

   * "_" で始まるシンボルは、$_ 自身 (と @_ など) を除いて、`main' パッ
     ケージに存在しなくてもよくなりました。

   * `s'$lhs'$rhs'' では、どちら側でも展開を行なわなくなりました。以前は、
     `$rhs' は展開しませんでしたが、`$lhs' は展開しました。

   * `splice()' の 2 番目の引数と 3 番目の引数が (本に書いてあったよう
     に) リストコンテキストではなく、スカラコンテキストで評価されるよう
     になりました。

   * 優先順位によって意味エラーが起こります:

          shift @list + 20;
          $n = keys %map + 20;

     これらがうまく行けば、以下がうまく行きません:

          sleep $dormancy + 20;

   * `open FOO || die' は、もはや正しくありません。ファイルハンドルの前
     後に括弧が必要です。一時的にサポートされていましたので、このような
     構文を使うと致命的ではない (がサプレスできない) 警告が出ます。(訳
     注: `or' 演算子を使用することができます。)

   * フォーマット文の引数リストの要素は、リストコンテキストで評価される
     ようになりました。このことにより、リスト値を展開できるようになりま
     した。

   * 最適化によってなくなるブロック内に `goto' することはできません。
     ちぇっ。

   * 空白を変数名やクォート構文の区切り文字に使うことは、もはや構文的に
     正しくなくなりました。ちぇっ、ちぇっ。

   * 関数 `caller()' は呼び元がないとき、スカラコンテキストで偽を返すよ
     うになりました。これにより、ライブラリファイルは、自分が
     `require' されたものかを判断できます。

   * `m//g' は状態を正規表現の方にではなく、検索文字列の方に括りつけます。

   * `sort' のサブルーティン名として、`reverse' というものは、許されな
     くなりました。

   * taintperl は、もはや独立した実行ファイルとして存在しません。自動的
     に汚染チェックが on にならないときのために、`-T' スイッチが用意さ
     れています。

   * ダブルクォート文字列が、エスケープされていない $ や @ で終了するこ
     とがなくなりました。

   * 古い `while/if BLOCK BLOCK' の構文は、もはやサポートされていません。

   * 配列に負の添え字を与えると、配列の終わりから数えるようになりました。

   * コンマ演算子をスカラコンテキストで使うと、引数にもスカラコンテキス
     トが適用されることを保証するようになりました。

   * `**' 演算子は、単項のマイナスよりも強く結合するようになりました。
     このように動作するように、ドキュメントに書かれていましたが、そうなっ
     ていませんでした。

   * `$#array' を小さく設定すると、それ以降の配列の要素を捨てます。

   * `delete()' は `tie' された配列の古い値を返すことが保証されません。
     この機能は、いくつかのモジュールにとってインプリメントがめんどうだ
     からです。

   * 異なるエラーメッセージがあります。

   * いくつかのバグが、迂闊にも修正されているかもしれません。




File: perl-ja.info, Node: スタイルガイド, Next: 応用プログラムインタフェース, Prev: 不注意によるわな, Up: Top

スタイルガイド
**************

もちろん、人それぞれにフォーマットの好みがありますが、読みやすく、理解
しやすく、保守しやすいプログラムにするための一般的なガイドラインも存在
します。

コードレイアウトの美学に関して、唯一 Larry が強く気にかけることは、複数
行に渡る BLOCK の閉じ中括弧の位置を、その構文を開始するキーワードとカラ
ム位置を揃えるということです。この他には、それ程に強くはない好みとして:

   * 4カラムのインデント。

   * 開き中括弧は、できるだけキーワードと同じ行におくようにする。さもな
     くば、キーワードとカラムを揃える。

   * 複数行ブロックの中括弧の前は空ける。

   * 1行の BLOCK は中括弧も含めて1行にしてよい。

   * セミコロンの前には空白を入れない。

   * 「短い」1行の BLOCK では、セミコロンを省く。

   * ほとんどの演算子の両側には空白を入れる。

   * (大括弧の中の) 「複雑な」添字の両側には空白を入れる。

   * 動作内容の異なる、かたまりごとに空行を入れる。

   * `else' は行替えする。

   * 関数名と開き括弧の間に空白を入れない。

   * コンマのあとには空白を入れる。

   * 長い行は (`and' と `or' 以外の) 演算子のあとで改行する。

   * その行内でマッチする最後の括弧の後にスペースを入れる。

   * 対応する項目は、カラムを揃えて縦に整列する。

   * 明瞭さの妨げにならない範囲で、余分な句読点などは省く。

Larry はこれらのことに対して彼なりの理由を持っていますが、他の人が同じ
ように考えなくても文句をいう筋合いのものではありません。

もう少し本質的なスタイルの問題も考えておくべきでしょう:

   * 何らかの方法で書けるからといって、その方法でやらなくてはならないこ
     とはありません。Perl は何でもいくつかの方法でできるように設計され
     ていますので、もっとも読みやすいものを選ぶとよいでしょう。たとえば、

          open(FOO,$foo) || die "Can't open $foo: $!";

     という方が

          die "Can't open $foo: $!" unless open(FOO,$foo);

     のように、文の重要なポイントを修飾子に隠してしまうよりも良いでしょ
     う。また、

          print "Starting analysis\n" if $verbose;

     の方が

          $verbose && print "Starting analysis\n";

     よりも良いでしょう。使う人が `-v' と入力したかどうかを判定するのが
     ポイントではないからです。

     同様に、演算子にデフォルトの値が用意されているからといって、それを
     利用しなければならないというものではありません。デフォルトは、怠け
     者のシステムプログラマが「一時的な」プログラムを書くためにあるので
     す。プログラムを読みやすくしたいと思うならば、ちゃんと引数を与える
     ようにしてください。

     さらには、多くの場所で括弧を省くことができますが、これは決して省か
     なければならないということではありません:

          return print reverse sort num values %array;
          return print(reverse(sort num (values(%array))));

     疑わしいときには括弧を付けるべきです。少なくとも、viで % キーを使っ
     て、跳ねまわることができます。

     特に疑わしい場合でなくても、みなさんの後を引き継いでコードのメンテ
     をする人のことを考えてあげてください。間違ったところに括弧を付けて
     しまうかも知れません。

   * ループの最初や最後で抜けられるように、妙に莫迦げた細工をしないこと。
     Perl では、`last' 演算子を用意しているので、ループの途中で抜けるこ
     とができるのです。目立つように、少しばかり突き出して置けばよいので
     す:

          LINE:
              for (;;) {
                  statements;
                last LINE if $foo;
                  next LINE if /^#/;
                  statements;
              }

   * ループラベルを付けるのを恐れてはいけません。多重のループからの脱出
     するためでもありますが、読みやすくするためでもあるのです。上の例を
     参照してください。

   * 移植性のため、すべてのマシンでインプリメントされていない機能を使う
     場合には、 `eval' の中で使ってみて調べてください。その機能がインプ
     リメントされているバージョンやパッチレベルがわかるのであれば、 $]
     (English モジュールを使っているときには $PERL_VERSION ) を調べて、
     実装されているかを見ることができます。 `Config' モジュールで Perl
     をインストールした時に、 Configure プログラムで決定された値を引き
     出すことができます。

   * 意味のある識別子名を使ってください。何を意味しているのかがわからな
     くなれば、きっと問題になるでしょう。

   * ごちゃごちゃした正規表現には、 `/x' 修飾子を使って、空白を入れ、な
     るべく見やすくするようにしましょう。正規表現の中にスラッシュやバッ
     クスラッシュを使っている時には、区切文字にスラッシュを使うのは避け
     ましょう。

   * リスト演算子に括弧を付けなければならなくなるのを避け、 `&&' や
     `||' といった記号的な演算子の頻度を下げるために " `and' "や "
     `or' " という新しい演算子を使ってください。過剰な `&' や括弧を避け
     るために、サブルーティンは関数やリスト演算子として使いましょう。

   * 何回も `print()' 文を繰り返すよりは、ヒアドキュメントを使ってくだ
     さい。

   * 対応するものは縦に並べましょう。特に 1 行に収まらないくらい長い場
     合には。

          $IDX = $ST_MTIME;
          $IDX = $ST_ATIME       if $opt_u;
          $IDX = $ST_CTIME       if $opt_c;
          $IDX = $ST_SIZE        if $opt_s;

          mkdir $tmpdir, 0700 or die "can't mkdir $tmpdir: $!";
          chdir($tmpdir)      or die "can't chdir $tmpdir: $!";
          mkdir 'tmp',   0777 or die "can't mkdir $tmpdir/tmp: $!";

   * 変換を行なうときに並べることでわかりやすくなるならば、並べましょう。

          tr [abc]
             [xyz];

   * 再利用性を考えましょう。同じようなことをまたしなくてはならないかも
     しれないときに、一時凌ぎのスクリプトに頭を悩ませることはないでしょ
     う。コードを一般化することを考えてください。モジュールやオブジェク
     トクラスを書くことを考えてください。 `use strict' や `-w' を有効に
     して、コードの不明瞭な部分が無いようにしてください。コードを減らす
     ことを考えてください。全体の見方を変えることも考えてください。さら
     に ... やめましょう。

   * 一貫性をもって。

   * 良識をもって。




File: perl-ja.info, Node: 応用プログラムインタフェース, Next: 拡張を行なうための内部関数, Prev: C からの呼び出し法, Up: Top

応用プログラムインタフェース
****************************

XS は、Perl と Perl といっしょに使おうとする C ライブラリの間の拡張イン
タフェースを作るための言語です。XS インタフェースは、Perl とリンクする
ことのできる、新しいライブラリを作るためのライブラリと組み合わせて使わ
れます。XSUB は、XS 言語内の関数で、Perl アプリケーションインタフェース
の中核を成すものです。

XS コンパイラは、xsubpp と呼ばれています。このコンパイラは、実際には C
の関数を装って XSUB に Perl の値を操作させるために必要な構造を埋め込み、
Perl に XSUB をアクセスさせるために必要なグルー関数を作ります。コンパイ
ラは、C 関数の引数や変数を Perl の値にマッピングする方法を決めるために、
`typemap' を使用します。デフォルトの `typemap' では、多くの一般的な C
の型を扱っています。新たにリンクされるライブラリのための、特殊な構造体
や型を扱うときには、補助的な `typemap' を作らなければなりません。

以下の多くの例では、Perl と ONC+RPC 結合ライブラリ関数のインタフェース
の作成に焦点をおいています。特に、 `rpcb_gettime()' 関数が、XS 言語の多
くの機能を示すために用いられています。この関数は、2 つの引数をとります。
一つめの引数が入力用で、ふたつめの引数が出力用です。この関数はまた、ス
テータス値を返します。

      bool_t rpcb_gettime(const char *host, time_t *timep);

C からは、以下のような形でこの関数が呼ばれます。

     #include <rpc/rpc.h>
     bool_t status;
     time_t timep;
     status = rpcb_gettime( "localhost", &timep );

この関数と Perl の間で直接変換を行なうための XSUB を作れば、次のようなコー
ドで、Perl からその XSUB が使われます。変数 $STATUS と変数
$TIMEP に、この関数の出力が得られます。

     use RPC;
     $status = rpcb_gettime( "localhost", $timep );

以下に示す XS ファイルは、 `rpcb_gettime()' 関数へのインタフェースの一
例となる XS サブルーティン (XSUB のこと) を示しています。この XSUB が
C と Perl の間の直接変換を行ない、Perlからのインタフェースも確保します。
XSUB は上に示したような使い方で、Perl から起動されます。XS ファイルでは
いつも、最初に `EXTERN.h' 、 `perl.h' 、 `XSUB.h' のための 3 つの
`#include' 文を指定しないといけません。この方法や他の方法の拡張は、後述
します。

     #include "EXTERN.h"
     #include "perl.h"
     #include "XSUB.h"
     #include <rpc/rpc.h>

     MODULE = RPC  PACKAGE = RPC

     bool_t
     rpcb_gettime(host,timep)
          char *  host
          time_t  &timep
          OUTPUT:
          timep

XSUB を使うものを含めて、どんな Perl への拡張も、ブートストラップのよう
に起動時に、その拡張を Perl に組み込む Perl モジュールを用意するように
なっています。このモジュールが、拡張機能や変数を Perl プログラムにエク
スポートし、拡張のためのXSUB を Perl に組み込みます。以下のモジュールは、
このドキュメントのほとんどの例で使われ、前に示したように Perl から
`use' コマンドで使われるはずです。Perl モジュールについては、このドキュ
メント内でも、もう少し詳しく触れます。

     package RPC;

     require Exporter;
     require DynaLoader;
     @ISA = qw(Exporter DynaLoader);
     @EXPORT = qw( rpcb_gettime );

     bootstrap RPC;
     1;

このドキュメントを通じて、さまざまな `rpcb_gettime()' XSUB へのインタ
フェースを研究しています。XSUB は、場合によって、順番や数の異なる引数を
とるようになっています。どの場合にも、XSUB は、Perl と実際の C の
`rpcb_gettime()' 関数の間を取り持つもので、XSUB が実際の
`rpcb_gettime()' 関数を常に正しい引数で呼ぶことを保証しなければなりませ
ん。この抽象化された仲介によって、プログラマは、C 関数にいっそう Perl
風なインタフェースを用意することができるようになっているのです。

* Menu:

* XSUB 解剖学::
* 引数スタック::
* RETVAL 変数::
* MODULE キーワード::
* PACKAGE キーワード::
* PREFIX キーワード::
* OUTPUT キーワード::
* CODE キーワード::
* PPCODE キーワード::
* NO_INIT キーワード::
* BOOT キーワード::
* CLEANUP キーワード::
* 関数引数の初期化::
* デフォルト引数値::
* 可変長引数リスト::
* Undef 値や空リストを返す::
* コメントや C プリプロセッサディレクティブを使用する::
* XS を C++ で使用する::
* Perl 変数::
* インタフェースの戦略::
* Perl モジュール::
* Perl のオブジェクトと C の構造体::
* C のヘッダファイルと Perl::
* 新しい拡張モジュールの作成::
* Typemap::
* XS の使用例::


AUTHOR
======
Dean Roehrich <roehrich@cray.com> September 27, 1994





File: perl-ja.info, Node: XSUB 解剖学, Next: 引数スタック, Prev: 応用プログラムインタフェース, Up: 応用プログラムインタフェース

XSUB 解剖学
===========

以下の XSUB では、Perl プログラムから `sin()' という C のライブラリ関数
をアクセスできるようにしています。この XSUB は、一つの引数をとり、一つ
の値を返す C の関数を模倣します。

     double
     sin(x)
       double<tab>x

コンパイラは、引数の名前と型の間に 1 つのタブがあることを期待しており、
型の前には空白は、あっても無くてもかまいません。C のポインタを使うとき
には、上記の `rpcb_gettime()' 関数で示したように、間接指定演算子 `*' は、
型の一部と考えるべきであり、アドレス演算子 `&' は、変数の一部と考えるべ
きです。C の型に関する修飾子と単項演算子の扱いについては、 *Note
typemap::, の節も参照してください。

関数の引数リストでは、開き括弧の後や、閉じ括弧の前に空白を入れてはなり
ません。

     誤った表記                     正しい表記

     double                         double
     sin( x )                       sin(x)
       double  x                      double  x

関数名と関数型は、行を改めて書かなくてはなりません。

     誤った表記                     正しい表記

     double sin(x)                    double
       double  x                      sin(x)
                                        double  x





File: perl-ja.info, Node: 引数スタック, Next: RETVAL 変数, Prev: XSUB 解剖学, Up: 応用プログラムインタフェース

引数スタック
============

引数スタックは、XSUB への引数として渡される値や XSUB からの返却値を蓄え
るために使用します。実際には、すべての Perl の関数が、スタック上の自分
の範囲を決めて、同時にこのスタックに値を蓄えています。このドキュメント
では、アクティブな関数に属するスタック上の最初の範囲を、その関数に対し
て位置0というようにして参照するようにします。

`x' をスタック上のその XSUB の部分の位置を示すものとするとき、XSUB は、
自分のスタック引数を `ST(x)' というマクロで参照できます。その関数の位置
`0' は、XSUB には、 `ST(0)' という形で伝えられることになります。XSUB へ
の引数と XSUB からの返却値は、いつも `ST(0)' の位置から置かれることになっ
ています。多くの簡単なケースでは、xsubpp コンパイラは、 `typemap' に入
れる埋め込みプログラムで、引数スタックを扱うために必要なコードを生成し
ます。より複雑なケースでは、プログラマがそのコードを用意しなくてはなり
ません。





File: perl-ja.info, Node: RETVAL 変数, Next: MODULE キーワード, Prev: 引数スタック, Up: 応用プログラムインタフェース

RETVAL 変数
===========

RETVAL 変数は、常に C のライブラリ関数の関数型にマッチするマジック変数
です。xsubpp コンパイラは、XSUB ごとに、この変数を用意し、デフォルトで
は、呼び出される C のライブラリ関数の返却値を保持するためにこの変数を使
用します。簡単なケースでは、RETVAL の値は、Perl が XSUB の返却値として
受け取れるように、引数スタックの `ST(0)' に置かれます。

XSUB の関数型を `void' とした場合には、この関数に対して、コンパイラは
RETVAL 変数を用意しません。 `PPCODE:' ディレクティブを使うときには、
RETVAL 変数は必要ありません。





File: perl-ja.info, Node: MODULE キーワード, Next: PACKAGE キーワード, Prev: RETVAL 変数, Up: 応用プログラムインタフェース

MODULE キーワード
=================

MODULE キーワードは、XS コードを開始し、定義される関数のパッケージを示
すために使われます。最初の `MODULE' キーワードの前のテキストはすべて、
C のコードとみなされ、透過的に出力に渡されます。すべての XS モジュール
には、XSUB をフックして、Perl に渡すために使われる `bootstrap' 関数を用
意します。この`bootstrap' 関数のパッケージ名は、XS ソースファイル中で最
後の`MODULE' 文の値にマッチします。MODULE の値は、一つの XS ファイルの
中では一定にしておくべきですが、そうしておかなければならないと決められ
ているものではありません。

以下の例は、XS コードを開始し、すべての関数を RPC というパッケージに置
くようにするものです。

     MODULE = RPC





File: perl-ja.info, Node: PACKAGE キーワード, Next: PREFIX キーワード, Prev: MODULE キーワード, Up: 応用プログラムインタフェース

PACKAGE キーワード
==================

XS ソースファイル内で関数を、複数のパッケージに分けなければならないとき、
`PACKAGE' キーワードが使われます。このキーワードが使われるときには、
`MODULE' キーワードとともに用い、その直後に置かなければなりません。

     MODULE = RPC  PACKAGE = RPC

     [ パッケージ RPC の XS コード ]

     MODULE = RPC  PACKAGE = RPCB

     [ パッケージ RPCB の XS コード ]

     MODULE = RPC  PACKAGE = RPC

     [ パッケージ RPC の XS コード ]

このキーワードは省略可能であり、冗長な情報となることもありますが、いつ
も使用するようにした方が良いでしょう。このキーワードを使うことによって、
XSUB が目的のパッケージに入れられることを保証するのです。





File: perl-ja.info, Node: PREFIX キーワード, Next: OUTPUT キーワード, Prev: PACKAGE キーワード, Up: 応用プログラムインタフェース

PREFIX キーワード
=================

`PREFIX' キーワードは、Perl の関数名から取り除くプリフィクスを指定する
ものです。C の関数が `rcpb_gettime()' で、 PRIFIX の値が `rcpb_' であれ
ば、この関数は、Perl からは `gettime()' というように見えます。

このキーワードが使われるときには、 `PACKAGE' キーワードのあとに置きます。
`PACKAGE' が使われなければ、 `MODULE' キーワードのあとに置きます。

     MODULE = RPC  PREFIX = rpc_

     MODULE = RPC  PACKAGE = RPCB  PREFIX = rpcb_





File: perl-ja.info, Node: OUTPUT キーワード, Next: CODE キーワード, Prev: PREFIX キーワード, Up: 応用プログラムインタフェース

OUTPUT: キーワード
==================

`OUTPUT:' キーワードは、XSUB の終了時に、(新しい値が Perl から見えるよ
うに) 特定の関数引数を更新しなければならないか、特定の値を呼び出しもと
の Perl 関数に返さなければならないことを示します。上記の `sin()' 関数の
ような簡単な関数では、 RETVAL 変数が、自動的に出力値として使われます。
より複雑な関数では、xsubpp コンパイラがどの変数が出力変数であるかを判断
するために助けが必要となります。

このキーワードは、通常 `CODE:' キーワードを補足するために使います。
`CODE:' キーワードが存在するとき、 RETVAL 変数が、出力変数として認識さ
れることはなくなります。 `OUTPUT:' キーワードを使用すると、コンパイラに
RETVAL を実際に出力変数として使うことを指示することになります。

`OUTPUT:' キーワードは、関数の引数が出力変数であることを示すために
も使われます。これは、その引数が関数内で変更されているときに、更新結果を
Perl から見えるようにするために必要となることがあります。関数引数を
RETVAL 変数といっしょに `OUTPUT:' の下に並べる場合には、
RETVAL 変数は最後に置かないといけません。

     bool_t rpcb_gettime(host,timep) char * host time_t &timep OUTPUT:
     timep `OUTPUT:' キーワードはまた、出力引数を `typemap' ではなく、
     マッチするコードに対応させるためにも使います。

     bool_t
     rpcb_gettime(host,timep)
          char *  host
          time_t  &timep
          OUTPUT:
          timep<tab>sv_setnv(ST(1), (double)timep);





File: perl-ja.info, Node: CODE キーワード, Next: PPCODE キーワード, Prev: OUTPUT キーワード, Up: 応用プログラムインタフェース

CODE: キーワード
================

このキーワードは、C の関数に対して特別な扱いを要求する、比較的複雑な
XSUB で使われます。 RETVAL 変数も使えますが、`OUTPUT:' キーワードの下に
指定して、実際に値を返すことを示さなければなりません。

次の XSUB は、引数に特別な扱いが要求される C 関数のためのものです。
Perl 側の用法をまず示します。

     $status = rpcb_gettime( "localhost", $timep );

XSUB は以下の通りです。

     bool_t rpcb_gettime(host,timep)
           char *  host
           time_t  timep
           CODE:
                RETVAL = rpcb_gettime( host, &timep );
           OUTPUT:
           timep
           RETVAL

ここに示す多くの例で、 `CODE:' ブロック (と他のブロック) が、中括弧 (
`{} と `'' ) で囲まれます。これによって、 `CODE:' ブロックを複雑な
INPUT typemap から保護し、結果の C のコードが正しいものとなることを保証
してくれます。





File: perl-ja.info, Node: PPCODE キーワード, Next: NO_INIT キーワード, Prev: CODE キーワード, Up: 応用プログラムインタフェース

PPCODE: キーワード
==================

`PPCODE:' キーワードは、 `CODE:' キーワードの別形式で、XSUB の返却値を
扱うために、引数スタックを制御するコードを用意していることを xsubpp コ
ンパイラに伝えるものです。単独の値よりも、値のリストを XSUB から返した
いこともあるでしょう。こういった場合には、 `PPCODE:' を使って、明示的に
値のリストをスタックにプッシュしなければなりません。  `PPCODE:' キーワー
ドと `CODE:' キーワードは、同一の XSUB 内で同時に用いることはありません。

次の XSUB では、C の `rpcb_gettime()' 関数を呼び、この関数からの二つの
出力値 `timep' と `status' を、一つのリストにして Perlに返しています。

     void rpcb_gettime(host)
          char *  host
          PPCODE:
          {
          time_t  timep;
          bool_t  status;
          status = rpcb_gettime( host, &timep );
          EXTEND(sp, 2);
          PUSHs(sv_2mortal(newSVnv(status)));
          PUSHs(sv_2mortal(newSVnv(timep)));
          }

実際に `rpcb_gettime()' を呼ぶためのコードと、返却値を正しく引数スタッ
ク上に置くためのコードを、用意しておかねばなりません。

この関数の型を `void' とすることで、 RETVAL 変数が必要ないか、
使われないものであり、作る必要がないものであることを、xsubpp コンパイラ
に伝えることになります。関数型 `void' は、ほとんどの場合、
`PPCODE:' ディレクティブといっしょに使われるはずです。

引数スタック上に二つの返却値の場所を確保するために、 `EXTEND()' マクロ
を使っています。 `PPCODE:' ディレクティブの指定によって、xsubpp コンパ
イラが、sp というスタックポインタを作り、それが`EXTEND()' マクロ内で
`this' ポインタとして使われます。その後、`PUSHs()' マクロで値を順にスタッ
クに積みます。

これで、以下のようにして、Perl から `rpcb_gettime()' 関数を呼ぶことがで
きるようになりました。

     ($status, $timep) = rpcb_gettime("localhost");





File: perl-ja.info, Node: NO_INIT キーワード, Next: BOOT キーワード, Prev: PPCODE キーワード, Up: 応用プログラムインタフェース

NO_INIT キーワード
==================

`NO_INIT' キーワードは、ある関数引数が、出力値としてだけ使われることを
示すために用います。xsubpp コンパイラは、通常、引数スタックからすべての
関数引数の値を読み取り、その関数のエントリ上の C 変数へ、代入を行なうコー
ドを生成します。 `NO_INIT' が指定されるとコンパイラは、ある引数が入力で
はなく、出力に使われ、関数が終了する前に処理されることを認識します。

次の例では、 `rpcb_gettime()' 関数のバリエーションを示します。この関数
では、変数 TIMEP を出力のみの変数として使用していて、初期状態の値には関
与しません。

     bool_t
     rpcb_gettime(host,timep)
          char *  host
          time_t  &timep = NO_INIT
          OUTPUT:
          timep





File: perl-ja.info, Node: BOOT キーワード, Next: CLEANUP キーワード, Prev: NO_INIT キーワード, Up: 応用プログラムインタフェース

BOOT: キーワード
================

`BOOT:' キーワードは、拡張モジュールの `bootstrap' 関数にコードを追加す
るために使用します。 `bootstrap' 関数は、xsubpp コンパイラによって作ら
れ、普通は Perl に任意の XSUB を登録するために必要な実行文が納められて
います。 `BOOT:' キーワードを使うと、 `bootstrap' 関数にさらにの実行文
を付け加えるように xsubppコンパイラに伝えることができます。

このキーワードは、最初の `MODULE' キーワード以降であれば、どこでも使う
ことができ、行内に単独で使用します。このキーワード以降、最初の空行まで
が、コードを記述したブロックとなります。

     BOOT:
     # bootstrap 関数の実行時に、
     # 以下のメッセージが表示されます。
     printf("Hello from the bootstrap!\n");





File: perl-ja.info, Node: CLEANUP キーワード, Next: 関数引数の初期化, Prev: BOOT: キーワード, Up: 応用プログラムインタフェース

CLEANUP: キーワード
===================

このキーワードは、XSUB が終了する前に、特別な後処理を必要とする場合に使
われます。 `CLEANUP:' キーワードを使用する場合には、XSUB 内の、どの
`CODE:' ブロック、 `PPCODE:' ブロック、 `OUTPUT:' セクションよりも後に
なければなりません。 `CLEANUP:' ブロックとして記述されるコードは、XSUB
内の最後の実行文として、追加されます。





File: perl-ja.info, Node: 関数引数の初期化, Next: デフォルト引数値, Prev: CLEANUP キーワード, Up: 応用プログラムインタフェース

関数引数の初期化
================

関数の引数は、通常、引数スタックからの値で初期化されます。typemap には、
Perl の値を C の引数に変換するために使われる、コードを入れています。し
かし、プログラマの方で、 `typemap' をオーバライドして、別の初期化コード
を与えることができます。

次のコードでは、関数引数の初期化コードの与え方を示します。初期化コード
は、出力に加えられる前に、コンパイラによって評価されるので、ダブルクォー
トのようなものを文字どおりに解釈させたいときには、バックスラッシュで保
護しなければなりません。

     bool_t
     rpcb_gettime(host,timep)
          char *  host = (char *)SvPV(ST(0),na);
          time_t  &timep = 0;
          OUTPUT:
          timep

これは、引数のデフォルト値を指定するために、使うべきものではありません。
これは通常、関数引数を使用する前に、別のライブラリ関数で処理しなければ
ならないときに使います。デフォルト引数については、次の節で扱います。





File: perl-ja.info, Node: デフォルト引数値, Next: 可変長引数リスト, Prev: 関数引数の初期化, Up: 応用プログラムインタフェース

デフォルト引数値
================

関数の引数に対するデフォルト値は、引数リスト内に代入文を置くことで、指
定することができます。デフォルト値としては、数値か文字列を指定すること
ができます。デフォルトは、引数リストの右側の引数から順にしか指定できま
せん。

`rpcb_gettime()' に対する XSUB にデフォルトの HOST 値を持てるようにする
には、XSUB への引数を並べ替えるとよいでしょう。その XSUB が、本当の
`rpcb_gettime()' 関数を正しい引数順序で呼ぶことになります。Perl から、
この XSUB を呼ぶときには、次のどちらの形式でも使えることになります。

     $status = rpcb_gettime( $timep, $host );

     $status = rpcb_gettime( $timep );

XSUB は次のようなものになるでしょう。 `CODE:' ブロックが、本当の
`rpcb_gettime()' 関数を、正しい順序の引数で呼び出すために使われます。

     bool_t
     rpcb_gettime(timep,host="localhost")
          char *  host
          time_t  timep = NO_INIT
          CODE:
               RETVAL = rpcb_gettime( host, &timep );
          OUTPUT:
          timep
          RETVAL





File: perl-ja.info, Node: 可変長引数リスト, Next: Undef 値や空リストを返す, Prev: デフォルト引数値, Up: 応用プログラムインタフェース

可変長引数リスト
================

引数リストに省略記号 `(...)' を指定することで、XSUB は可変長の引数リス
トを持てるようになります。省略記号のこの使い方は、ANSI C のものと同様で
す。xsubpp コンパイラが、すべてのXSUB に用意している変数 items を調べる
ことで、XSUB に渡された引数の数を知ることができます。この仕組みを使って、
大きさのわからない引数のリストを受け取る XSUB を作ることができます。

`rpcb_gettime()' XSUB の host 引数は省略できますから、XSUB が可変個数の
引数をとれることを示すために、省略記号を使うことができます。Perl は、こ
の XSUB を次のどちらかの形式で呼び出すことができます。

     $status = rpcb_gettime( $timep, $host );

     $status = rpcb_gettime( $timep );

省略記号を持つ XS コードです。

     bool_t
     rpcb_gettime(timep, ...)
          time_t  timep = NO_INIT
          CODE:
          {
          char *host = "localhost";

          if( items > 1 )
               host = (char *)SvPV(ST(1), na);
          RETVAL = rpcb_gettime( host, &timep );
          }
          OUTPUT:
          timep
          RETVAL





File: perl-ja.info, Node: Undef 値や空リストを返す, Next: コメントや C プリプロセッサディレクティブを使用する, Prev: 可変長引数リスト, Up: 応用プログラムインタフェース

Undef 値や空リストを返す
========================

関数の異常を示すために、状態変数を別に用意するよりも、単に`undef' 値や
空リストを返したい場合があります。 `rpcb_gettime()' 関数を、そのような
場合にあてはめてみましょう。この関数がうまくいったときには、時刻を返し、
問題があったときには、 `undef' 値を返すようにしてみましょう。次の Perl
コードでは、 $TIMEP の値が `u' か有効な時刻のどちらかになることになりま
す。

$timep = rpcb_gettime( "localhost" );

次の XSUB では、関数型に `void' を用いて、RETVAL 変数を作らないようにし、
`CODE:' ブロックを使って、必要なコードはすべて用意していることをコンパ
イラに示しています。 `sv_newmortal()' の呼び出しで返却値を `undef' で初
期化し、これをデフォルトの返却値としています。

     void
     rpcb_gettime(host)
          char *  host
          CODE:
          {
          time_t  timep;
          bool_t x;
          ST(0) = sv_newmortal();
          if( rpcb_gettime( host, &timep ) )
               sv_setnv( ST(0), (double)timep);
          }

次の例では必要となったときに、明示的に `undef' 値を返却値として設定する
方法を示します。

     void
     rpcb_gettime(host)
          char *  host
          CODE:
          {
          time_t  timep;
          bool_t x;
          ST(0) = sv_newmortal();
          if( rpcb_gettime( host, &timep ) ){
               sv_setnv( ST(0), (double)timep);
          }
          else{
               ST(0) = &sv_undef;
          }
          }

空リストを返すには、 `PPCODE:' ブロックを使ったうえで、スタック上に返却
値を積まないでおきます。

     void
     rpcb_gettime(host)
          char *  host
          PPCODE:
          {
          time_t  timep;
          if( rpcb_gettime( host, &timep ) )
               PUSHs(sv_2mortal(newSVnv(timep)));
          else{
          /* スタックに何も積まないので、 */
          /* 暗黙のうちに空リストが返される。 */
          }
          }





File: perl-ja.info, Node: コメントや C プリプロセッサディレクティブを使用する, Next: XS を C++ で使用する, Prev: Undef 値や空リストを返す, Up: 応用プログラムインタフェース

コメントや C プリプロセッサディレクティブを使用する
===================================================

`CODE:' ブロック、 `PPCODE:' ブロック、 `BOOT:' セクション、
`CLEANUP:' ブロック内では、コメントや C プリプロセッサディレクティブを
記述することができます。コンパイラは、プリプロセッサディレクティブには
触れずに渡し、コメント行を削除します。行の最初に `#' を置くことで、
XSUB にコメントを入れることができます。コメントが、C のプリプロセッサディ
レクティブに見えることの無いように注意し、そのように解釈されないように
すべきです。





File: perl-ja.info, Node: XS を C++ で使用する, Next: Perl 変数, Prev: Undef 値や空リストを返す, Up: 応用プログラムインタフェース

XS を C++ で使用する
====================

関数が、C++ のメソッドとして定義されているときには、その最初の引数はオブ
ジェクトポインタとみなされます。オブジェクトポインタは、 THIS とい
う変数に入れられることになります。対象となるオブジェクトは、C++ の
`new()' 関数で生成され、Perl の`sv_setptrobj()' マクロで
`bless' されたものです。Perl によるオブジェクトの `bless' は、
`T_PTROBJ typemap' で扱うことができます。

メソッドが `static' で定義されているときには、その C++ の関数を
`class::method()' という構文で呼び出すことになります。メソッドが
`static' でないならば、その関数を `THIS->method()' という構文で呼び出し
ます。





File: perl-ja.info, Node: Perl 変数, Next: インタフェースの戦略, Prev: XS を C++ で使用する, Up: 応用プログラムインタフェース

Perl 変数
=========

これから、XSUB でどのように Perl の変数 `$host' をアクセスするかを示し
ます。 `perl_get_sv()' という関数が、内部的に `SV' (スカラ変数) といわ
れている変数へのポインタを得るために使用されます。変数の名前には、パッ
ケージ名 RPC が付け加えられますので、 `perl_get_sv()' で $host がどのパッ
ケージにあるかがわかります。パッケージ名がないときには、
`perl_get_sv()' では、パッケージ `main' で変数を探すことになります。そ
れから、`SV' の内容への `char*' ポインタを取得するため、マクロ
`SvPVX()' を使って `SV' の被参照を行ないます。

     void
     rpcb_gettime()
          PPCODE:
          {
          char *host;
          SV *hostsv;
          time_t timep;

          hostsv = perl_get_sv( "RPC::host", FALSE );
          if( hostsv != NULL ){
               host = SvPVX( hostsv );
               if( rpcb_gettime( host, &timep ) )
                    PUSHs(sv_2mortal(newSVnv(timep)));
          }
          }

この XSUB を呼ぶためには、次のような Perl コードを使います。

     $RPC::host = "localhost";
     $timep = rpcb_gettime();

上記の例では、`SV' に C の `char*' が入っていましたが、Perl の
スカラ変数には、数値やリファレンスも入れることができます。`SV' に C
の `int' が入っているときには、`SV' の被参照にマクロ
`SvIVX()' を使い、C の `double' が入っているときには、
`SvNVX()' を使います。

`SV' が Perl のリファレンスのときには、`SV' の被参照にマクロ`SvRV()' が
使えます。結果は実際の Perl の変数を指す別の `SV'となります。これは、
`SvPVX()' 、 `SvNVX()' 、 `SvIVX()' で被参照することができます。次の
XSUB では、 `SvRV()' を使っています。

     void rpcb_gettime()
          PPCODE:
          {
          char *host;
          SV *rv;
          SV *hostsv;
          time_t timep;

          rv = perl_get_sv( "RPC::host", FALSE );
          if( rv != NULL ){
               hostsv = SvRV( rv );
               host = SvPVX( hostsv );
               if( rpcb_gettime( host, &timep ) )
                    PUSHs(sv_2mortal(newSVnv(timep)));
          }
          }

次の Perl コードは、 `$MY::host' へのリファレンスとなる、変数
$RPC::HOST を生成します。変数 $MY::HOST には、使用するホスト名が入って
います。

     $MY::host = "localhost";
     $RPC::host = \$MY::host;
     $timep = rpcb_gettime();

`perl_get_sv()' の第 2 引数は、上の例に示したように、通常は`FALSE' にし
ます。この引数を `TRUE' とすると、変数が存在しないときに、生成するよう
になります。空の `SV' かも知れないものを扱うために段階を踏むのでなけれ
ば、 `TRUE' は使用すべきではありません。

XSUB では、Per の配列値、ハッシュ値、コード値をアクセスするために、
`perl_get_av()' 、 `perl_get_hv()' 、 `perl_get_cv()' を使うことができ
ます。





File: perl-ja.info, Node: インタフェースの戦略, Next: Perl モジュール, Prev: Perl 変数, Up: 応用プログラムインタフェース

インタフェースの戦略
====================

Perl と C ライブラリの間のインタフェースを設計する段階では、ほとんどの
場合、C から XS への直訳で十分です。そのインタフェースは、多くは C 風の
ものとなり、特に C の関数が引数を変更するようなときには、直感的とはいえ
ないものとなります。もっと Perl 風なインタフェースを作りたい場合には、
インタフェースが、どちら寄りに傾くかを左右するような部分を特定するのに、
以下のような戦略をとると良いでしょう。

引数を変更する C 関数を見つけること。こういった関数の XSUB は、Perl へ
リストを返すようにし、失敗時には `undef' や空リストを返すようにすること
ができるでしょう。

C と XSUB の関数のみで使用される値を見つけなさい。Perl 側でその値の中身
に触れる必要がないのであれば、その値を C からPerl へ変換する必要もあり
ません。

C の関数の引数リストと返却値から、ポインタを探しなさい。ポインタによって
は、XS で変数名に単項演算子 `&' を付けて扱うことができますし、型名
に `*' 演算子を使わなければならないものもあります。一般に、
`&' 演算子で処理する方が簡単です。

C の関数で使われる構造体を特定しなさい。多くの場合、そのような構造体が
`bless' されたオブジェクトとして Perl から扱えるように、
`T_PTROBJ typemap' をこの構造体に使うとよいでしょう。





File: perl-ja.info, Node: Perl モジュール, Next: Perl のオブジェクトと C の構造体, Prev: インタフェースの戦略, Up: 応用プログラムインタフェース

Perl モジュール
===============

Perl モジュールは、XS コードから作られた拡張ライブラリと、Perl インタプ
リタとの間をつなぐ役割を果たします。このモジュールを使って、Perl に拡張
ライブラリの内容を知らせるのです。モジュールの名前とパッケージは、ライ
ブラリの名前に合わせた方がよいでしょう。

以下は、あるONC+RPC 結合ライブラリ関数を拡張する Perl モジュールです。

     package RPC;

     require Exporter;
     require DynaLoader;
     @ISA = qw(Exporter DynaLoader);
     @EXPORT = qw( rpcb_gettime rpcb_getmaps rpcb_getaddr
                     rpcb_rmtcall rpcb_set rpcb_unset );

     bootstrap RPC;
     1;

@EXPORT リスト内にある関数が、RPC 拡張に含まれています。RPC モジュール
は、Exporter モジュールを使って、これらの関数名がモジュール外の Perl プ
ログラムからも見えるようにしています。DynaLoader モジュールによって、
RPC モジュールは、拡張ライブラリをブートストラップできるようにします。
この拡張機能を実際にロードし、関数を使えるようにするために、

     use RPC;

という Perl の実行文を使います。`DynaLoader' についてより詳しくは、
Perl のソースディレクトリの `ext/DynaLoader' にあるドキュメントを見てく
ださい。





File: perl-ja.info, Node: Perl のオブジェクトと C の構造体, Next: C のヘッダファイルと Perl, Prev: Perl モジュール, Up: 応用プログラムインタフェース

Perl のオブジェクトと C の構造体
================================

C の構造体を扱うときには、XS の型に `T_PTROBJ' か `T_PRTREF' を選択する
必要があります。どちらの型も複雑なオブジェクトへのポインタを扱うように
設計されています。T_PTRREF 型では、Perl のオブジェクトが `bless' されて
いなくてもよいが、T_PTROBJ 型では、オブジェクトが `bless' されていなけ
ればなりません。T_PTROBJ を使うことで、XSUB は Perl オブジェクトが期待
する型であることを確認するようになりますから、型チェックを行なうことが
できます。

次の XS コードでは、 `getnetconfigent()' 関数を ONC TIRPC といっしょ
に使っています。 `getnetconfigent()' 関数は、C の構造体へのポインタ
を返すもので、以下のプロトタイプで示されるものです。この例では、C のポイ
ンタを Perl のリファレンスにする方法を示すことにします。Perl は、このリ
ファレンスを bless されたオブジェクトへのポインタとみなして、このオブジェ
クトに対してデストラクタを起動しようとします。デストラクタは、
`getnetconfigent()' が使ったメモリを解放するために、XS ソース内で記
述しす。XS でのデストラクタは、DESTROY で終わる名前を持つ XSUB 関数を記
述することで作ることができます。XS デストラクタは、別の XSUB が
`malloc' したメモリを、 `free' するために使うことができます。

     struct netconfig *getnetconfigent(const char *netid);

`struct netconfig' のために `typedef' を行なっています。Perlのオブジェ
クトは、C での型の名前に `Ptr' というタグを付けたものにマッチする名前の
クラスで `bless' され、その名前は、Perl のパッケージ名として使われると
きには、空白を入れません。デストラクタは、そのオブジェクトの属するクラ
スに対応するクラスに置かれ、Perl 側では `DESTROY' という名前で参照され
ますので、`PREFIX' キーワードを使用して関数名の先頭部分をみないようにし
ます。

     typedef struct netconfig Netconfig;

     MODULE = RPC  PACKAGE = RPC

     Netconfig *
     getnetconfigent(netid)
          char *  netid

     MODULE = RPC  PACKAGE = NetconfigPtr  PREFIX = rpcb_

     void
     rpcb_DESTROY(netconf)
          Netconfig *  netconf
          CODE:
          printf("Now in NetconfigPtr::DESTROY\n");
          free( netconf );

この例には、次のような `typemap' のエントリが必要になります。拡張に際し
て、新しい `typemap' を設けるときには、 *Note typemap::, の節の情報も参
考にしてください。

     TYPEMAP
     Netconfig *  T_PTROBJ

今回の例は、

     use RPC;
     $netconf = getnetconfigent("udp");

という Perl の文で使用されます。

Perl は $NETCONF で参照されるオブジェクトを消去するとき、そのオブジェク
トを用意された XSUB DESTROY 関数に送ります。Perl では、このオブジェクト
が C の構造体であって、Perl のオブジェクトではないと知るすべがありませ
んし、関与もしません。この意味で、 `getnetconfigent()' XSUB で作られた
オブジェクトと、普通の Perl のサブルーティンで作られたオブジェクトの区
別はありません。





File: perl-ja.info, Node: C のヘッダファイルと Perl, Next: 新しい拡張モジュールの作成, Prev: Perl のオブジェクトと C の構造体, Up: 応用プログラムインタフェース

C のヘッダファイルと Perl
=========================

h2xs コンパイラは、 `/usr/include' の C のヘッダファイルを Perlの拡張モ
ジュールに変換するために設計されています。このコンパイラは、Perl ソース
の ext ディレクトリの下に、ディレクトリを作り、ここに `Mekefile' 、
Perl モジュール、XS ソースファイル、`MANIFEST' ファイルを入れます。

次のコマンドは、 `<rpcsvc/rusers.h>' ヘッダから、Rusers という拡張モ
ジュールを作ります。

     h2xs rpcsvc/rusers

Rusers 拡張モジュールがコンパイルされ、インストールされると、C のヘッダ
にあった `#define' 文を Perl から参照するために、このモジュールを使うこ
とができます。

     use Rusers;
     print "RPC program number for rusers service: ";
     print &RUSERSPROG, "\n";





File: perl-ja.info, Node: 新しい拡張モジュールの作成, Next: Typemap, Prev: C のヘッダファイルと Perl, Up: 応用プログラムインタフェース

新しい拡張モジュールの作成
==========================

h2xs コンパイラは、テンプレートのソースファイルと `Mekefile' を生成でき
ます。多くの拡張モジュールで、このテンプレートを叩き台として使うことが
できます。以下の例では、このドキュメントの RPC 関数を含む拡張モジュール
を生成するために、どのように h2xs を使うのかを示します。

この拡張モジュールでは、自動ロード関数を使用しておらず、定数の定義もし
ていませんから、 `-A' オプションを h2xs に付けています。Perl のソースディ
レクトリで実行すると、h2xs コンパイラは、 `ext/RPC' ディレクトリを作成
し、 `RPC.xs' 、 `RPC.pm' 、 `Makefile.PL' 、`MANIFEST' というファイル
をそこに置きます。RPC 関数の XS コードは、 `RPC.xs' ファイルに付け加え
ます。 `RPC.pm' の `@EXPORT' リストは、 `RPC.xs' から、その関数をインク
ルードするように更新しておきます。

     h2xs -An RPC

動的ローディングを行なう拡張モジュールのコンパイルには、

     make dynamic

というコマンドを `ext/RPC' ディレクトリで実行します。拡張モジュールを
Perl のバイナリに静的にリンクする場合には、Perlのソースディレクトリの
`makefile' ( `Makefile' ではなく、 `makefile' を使います) を編集して、
`ext/RPC/RPC.a' を STATIC_EXT 変数に追加します。この変更を行なう前に、
Perl を作ってないといけません。 `makefile' を更新したあとで、

     make

というコマンドを、Perl のソースディレクトリで実行します。

拡張モジュールを追加するために、Perl の Configure スクリプトを使うこと
もできます。この場合、Perl を作成する前に、Configure の実行に先立って、
拡張モジュールを Perl のソースディレクトリの ext ディレクトリに置いてお
く必要があります。Configure を実行するときに、他の拡張モジュール共々、
この拡張モジュールが ext ディレクトリで発見されると、作成される拡張モ
ジュールのリストに加えられます。make が実行されると、この拡張モジュール
も、他の拡張モジュールといっしょに、組み込まれることになります。

Configure は、拡張モジュールが、そのディレクトリ名と一致するXS ソースファ
イルを用意しているときに、その存在を認識します。Configure は、Perl ソー
スディレクトリの `MANIFEST' にあげられている、すべての `.SH' ファイルを
抽出した後で、拡張モジュールのディレクトリにも `MANIFEST' ファイルがあ
ると、そのファイルでも `.SH' ファイルを探して抽出します。その後、Perl
のソースディレクトリの `Makefile' が、拡張モジュールのディレクトリ名に
一致する XS ファイルを見つけると、そのディレクトリで make を実行します。





File: perl-ja.info, Node: Typemap, Next: XS の使用例, Prev: 新しい拡張モジュールの作成, Up: 応用プログラムインタフェース

Typemap
=======

`typemap' は、xsubpp コンパイラが、C の関数の引数や値を Perlの値に
マッピングするために使用する、コードを集めたものです。`typemap' ファ
イルは、 `TYPEMAP'、`INPUT'、`OUTPUT' というラベルを付け
た、3 つのセクションに分けることができます。`INPUT' セクションは、
Perl の値を、特定の型の C の変数に変換する方法を、コンパイラに伝えるもの
です。 `OUTPUT' セクションは、特定の型のC の値から、Perl が認識でき
る値に変換する方法をコンパイラに伝えます。 `TYPEMAP' セクションでは、
与えられた C の型を Perlの値にマッピングするために、どの `INPUT' コー
ドと `OUTPUT' コードを使用するかを、コンパイラに教えます。
`typemap' のどのセクションも、`TYPEMAP'、`INPUT'、
`OUTPUT' のいずれかのキーワードで始まることになります。

Perl のソースディレクトリの `ext' ディレクトリにあるデフォルトの
`typemap' には、Perl の拡張モジュールで使用することができる便利な型
をたくさん入れてあります。拡張モジュールによっては、自分のディレクトリに、
追加の `typemap' を定義して置いているものもあります。そのような追加
の `typemap' は、デフォルトの`typemap' の `INPUT' と
`OUTPUT' のマッピングを参照することができます。xsubpp コンパイラで
は、デフォルトの `typemap' のマッピングが、拡張モジュールの
`typemap' でオーバライドすることが許されています。

独自の `typemap' を必要とする拡張モジュールでは、ほとんどの場合、
`typemap' ファイルの `TYPEMAP' セクションだけが必要になります。
`getnetconfigent()' の例で示した独自 `typemap' は、拡張モジュールの
`typemap' の使用例としては、典型的なものかもしれません。この `typemap'
は、C の構造体と T_PTROBJ typemap を等しいものとして扱うために使われて
ます。 `getnetconfigent()' で使った `typemap' を再掲します。C の型は、
XS の型とタブで区切られ、C の単項演算子 `*' は、C の型名の一部とみなさ
れます。

     TYPEMAP
     Netconfig *<tab>T_PTROBJ





File: perl-ja.info, Node: XS の使用例, Prev: Typemap, Up: 応用プログラムインタフェース

XS の使用例
===========


ファイル `RPC.xs' : いくつかの ONC+ RPC 結合ライブラリ関数へのインタフェース
----------------------------------------------------------------------------

     #include "EXTERN.h"
     #include "perl.h"
     #include "XSUB.h"

     #include <rpc/rpc.h>

     typedef struct netconfig Netconfig;

     MODULE = RPC  PACKAGE = RPC

     void
     rpcb_gettime(host="localhost")
          char *  host
          CODE:
          {
          time_t  timep;
          ST(0) = sv_newmortal();
          if( rpcb_gettime( host, &timep ) )
               sv_setnv( ST(0), (double)timep );
          }

     Netconfig *
     getnetconfigent(netid="udp")
          char *  netid

     MODULE = RPC  PACKAGE = NetconfigPtr  PREFIX = rpcb_

     void
     rpcb_DESTROY(netconf)
          Netconfig *  netconf
          CODE:
          printf("NetconfigPtr::DESTROY\n");
          free( netconf );




ファイル `typemap' : `RPC.xs' のための独自 typemap。
----------------------------------------------------

     TYPEMAP
     Netconfig *  T_PTROBJ




ファイル `RPC.pm' : RPC 拡張のための Perl モジュール。
------------------------------------------------------

     package RPC;

     require Exporter;
     require DynaLoader;
     @ISA = qw(Exporter DynaLoader);
     @EXPORT = qw(rpcb_gettime getnetconfigent);

     bootstrap RPC;
     1;




ファイル `rpctest.pl' : RPC 拡張のための Perl テストプログラム。
----------------------------------------------------------------

     use RPC;

     $netconf = getnetconfigent();
     $a = rpcb_gettime();
     print "time = $a\n";
     print "netconf = $netconf\n";

     $netconf = getnetconfigent("tcp");
     $a = rpcb_gettime("poplar");
     print "time = $a\n";
     print "netconf = $netconf\n";




File: perl-ja.info, Node: 拡張を行なうための内部関数, Next: C からの呼び出し法, Prev: 応用プログラムインタフェース, Up: Top

拡張を行なうための内部関数
**************************

このドキュメントでは Perl の実行ファイルの内部関数をいくつか記述してい
ます。完璧なものではありませんし、間違いも多いと思います。疑問点やコメ
ントは後に示す著者に行なってください。

* Menu:

* データ型::
* IV とは::
* SV の操作::
* プライベート値とバブリック値::
* AV を使う::
* HV を使う::
* 内部関数でリファレンスを使う::
* XSUB と引数スタック::
* 揮発性::
* 新しい変数の生成::
* スタッシュとオブジェクト::
* マジック::
* 二重に型をもつ SV::
* C プログラムから Perl ルーティンを呼び出す::
* Memory Allocation::


AUTHOR
======

Jeff Okamoto <okamoto@corp.hp.com>

With lots of help and suggestions from Dean Roehrich, Malcolm Beattie,
Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, and Neil
Bowers.


DATE
====
Version 12: 1994/10/16




File: perl-ja.info, Node: データ型, Next: IV とは, Prev: 拡張を行なうための内部関数, Up: 拡張を行なうための内部関数

データ型
========

Perl では、主となる 3 つのデータ型を扱うために 3 つの `typedef' を行なっ
ています:

   SV スカラ値
   AV 配列値
   HV ハッシュ値

それぞれの `typedef' には様々なデータ型を操作するための特別なルーティン
が用意されています。





File: perl-ja.info, Node: IV とは, Next: SV の操作, Prev: データ型, Up: 拡張を行なうための内部関数

IV とは
=======

Perl では、整数でもポインタでも十分に入れることのできる、特別な
`typedef IV' を使います。

Perl ではまた、常に 32 bit の整数となる特別な `typedef I32' も使用しま
す。





File: perl-ja.info, Node: SV の操作, Next: プライベート値とバブリック値, Prev: IV とは, Up: 拡張を行なうための内部関数

SV の操作
=========

SV は、1 つのコマンドで生成し、値をロードすることができます。ロードでき
る値の型には、整数 (IV)、倍精度 (NV)、文字列 (PV)、その他のスカラ (SV)
があります。

これらを行なう、4 つのルーティンは:

     SV*  newSViv(IV);
     SV*  newSVnv(double);
     SV*  newSVpv(char*, int);
     SV*  newSVsv(SV*);

です。「既に存在する」スカラの値を変更するために 5 つのルーティンがあり
ます:

     void  sv_setiv(SV*, IV);
     void  sv_setnv(SV*, double);
     void  sv_setpvn(SV*, char*, int)
     void  sv_setpv(SV*, char*);
     void  sv_setsv(SV*, SV*);

`sv_setpvn' を使って、代入される文字列の長さを指定することもできますし、
`sv_setpv' を使って Perl に長さを算出させることもできます。ただし、
sv_setpv は、文字列の長さを `NUL' 文字で終了することに依存する
`strlen' を使って算出することに注意しなくてはなりません。

SV が指し示す実際の値をアクセスするには、実際のスカラの型を強制的に IV
や倍精度や文字列にする、

     SvIV(SV*)
     SvNV(SV*)
     SvPV(SV*, STRLEN len)

というマクロを使うことができます。

`SvPV' マクロでは、返される文字列の長さは、変数 LEN に納められます (こ
れはマクロですので、 `&len' としないでください)。もし、データの長さを気
にしないのであれば、グローバル変数 na を使ってください。ただし、Perl で
は `NUL' を含む文字列も、 `NUL' で終端しない文字列も許されるということ
を忘れないでください。

単にスカラ値が真かどうかを知りたいだけならば、

     SvTRUE(SV*)

を使うことができます。

Perl では、SV にもっとメモリを割り当てて欲しいときには、自動的に文字列
を大きくしてくれますが、まだメモリを割り当てないといけないかを判断して
くれる、

     SvGROW(SV*, STRLEN newlen)

というマクロが使えます。もし必要なら、このマクロが sv_grow を呼びます。
`SvGROW' は SV に割り当てたメモリを増やすだけで、減らすことはできません。

手元にある SV の Perl から見た、データの種類を知りたいときには、その
SV の型チェックに、

     SvIOK(SV*)
     SvNOK(SV*)
     SvPOK(SV*)

というマクロを使うことができます。

SV に納められた文字列の、現在長を取得したり設定したりするには、以下のマ
クロが使います。

     SvCUR(SV*)
     SvCUR_set(SV*, I32 val)

ただし、これらは `SvPOK()' が真のときだけ有効です。

もし、スカラ変数の名前がわかるならば、その SV へのポインタは、

     SV*  perl_get_sv("varname", FALSE);

を使って得られます。その変数が存在しなければ、 `NULL' が返されます。

その変数 (あるいは、他の任意の SV) が、実際に定義されているかを知りたい
ならば、

     SvOK(SV*)

を呼び出してください。

スカラの `undef' 値は、 `sv_undef' という SV インスタンスに納められてい
ます。そのアドレスは、 `SV*' が必要とされるところで使用することができま
す。

ブール値の真と偽を表わす、 `sv_yes' と `sv_no' という値もあります。
`sv_undef' と同様に、これらのアドレスも `SV*' が必要なところで、使うこ
とができます。

`(SV *0)' が `&sv_undef' が同じであると考えて、だまされてはいけません。
次のようなコードを見てください:

     SV* sv = (SV*) 0;
     if (I-am-to-return-a-real-value) {
             sv = sv_2mortal(newSViv(42));
     }
     sv_setsv(ST(0), sv);

このコードは、実値を返さなければならないときには、(値として42 を持つ) 新
しい SV を返そうとし、さもなくば `undef' を返そうとします。ですが、
どこかの行でヌルポインタを返して、セグメントバイオレーションが起こるか、
何かおかしな結果になってしまいます。最初の行の `0' を
`&sv_undef' に変えれば、すべてが旨くいきます。

生成した SV を解放するためには、 `SvREFCNT_dec(SV*)' を呼びます。普通は、
この呼び出しは必要ありません。「 *Note 揮発性::, 」の章を参照してくださ
い。





File: perl-ja.info, Node: プライベート値とバブリック値, Next: AV を使う, Prev: SV の操作, Up: 拡張を行なうための内部関数

プライベート値とバブリック値
============================

自分で持っていれるスカラの型を決定する通常の方法は、マクロ `Sv[INP]OK'
を使うのでした。スカラは数値にも文字列にもなり得ますから、普通、これら
のマクロはいつも真を返し、`Sv[INV]V' マクロを呼ぶことで、文字列から整数
/倍精度、整数/倍精度から文字列への変換を行ないます。

もし、本当に SV にあるのが整数か、倍精度か、文字列ポインタかを知りたい
のであれば、代わりに、

     SvIOKp(SV*)
     SvNOKp(SV*)
     SvPOKp(SV*)

というマクロを使うことができます。これらは、実際に SV に入っているもの
が整数か、倍精度か、文字列ポインタかを教えてくれます。

しかし、一般には、 `Sv[INP]V' マクロを使うだけにした方が良いでしょう。




File: perl-ja.info, Node: AV を使う, Next: HV を使う, Prev: プライベート値とバブリック値, Up: 拡張を行なうための内部関数

AV を使う
=========

AV を生成して、値を設定するのには、2 つの方法があります。最初の方法は、
単に空の AV を作るものです:

     AV*  newAV();

ふたつめの方法は、AV を生成した上で、初期値として SV の値を入れます:

     AV*  av_make(I32 num, SV **ptr);

ふたつめの引数は、num 個の `SV*' の配列を指しています。

いったん、AV が生成されると、AV に対して、

     void  av_push(AV*, SV*);
     SV*   av_pop(AV*);
     SV*   av_shift(AV*);
     void  av_unshift(AV*, I32 num);

といった操作が行えます。これらは、 `av_unshift' を除いては、お馴染みの
演算でしょう。 `av_unshift' は、配列の先頭に、num 個の `undef' 値の要素
を付け加えます。その後で、(あとで述べる) `av_store' を使って、新しい要
素に値を代入しなければなりません。他にもいくつか関数があります:

     I32 av_len(AV*); /* 配列の大きさを返す */
     SV** av_fetch(AV*, I32 key, I32 lval);
            /* オフセットが key の位置から値を取り出すが、lval
               がゼロでないとき、値を lval に設定するようだ */
     SV** av_store(AV*, I32 key, SV* val);
            /* オフセットが key の位置に val を設定する */
     void av_clear(AV*);
            /* すべての要素をクリアするが、配列は残す */
     void av_undef(AV*);
            /* 全要素を除去し、配列を未定義にする */

配列変数の名前がわかるのであれば、

     AV*  perl_get_av("varname", FALSE);

を使えば、AV へのポインタが得られます。その変数が存在しなければ、NULL
を返します。





File: perl-ja.info, Node: HV を使う, Next: 内部関数でリファレンスを使う, Prev: AV を使う, Up: 拡張を行なうための内部関数

HV を使う
=========

HV を生成するには、

     HV* newHV();

というルーティンを使います。いったん、HV が生成されると、HV に対して、

     SV** hv_store(HV*, char* key, U32 klen, SV* val, U32 hash);
     SV** hv_fetch(HV*, char* key, U32 klen, I32 lval);

という操作が行えます。引数 klen は、渡される key の長さです。引数 val
は、設定されるスカラへの SV ポインタを入れ、hash は、あらかじめ計算した
ハッシュ値 (hv_store に計算させる場合には、ゼロ) です。引数 lval で、こ
のフェッチ操作が、実はストア操作の一部であるかを示します。

`hv_store' や `hv_fetch' は、SV** を返すもので、SV* ではないことに注意
してください。スカラ値をアクセスするには、まず返却値を被参照する必要が
あります。しかし、その前に返却値が NULLでないことを確認すべきです。

ハッシュテーブルのエントリが存在するかをチェックし、削除する関数があり
ます。

     bool hv_exists(HV*, char* key, U32 klen);
     SV* hv_delete(HV*, char* key, U32 klen);

そして、その他の諸々の関数:

     void hv_clear(HV*);
           /* ハッシュテーブルのすべてのエントリをクリアする */
     void hv_undef(HV*);
           /* ハッシュテーブルを未定義にする */

     I32 hv_iterinit(HV*);
           /* ハッシュテーブルを走査する開始点を準備する */

     HE* hv_iternext(HV*);
           /* 次のエントリを取り出し、key と value が入った
              構造体へのポインタを返す */
     char* hv_iterkey(HE* entry, I32* retlen);
           /* HE 構造体から key を取り出し、また、key 文字
              列の長さを返す */
     SV* hv_iterval(HV*, HE* entry);
           /* HE 構造体の value への SV ポインタを返す */

ハッシュ変数の名前がわかるのであれば、

     HV* perl_get_hv("varname", FALSE);

を使うことで、HV へのポインタが得られます。その変数が存在しなければ、
NULL を返します。

(興味ある方のために、) ハッシュのアルゴリズムは、

     i = klen;
     hash = 0;
     s = key;
     while (i--)
     hash = hash * 33 + *s++;

となっています。





File: perl-ja.info, Node: 内部関数でリファレンスを使う, Next: XSUB と引数スタック, Prev: HV を使う, Up: 拡張を行なうための内部関数

リファレンス
============

リファレンスは、(リファレンスを含む) 他のスカラ型を指す、特別なスカラ型
です。AV や HV をスカラとして扱うには、単に AVや HV を SV にキャストす
るだけのことです。

リファレンスを生成するには、

     SV* newRV((SV*) pointer);

というコマンドを使います。いったん、リファレンスができると、適切な
`typedef (AV, AV, HV)' へのキャストを用いて、

     SvRV(SV*)

というマクロが使うことができ、返された SV* を AV* か HV* にキャストして、
適切なルーティンを呼ぶことになります。

リファレンスを被参照した後も、まだリファレンスであるかを調べるには、

     SvROK(SV*)

というマクロが使えます。





File: perl-ja.info, Node: XSUB と引数スタック, Next: 揮発性, Prev: 内部関数でリファレンスを使う, Up: 拡張を行なうための内部関数

XSUB と引数スタック
===================

XSUB の仕組みは、Perl プログラムが C のサブルーティンをアクセスするため
の単純な方法です。XSUB には、Perl プログラムからの引数を入れるスタック
と、Perl のデータ構造を C の同等なものにマッピングする方法を用意してい
ます。

スタック引数は、ST(n) というマクロでアクセスできます。これは、n 番目の
スタック引数を返すものです。引数 0 は、Perl のサブルーティン呼び出しで
渡された、最初の引数です。これらの引数は SV* で、SV* が使われるところで
あれば、どこでも使うことができます。

ほとんどの場合には、C ルーティンからの出力は、RETVAL とOUTPUT: ディレク
ティブを使って扱うことができます。しかし、引数スタックのスペースがすべ
ての返却値を扱うのに、十分でなくなる場合があります。例としては、引数を
とらないで、ローカルなタイムゾーンと、夏時間の省略形の二つの返却値を返
す、POSIX tzname() の呼び出しがあります。

このような状況を扱うためには、PPCODE: ディレクティブを使い、

     EXTEND(sp, num);

というマクロを使ってスタックを拡張します。ここで、sp はスタックポインタ
で、num はスタックを拡張すべき要素の数です。

スタック上に場所を確保したならば、IV、倍精度、文字列、SV ポインタをプッ
シュする、

     PUSHi(IV)
     PUSHn(double)
     PUSHp(char*, I32)
     PUSHs(SV*)

というマクロを使って、値をスタックへプッシュします。

これで、tzname をよぶ Perl プログラムでは、二つの値は、

     ($standard_abbrev, $summer_abbrev) = POSIX::tzname;

というように代入できます。スタックに値を積む、別の (おそらく、より簡単
な) 方法は、

     XPUSHi(IV)
     XPUSHn(double)
     XPUSHp(char*, I32)
     XPUSHs(SV*)

というマクロを使うものです。こちらのマクロは、必要ならば、自動的にスタッ
クを調整してくれます。





File: perl-ja.info, Node: 揮発性, Next: 新しい変数の生成, Prev: XSUB と引数スタック, Up: 拡張を行なうための内部関数

揮発性
======

Perl では、値は通常「不揮発な」ものです。つまり、(Perl の undef 呼び出
しや、Perl 自身で他のルーティンを通じて) 明示的に解放しない限り、解放さ
れることはありません。

先の tzname の例では、文字列であるところの、二つの新しい SV を引数スタッ
クに積むために、生成する必要がありました。しかし、これらは最終的にはス
カラ変数を保持する SV にコピーされますから、新しい SV に永久に固執する
ものではありません。

「揮発性」の SV (あるいは、AV や HV) は、普通の「不揮発性」の SV、AV、
HV と全く同じように動作しますが、「現在の文脈」でしか有効ではないもので
す。Perl インタプリタが現在の文脈を離れると、揮発性の SV、AV、HV は自動
的に解放されます。一般に「現在の文脈」というのは、Perl の一つの実行文を
表わします。

揮発性の変数を生成するには、

     SV* sv_newmortal()
     SV* sv_2mortal(SV*)
     SV* sv_mortalcopy(SV*)

という関数を使います。最初のものは揮発性の SV を生成し、ふたつめは、既
にある SV を揮発性の SV に変換します。三つめは、既に存在する SV の揮発
性のコピーを生成します。

揮発性のルーティンは、単に SV のためだけではありません。AVや HV も、
sv_2mortal や sv_mortalcopy ルーティンに、アドレスを (SV* にキャストし
て) 渡すことで、揮発性にすることができます。






File: perl-ja.info, Node: 新しい変数の生成, Next: スタッシュとオブジェクト, Prev: 揮発性, Up: 拡張を行なうための内部関数

新しい変数の生成
================

Perl スクリプトからアクセスできる、新しい Perl の変数を生成するには、変
数の型に応じて、

     SV* perl_get_sv("varname", TRUE);
     AV* perl_get_av("varname", TRUE);
     HV* perl_get_hv("varname", TRUE);

というルーティンを使用します。二番目の引数としては TRUE を使います。新
しい変数は、データの型に合ったルーティンを使って、設定することができま
す。





File: perl-ja.info, Node: スタッシュとオブジェクト, Next: マジック, Prev: 新しい変数の生成, Up: 拡張を行なうための内部関数

スタッシュとオブジェクト
========================

スタッシュとは、パッケージ内にある、すべての異なるオブジェクトが入って
いるハッシュテーブル (連想配列) のことです。ハッシュテーブルの個々の
key は、(同じ名前のすべての異なる型のオブジェクトで共有される) シンボル
名で、ハッシュテーブルの個々の value は、(グローバル値のための) GV と呼
ばれます。GV には、

   スカラ値
   配列値
   ハッシュ値
   ファイルハンドル
   ディレクトリハンドル
   フォーマット
   サブルーティン

を含む (これらに限りませんが)、その名前の様々なオブジェクトへのリファレ
ンスが次々に入ることになります。

Perl は、(グローバル変数のための) GV 構造体に様々なスタッシュを入れます
が、それらは、HV 構造体で表されます。

特定のパッケージの HV ポインタの入手には、

     HV* gv_stashpv(char* name, I32 create)
     HV* gv_stashsv(SV*, I32 create)

という関数を使います。最初の関数が、リテラル文字列をとり、二番目が SV
に入れた文字列を使います。

`gv_stash*v' が使う name は、シンボルテーブルを手に入れようとするパッケー
ジの名前です。デフォルトのパッケージは、`main' というものです。多重にネ
ストしたパッケージであれば、Perl での場合と同様に、:: で区切って
gv_stash*v に名前を渡すのが正しい方法です。

もし、`bless' されたリファレンスである SV があれば、

     HV* SvSTASH(SvRV(SV*));

を使っても、スタッシュポインタを探すことができ、パッケージ名自身は、

     char* HvNAME(HV* stash);

で得られます。

Perl スクリプトへ `bless' された値を返す必要があれば、

     SV* sv_bless(SV*, HV* stash)

という関数が使えます。最初の引数 SV* は、リファレンス、二番目の引数がス
タッシュです。返された SV* は、他の SV と同様に使うことができます。





File: perl-ja.info, Node: マジック, Next: 二重に型をもつ SV, Prev: スタッシュとオブジェクト, Up: 拡張を行なうための内部関数

マジック
========

[執筆中]





File: perl-ja.info, Node: 二重に型をもつ SV, Next: C プログラムから Perl ルーティンを呼び出す, Prev: マジック, Up: 拡張を行なうための内部関数

二重に型をもつ SV
=================

スカラ変数は、通常、整数、倍精度、ポインタ、リファレンスのいずれか 1 つ
の型をとります。Perl は、実際のデータに対して、蓄積されている型から、要
求されている型へ、自動的に変換を行ないます。

ある種のスカラ変数は、複数の型のスカラデータを持つようになっています。た
とえば、変数 `$!' は、`errno' の数値としての値と、
`sys_errlist[]' から取り出した同値な文字列を持っています。

SV に複数のデータ値を入れるようにするには、2 つのことをしなくてはなりま
せん。スカラ型を別に追加するために、`sv_set*v'ルーティンを使用すること。
それから、フラグを設定して Perlに複数のデータを持っていることを知らせる
ことです。フラグを設定するための 4 つのマクロは:

     SvIOK_on
     SvNOK_on
     SvPOK_on
     SvROK_on

です。使用するマクロは、最初にどの `sv_set*v' ルーティンを呼ぶのかに関
わってきます。これは、 `sv_set*v' ルーティンはすべて、特定のデータ型の
ビットだけを設定し、他をクリアしてしまうからです。

たとえば、"dberror" という新しい Perl 変数を作って、エラー値を数値とメッ
セージ文字列で持つようにするには、以下のように書きます:

     extern int  dberror;
     extern char *dberror_list;

     SV* sv = perl_get_sv("dberror", TRUE);
     sv_setiv(sv, (IV) dberror);
     sv_setpv(sv, dberror_list[dberror]);
     SvIOK_on(sv);

もし、 `sv_setiv' と `sv_setpv' の順序が逆であれば、 `SvIOK_on' マクロ
の代わりに、 `SvPOK_on' マクロを呼ばなければなりません。





File: perl-ja.info, Node: C プログラムから Perl ルーティンを呼び出す, Next: Memory Allocation, Prev: 二重に型をもつ SV, Up: 拡張を行なうための内部関数

C プログラムから Perl ルーティンを呼び出す
==========================================

C プログラムから、Perl サブルーティンを呼び出すために使用することのでき
るルーティンが 4 つあります。その 4 つは:

     I32  perl_call_sv(SV*, I32);
     I32  perl_call_pv(char*, I32);
     I32  perl_call_method(char*, I32);
     I32  perl_call_argv(char*, I32, register char**);

です。最もよく使われるはずのものは、 `perl_call_sv ' です。引数 SV* に
は、呼び出される Perl サブルーティンの名前か、そのサブルーティンへのリ
ファレンスを含むものです。2 番目の引数は、Perl サブルーティンが返す値が
あれば、それがどんなものかを該当ルーティンに知らせます。

4 つのルーティンはいずれも、サブルーティンが Perl スタック上に返した引
数の数を返します。

これら 4 つのルーティンを使うときには、プログラマが Perl スタックを操作
しなくてはなりません。以下のマクロと関数が用意されています:

     dSP
     PUSHMARK()
     PUTBACK
     SPAGAIN
     ENTER
     SAVETMPS
     FREETMPS
     LEAVE
     XPUSH*()

詳しくは *Note C からの呼び出し法::, を参照してください。





File: perl-ja.info, Node: Memory Allocation, Prev: C プログラムから Perl ルーティンを呼び出す, Up: 拡張を行なうための内部関数

Memory Allocation
=================

[執筆中]




File: perl-ja.info, Node: C からの呼び出し法, Next: 多重定義, Prev: 拡張を行なうための内部関数, Up: Top

C からの呼び出し法
******************

WARNING: このドキュメントは、現在まだ作成中です。不正確な点が、たくさん
あることは確実ですので、とうぶんは、注意して読むようにしてください。

このドキュメントの目的は、「コールバック」の書き方、すなわち、どのよう
に C から Perl を呼び出すかを示すことです。中心となるのは、Perl によっ
て実行される、ほんのわずかの C のコードから Perl を呼び戻すインタフェー
ス、つまり、`main' プログラムは Perl スクリプトで、そこから C で書いた
コードを起動し、その C のコードが何かを行なうときに、特定のイベントによっ
て、Perl sub を実行するということが、いつでもできるようにしておくことが
必要でしょう。

必要に応じて、例を示すようにしてあります

   * アプリケーションの C API へのインタフェース XSUB を作成しました。

     アプリケーションでかなり一般的な機能として、なにか面倒が起こったと
     きに、呼ぶことのできる C の関数を定義することができるようにするこ
     とがあげられます。やりたいことは、代わりに Perl sub を呼ぶというこ
     とです。

   * どこでコールバックが使われるかの古典的な例は、X Window System のよ
     うなイベントドリブンなプログラムに見られます。この場合、登録内容は、
     マウスのボタンが押されたような、特定のイベントが発生したときに呼ば
     れるように機能します。

記述したテクニックは、Perl プログラムを C プログラムに埋め込むときにも
適用することができますが、これは、このドキュメントの本来の目的ではあり
ません。C に埋め込む Perl に関する詳細は、 perlembed manpage (現在執筆
中) を参照してください。

このドキュメントの残りの部分に進む前に、以下の 2 つのドキュメントを読ん
でおいた方が良いでしょう。- *Note 応用プログラムインタフェース::,と
*Note 拡張を行なうための内部関数::,です。

内容は、例を用いて、やさしく説明しています。しかし、まず、とにかく定義
をいくつかしておきましょう。

* Menu:

* 呼び出しの定義::
* フラグ値::
* 呼び出しの例::
* コンテキスト情報を蓄える方策::
* 別のスタック操作::



SEE ALSO
========
*Note 応用プログラムインタフェース::,、*Note 拡張を行なうための内部関
数::,、perlembed manpage


AUTHOR
======
Paul Marquess <pmarquess@bfsec.bt.co.uk>

ドキュメントの作成に協力してくれた、次の方々に感謝します。

Jeff Okamoto, Tim Bunce.


DATE
====
Version 0.4, 17th October 1994





File: perl-ja.info, Node: 呼び出しの定義, Next: フラグ値, Prev: C からの呼び出し法, Up: C からの呼び出し法

呼び出しの定義
==============

Perl では、Perl sub を呼ぶことを許している C の関数がたくさんあります。
それは、

     I32 perl_call_sv(SV* sv, I32 flags) ;
     I32 perl_call_pv(char *subname, I32 flags) ;
     I32 perl_call_method(char *methname, I32 flags) ;
     I32 perl_call_argv(char *subname, I32 flags, register char **argv) ;

中心となる関数は、 `perl_call_sv' です。他の関数は、自分のやりたいこと
に合わせて、 `perl_call_sv' を利用します。 `perl_call_sv' は、2 つの引
数をとり、最初の引数は、 `SV*' です。これによって、呼び出される Perl
sub を C の文字列 (まず、SV に変換されています) か、sub へのリファレン
スで指定することができます。例 7 では、自ら `perl_call_sv' を利用する方
法を示します。2 番目のパラメータ `flags' は、汎用のオプションコマンドで
す。このパラメータは、すべての `perl_call_*' 関数に共通です。詳しくは、
次の節で述べます。

関数 `perl_call_pv' は、ほぼ `perl_call_sv' と同じですが、最初の引数と
して呼び出したい Perl sub を示す C の `char *' を指定します。例:
`perl_call_pv("fred", 0)'

関数 `perl_call_method' は、最初の引数に、 `bless' された、ク
ラスへのリファレンスを指定しなければなりません。そのリファレンスを使って
検索し、該当クラスから `methname' を呼び出します。
*Note 例 9. perl_call_method を使う::, を参照。

`perl_call_argv' は、 `subname' パラメータで指定された Perl sub を呼び
出します。これはまた、通常の `flags' パラメータも指定します。最後のパラ
メータ `argv' には、Perl sub に渡される C の文字列のリストを指定します。
*Note 例 8. perl_call_argv を使う::, を参照してください。

すべての関数は、数を返します。これは、Perl sub がスタック上に置いた、返
却物の数を示します。

一般論として、これらの関数からの返却値は「常に」チェックしてください。
Perl sub から特定の数が返って来ることを期待している場合にも、誰かがなに
か期待以外のことをしないとは限りません。「そんなの聞いていない」とは言
わないでください。





File: perl-ja.info, Node: フラグ値, Next: 呼び出しの例, Prev: 呼び出しの定義, Up: C からの呼び出し法

フラグ値
========

すべての perl_call_* 関数のパラメータ flags は、以下に定義するシンボル
を「論理和」で組み合わせて用います。

G_SCALAR
     Perl sub をスカラコンテキストで呼び出します。

     Perl sub が実際に何を返そうとも、スカラのみが必要と解釈されます。
     Perl sub がスカラを返したときには、 `perl_call_*' 関数の返却値は、
     `1' か `0' になります。 `1' ならば、Perl subが実際に返した値は、ス
     タックのトップにあります。 `0' ならば、 `sub' で `die' を呼んだか、
     `G_DISCARD' フラグを設定したことを示します。Perl sub がリストを返
     すときにも、 `perl_call_*' 関数は、 `0' か `1' を返します。 `1' で
     あれば、リストの要素の数がスタックのトップに置かれます。実際のリス
     トの値には、アクセスできなくなります。

     `G_SCALAR' は、すべての関数で、デフォルトで設定されているフラグです。

G_ARRAY
     Perl sub をリストコンテキストで呼び出します。

     `perl_call_*' 関数からの返却値は、積まれた配列がスタックを何要素使っ
     たかを示します。

G_DISCARD
     Perl sub からの返却値が必要ないときには、このフラグを設定することで、
     Perl が自動的に廃棄してくれます。このフラグは、 `G_SCALAR' や
     `G_ARRAY' よりも優先されます。

     このフラグを設定しなかった場合には、一時的な値を明示的に自分で処分
     する必要があるかもしれません。詳細は、*Note 例 3. スカラを返す::,
     を参照してください。

G_NOARGS
     Perl sub に対して、何の引数も渡さないときには、このフラグを設定すること
     で、時間を少し稼ぐことができます。これは、Perl sub に対して、新しく
     `@_' を生成しないという効果があります。

     言うまでもないことですが、このフラグが指定された場合にも、呼び出さ
     れた Perl sub からは、上位の Perl sub の `@_' をアクセスすることが
     できます。この機能は、以下のような perl コードで確かめることができ
     ます。

          sub fred
            { print "@_\n"  }

          sub joe
            { &fred }

          &joe(1,2,3) ;

     とすると

          1 2 3

     と表示します。 `joe' に属している配列 `@_' を `fred' からアクセス
     したのです。

G_EVAL
     呼び出す Perl sub が、 `die' を呼んだり、実際に `exit' するな
     ど、通常ではない終了の仕方をすることがあり、そのようなイベントを捕捉した
     いようなときに、このフラグを設定します。 `sub' の呼び出しを
     `eval {}' で囲ったような状態にする働きがあります。

     `perl_call_*' 関数から制御が戻ったときには、通常 Perl スクリプトで
     行なうように、変数 $@ をチェックする必要があります。チェックの仕方
     については、*Note 例 6. G_EVAL を使う::,を参照してください。





File: perl-ja.info, Node: 呼び出しの例, Next: 例 1. パラメータなし、返却値なし, Prev: フラグ値, Up: C からの呼び出し法

呼び出しの例
============

定義の話は十分でしょうから、いくつか例を示します。

Perl では、Perl スタックをアクセスする手助けのためのマクロをたくさん用
意しています。Perl の内部ルーティンとのインタフェースには、常にこれらの
マクロを使うようにすべきでしょう。将来 Perl に施される変更に対しても、
これを使うことで、コードの方への影響が少なくなるはずです。

もう一つ余計なことを言っておくと、最初のいくつかの例では、
`perl_call_pv' 関数だけを使っています。これは、単にみなさんがこの話題に
入り込みやすいようにと考えただけのことです。`perl_call_pv' と
`perl_call_sv' のどちらも使える場合、私は常に`perl_call_sv ' を使います。

これらの例のコードは、`perlcall.tar' というファイルに納められています。
(いったん、このドキュメントが落ち着いたら、すべての例のコードをファイル
に入れるようにします。)

* Menu:

* 例 1. パラメータなし、返却値なし::
* 例 2. パラメータを渡す::
* 例 3. スカラを返す::
* 例 4. リスト値を返す::
* 例 5. Perl から引数リストを介してデータを返す::
* 例 6. G_EVAL を使う::
* 例 7. perl_call_sv を使う::
* 例 8. perl_call_argv を使う::
* 例 9. perl_call_method を使う::





File: perl-ja.info, Node: 例 1. パラメータなし、返却値なし, Next: 例 2. パラメータを渡す, Prev: 呼び出しの例, Up: C からの呼び出し法

例 1: パラメータなし、返却値なし
--------------------------------

最初の明快な例は、プロセスの `UID' を出力するために、Perl subの
`PrintUID' を呼びます。

     sub PrintUID
     {
         print "UID is $<\n" ;
     }

と、これを呼ぶ C 側です

     void
     call_PrintUID()
     {
         dSP ;

         PUSHMARK(sp) ;
         perl_call_pv("PrintUID", G_DISCARD|G_NOARGS) ;
     }

単純でしょう。

この例についていくつか注意点をあげておきましょう。

  1. `PrintUID' に引数を渡しませんので、 `G_NOARGS' を指定できます。

  2. 今のところ、 `dSP' と `PUSHMARK(sp)' は無視してください。これにつ
     いては、次の例でお話します。

  3. `PrintUID' から返されるものは、特に必要ありませんので、
     `G_DISCARD' を指定しています。 `PrintUID' が何か値を返すように変更
     されても、 `G_DISCARD' を指定しておくと、 `perl_ call_pv' から制御
     が戻るときに、その値が捨てられることになります。

  4. `G_DISCARD' を指定しましたので、 `perl_call_sv' からの返却値をチェッ
     クする必要はありません。常に `0' となります。

  5. `perl_call_pv' が使われていますから、Perl sub は C の文字列として
     表現されています。





File: perl-ja.info, Node: 例 2. パラメータを渡す, Next: 例 3. スカラを返す, Prev: 例 1. パラメータなし、返却値なし, Up: C からの呼び出し法

例 2: パラメータを渡す
----------------------

さて、今度はもう少し込み入った例です。今回は、2 つの引数として、文字列
`($a)' と整数 `($n)' をとる Perl sub を呼び出してみましょう。
``sub'' では、簡単に、文字列の最初の $N 文字を出力します。

Perl sub は以下のようなものです:

     sub LeftString
     {
         my($s, $n) = @_ ;
         print substr($s, 0, $n), "\n" ;
     }

`LeftString' を呼ぶための C の関数は、以下のようです:

     static void
     call_LeftString(a, b)
     char * a ;
     int b ;
     {
         dSP ;

         PUSHMARK(sp) ;
         XPUSHs(sv_2mortal(newSVpv(a, 0)));
         XPUSHs(sv_2mortal(newSViv(b)));
         PUTBACK ;

         perl_call_pv("LeftString", G_DISCARD);
     }

C の関数 `call_LeftString' の注意点を示します。

  1. 今回指定しているフラグは、G_DISCARD のみです。今回、Perl sub に 2
     つのパラメータを渡しますので、G_NOARGS は指定していません。

  2. パラメータは、Perl スタックを使って Perl sub に渡されます。これが、
     dSP で始め、PUTBACK 行で終わるコードの目的です。

  3. Perl スタックに何かをおこうとする場合には、どこにおけばよいかを知
     る必要があります。これが、マクロ dSP の目的で、Perl スタックポイン
     タのローカルなコピーを宣言し、初期化します。

     この例で使う、他のすべてのマクロは、このマクロの使用を前提にしてい
     ます。

     Perl sub を直接 XSUB 関数から呼ぶときには、明示的に dSPマクロを使
     う必要はありません。自動的に宣言されます。

  4. スタック上に積まれるパラメータはすべて、 `PUSHMARK' マクロと
     `PUTBACK' マクロで囲まなければなりません。この 2 つのマクロは、こ
     の文脈では、自動的にプッシュした引数の数を数えるために使われます。
     それで、Perl が sub に対して @_ 配列を作るときには、その大きさがわ
     かるという仕組みになっているのです。

     `PUSHMARK' マクロは、Perl に対して、内的にその時点のスタックポイン
     タに注目するように伝えます。(*Note 例 1. パラメータなし、返却値な
     し::,の場合のように) 引数を渡さない場合であっても、 `perl_call_*'
     関数を呼ぶ場合には、その前に `PUSHMARK' マクロを呼ばなくてはなりま
     せん。Perl からすると、引数がないことを知る必要があるのです。

     少し先へ飛んで、 `PUTBACK' マクロは、グローバルなスタックポインタ
     を、先に作ったローカルなものに合わせます。これを行わないと、どこに
     引数を置いたか、 `perl_call_pv' が判断することができません。ここま
     で、すべてのスタックポインタの操作は、ローカルなものに対して行なっ
     てきたのであって、グローバルなものは触っていなかったのです。

  5. 元に戻って、次に `XPUSH' を引数分呼んでいます。ここで、実際に引数
     がスタックに積まれます。今回の場合、文字列と整数を積んでいます。

     `XPUSH' マクロがどのように動作するのかについて詳しくは、*Note 拡張
     を行なうための内部関数::,の「*Note XSUB と引数スタック::,」の項を
     参照してください。

  6. ここまでで、 `LeftString' を `perl_call_pv' 関数を介して呼ぶことが
     できます。





File: perl-ja.info, Node: 例 3. スカラを返す, Next: 例 4. リスト値を返す, Prev: 例 2. パラメータを渡す, Up: C からの呼び出し法

例 3: スカラを返す
------------------

さて、Perl sub からの返却値を扱う例を見てみましょう。

ここにあげる Perl sub は、2 つの整数引数をとって、単にその和を返す
`Adder' というものです。

     sub Adder
     {
         my($a, $b) = @_ ;
         $a + $b ;
     }

`Adder' からの返却値を扱う必要がありますので、C 関数側は今回、多少複雑
になります。

     static void
     call_Adder(a, b)
     int a ;
     int b ;
     {
         dSP ;
         int count ;

         ENTER ;
         SAVETMPS;

         PUSHMARK(sp) ;
         XPUSHs(sv_2mortal(newSViv(a)));
         XPUSHs(sv_2mortal(newSViv(b)));
         PUTBACK ;

         count = perl_call_pv("Adder", G_SCALAR);

         SPAGAIN ;

         if (count != 1)
             croak("Big trouble\n") ;

         printf ("The sum of %d and %d is %d\n", a, b, POPi) ;

         PUTBACK ;
         FREETMPS ;
         LEAVE ;
     }


注意点は、

  1. 今回は、フラグとして `G_SCALAR' だけを使用しています。これは、
     @_ 配列が作られ、 `Adder' からの返された値は、
     `perl_call_pv' の呼び出し後も存在することを表わします。

  2. `Adder' から返されるものに意味がありますから、 `G_DISCARD' を指定
     することはできません。つまり、自分で Perl スタックをきちんと整理し
     て、一時的な値も廃棄する必要があります。これが、関数の最初で、

          ENTER ;
          SAVETMPS ;

     として、最後に

          FREETMPS ;
          LEAVE ;

     としていることの目的です。 `ENTER'/ `SAVETMPS' のペアが、使用する
     一時的な領域を作ります。逆にいうと、自分で廃棄できるものは、これら
     を呼び出した後に作ったものに限定されるということです。

     `FREETMPS' / `LEAVE' のペアは、Perl sub が返した値を捨て、生成した
     `SV' について、解放直前の情報をダンプします。コードの最初に
     `ENTER' / `SAVETMPS ' をおくことで、それ以上の開放情報が壊されるの
     を防ぎます。

  3. `SPAGAIN' マクロの目的は、ローカルなスタックポインタをリフレッシュ
     することです。 `perl_call_pv' の呼び出しの間に再配置された Perl ス
     タックへメモリ配置を行なうことができますから、これが必要になります。

     コードの中で Perl スタックポインタを利用する場合には、
     `perl_call_*' 関数や他の Perl の内部関数を利用するときには必ず、
     `SPAGAIN' を使ってローカルなポインタをリフレッシュしなくてはなりま
     せん。

  4. `Adder' から返されるのは、単一の値のみのはずですが、いずれにしても
     `perl_call_pv' からの返却値をチェックするのが良いでしょう。

     単一の値を期待するのは、一つであることを知っていることとは違います。
     誰かが `Adder' を改造して、リストを返すようにし、その可能性をチェッ
     クしていなかったときに、この操作を行なってしまうと、Perl スタック
     の状態は、矛盾したものになってしまいます。こんなことは、誰も望みは
     しないでしょう。

  5. スタックから、返却値をポップするのに、ここでは `POPi' マクロを使用
     しています。ここでは整数が必要であったため、`POPi' を使用したので
     す。

     返された値の型に応じて、以下の `POP' マクロを使用することができま
     す。

          POPs    SV
          POPp    ポインタ
          POPn    倍精度
          POPi    整数
          POPl    long 整数


  6. 最後の `PUTBACK' は、関数を抜ける前に、Perl スタックを矛盾の無い状
     態にしておくために使用しています。これは、`POPi' でスタックから返
     却値を取り出したときに、ローカルなスタックポインタのみを更新するた
     め、必要となります。先の例で説明したように `PUTBACK' は、グローバ
     ルなスタックポインタをローカルなスタックポインタの値にあわせるよう
     に設定します。




File: perl-ja.info, Node: 例 4. リスト値を返す, Next: 例 5. Perl から引数リストを介してデータを返す, Prev: 例 3. スカラを返す, Up: C からの呼び出し法

例 4: リスト値を返す
--------------------

さて、今度は、先の例を改造して、2 つの引数の和と差の両方を返すようにし
てみましょう。

Perl sub は

     sub AddSubtract
     {
        my($a, $b) = @_ ;
        ($a+$b, $a-$b) ;
     }

のようになり、C 関数は

     static void
     call_AddSubtract(a, b)
     int a ;
     int b ;
     {
         dSP ;
         int count ;

         ENTER ;
         SAVETMPS;

         PUSHMARK(sp) ;
         XPUSHs(sv_2mortal(newSViv(a)));
         XPUSHs(sv_2mortal(newSViv(b)));
         PUTBACK ;

         count = perl_call_pv("AddSubtract", G_ARRAY);

         SPAGAIN ;

         if (count != 2)
             croak("Big trouble\n") ;

         printf ("%d - %d = %d\n", a, b, POPi) ;
         printf ("%d + %d = %d\n", a, b, POPi) ;

         PUTBACK ;
         FREETMPS ;
         LEAVE ;
     }

となります。

注意点

  1. リストコンテキストが必要なため、 `G_ARRAY' を使用します。

  2. スタックから 2 つの値を取り出すため、今回 2 つの `POPi' を使ってい
     ることは、驚くに値しないでしょう。それよりも、注目すべきは、スタッ
     クから取り出したときに逆順となることです。reverse order.





File: perl-ja.info, Node: 例 5. Perl から引数リストを介してデータを返す, Next: 例 6. G_EVAL を使う, Prev: 例 4. リスト値を返す, Up: C からの呼び出し法

例 5: Perl から引数リストを介してデータを返す
---------------------------------------------

引数リストを使って直接値を返すことも可能です。ただし、これが実際に望ま
しい方法であるか、否かについては、まったく別の問題です。

以下の Perl sub `Inc' は、2 つの引数をとり、それぞれをインクリメントし
ます。

     sub Inc
     {
         ++ $_[0] ;
         ++ $_[1] ;
     }

そして、これを呼び出す C 関数です。

     static void
     call_Inc(a, b)
     int a ;
     int b ;
     {
         dSP ;
         int count ;
         SV * sva ;
         SV * svb ;

         ENTER ;
         SAVETMPS;

         sva = sv_2mortal(newSViv(a)) ;
         svb = sv_2mortal(newSViv(b)) ;

         PUSHMARK(sp) ;
         XPUSHs(sva);
         XPUSHs(svb);
         PUTBACK ;

         count = perl_call_pv("Inc", G_DISCARD);

         if (count != 0)
             croak ("call_Inc : expected 0 return "
                       "value from 'Inc', got %d\n", count) ;

         printf ("%d + 1 = %d\n", a, SvIV(sva)) ;
         printf ("%d + 1 = %d\n", b, SvIV(svb)) ;

         FREETMPS ;
         LEAVE ;
     }

`perl_call_pv' からリターンした後で、スタック上にプッシュされた 2 つの
パラメータにアクセスするために、これらのアドレスを記録しておく必要があ
ります。このため 2 つの変数 SVA と SVB を使っています。

これらの値を保持する Perl スタックのエリアは、 `perl_call_pv' から制御
が戻るときまでに、何ものかによって破壊されていることが十分に有り得るか
ら、こういった操作が必要になるのです。





File: perl-ja.info, Node: 例 6. G_EVAL を使う, Next: 例 7. perl_call_sv を使う, Prev: 例 5. Perl から引数リストを介してデータを返す, Up: C からの呼び出し法

例 6: G_EVAL を使う
-------------------

今度は `G_EVAL' を使う例です。以下は、2 つの引数の差を計算する Perl
sub です。結果が負になると、sub は `die' を呼びます。

     sub Subtract
     {
         my ($a, $b) = @_ ;
         die "death can be fatal\n" if $a < $b ;

         $a - $b ;
     }

これを呼ぶ C の方は、

     static void
     call_Subtract(a, b)
     int a ;
     int b ;
     {
         dSP ;
         int count ;
         SV * sv ;

         ENTER ;
         SAVETMPS;

         PUSHMARK(sp) ;
         XPUSHs(sv_2mortal(newSViv(a)));
         XPUSHs(sv_2mortal(newSViv(b)));
         PUTBACK ;

         count = perl_call_pv("Subtract", G_EVAL|G_SCALAR);

         /* Check the eval first */
         sv = GvSV(gv_fetchpv("@", TRUE, SVt_PV));
         if (SvTRUE(sv))
             printf ("Uh oh - %s\n", SvPV(sv, na)) ;

         SPAGAIN ;

         if (count != 1)
             croak ("call_Subtract : expected 1 return "
                       "value from 'Subtract', got %d\n", count) ;

         printf ("%d - %d = %d\n", a, b, POPi) ;

         PUTBACK ;
         FREETMPS ;
         LEAVE ;

     }

となります。CALL_SUBTRACT が

     call_Subtract(4, 5)

のように呼ばれると、以下のように表示されます。

     Uh oh - death can be fatal注意点

  1. `die' を捉えるために、 `G_EVAL' フラグを使用しました。このフラグを
     使用しないと、プログラムは途中終了してしまいます。

  2. C 関数の中の

          sv = GvSV(gv_fetchpv("@", TRUE, SVt_PV));
          if (SvTRUE(sv))
              printf ("Uh oh - %s\n", SvPVx(sv, na)) ;

     という部分は、Perl の書くところの

          print "Uh oh - $@\n" if $@ ;

     と同じことになります。




File: perl-ja.info, Node: 例 7. perl_call_sv を使う, Next: 例 8. perl_call_argv を使う, Prev: 例 6. G_EVAL を使う, Up: C からの呼び出し法

例 7: perl_call_sv を使う
-------------------------

これまでの例では、Perl sub の名前を C から呼ばれるように扱ってきました。
ですが、ときには Perl スクリプトの中から、Perl sub の名前を指定すること
ができないと、困ることがあります。

     sub fred
     {
         print "Hello there\n" ;
     }

     CallSub("fred") ;

のような Perl コードを考えてみましょう。 `CallSub' を定義する
`XSUB' の一部は、

     void
     CallSub(name)
             char *  name
             CODE:
             PUSHMARK(sp) ;
             perl_call_pv(name, G_DISCARD|G_NOARGS) ;

のようになります。今のところは、これで良いのかもしれません。問題は、
Perl sub が文字列でしか表現できないということです。Perl 4 では、これで
十分なのですが、Perl 5 では sub へのリファレンスや無名の sub が許されて
います。そういった場合に、`perl_call_sv' が役に立つのです。

次の `CallSub' のコードは、先のものと同一ですが、引数 NAME を`SV*' で定
義し、 `perl_call_pv' の代わりに `perl_call_sv' を使っています。

     void
     CallSub(name)
             SV*     name
             CODE:
             PUSHMARK(sp) ;
             perl_call_sv(name, G_DISCARD|G_NOARGS) ;

`fred' を呼ぶのに `SV' を使っていますから、Perl 側では、

     CallSub("fred") ;
     Callsub(\&fred) ;
     $ref = \&fred ;
     CallSub($ref) ;
     CallSub( sub { print "Hello there\n" } ) ;

といった記法が、すべて可能になります。ご覧のように、perl_ call_sv を使
えば、Perl sub をかなり柔軟に指定することができるようになります。





File: perl-ja.info, Node: 例 8. perl_call_argv を使う, Next: 例 9. perl_call_method を使う, Prev: 例 7. perl_call_sv を使う, Up: C からの呼び出し法

例 8: perl_call_argv を使う
---------------------------

次にあげるのは、渡された引数を表示する Perl sub です。

     sub PrintList
     {
         my(@list) = @_ ;

         foreach (@list) { print "$_\n" }
     }

そして、 `PrintList' を呼ぶ `perl_call_argv' の例です。

     call_PrintList
     {
         dSP ;
         char * words[] = {"alpha", "beta", "gamma", "delta", NULL } ;

         perl_call_argv("PrintList", words, G_DISCARD) ;
     }

注目したいのは、この場合には、 `PUSHMARK' を呼ぶ必要がないということで
す。 `perl_call_argv' 側で自動的に行なうからです。





File: perl-ja.info, Node: 例 9. perl_call_method を使う, Next: コンテキスト情報を蓄える方策, Prev: 例 8. perl_call_argv を使う, Up: C からの呼び出し法

例 9: perl_call_method を使う
-----------------------------

[この節は執筆中]

以下のような Perl コードを考えてみましょう。

     {
       package Mine ;

       sub new     { bless [@_] }
       sub Display { print $_[0][1], "\n" }
     }

     $a = new Mine ('red', 'green', 'blue') ;
     call_Display($a, 'Display') ;

メソッド `Display' は、単にリストの最初の要素を出力するものです。そして、
`call_Display' の `XSUB' インプリメンテーションです。

     void
     call_Display(ref, method)
         SV *    ref
         char *  method
         CODE:
         PUSHMARK(sp);
         XPUSHs(ref);
         PUTBACK;

         perl_call_method(method, G_DISCARD) ;





File: perl-ja.info, Node: コンテキスト情報を蓄える方策, Next: 別のスタック操作, Prev: 呼び出しの例, Up: C からの呼び出し法

コンテキスト情報を蓄える方策
============================

[この節は執筆中]

コールバックを設計するときに克服すべき、陥りやすい問題の一つは、C のコー
ルバック関数と Perl の同等のものの間での対応を覚えておく方法を見つける
ことです。

以下の例を考えてください。....





File: perl-ja.info, Node: 別のスタック操作, Prev: コンテキスト情報を蓄える方策, Up: C からの呼び出し法

別のスタック操作
================

[この節は執筆中]

Perl sub から返された値をアクセスするために、POP* マクロだけを使ってき
ましたが、これらのマクロを使わずに、直接スタックを読むこともできます。

以下のコードは ....




File: perl-ja.info, Node: 多重定義, Next: 書籍の情報, Prev: C からの呼び出し法, Up: Top

多重定義
********

     package SomeThing;

     %OVERLOAD = (
         '+' => \&myadd,
         '-' => \&mysub,
         # etc
     );
     ...

     package main;
     $a = new SomeThing 57;
     $b=5+$a;

* Menu:

* 多重定義関数の宣言::
* 二項演算子の呼び出し方::
* 単項演算子の呼び出し方::
* 多重定義可能な演算子::
* %OVERLOAD の特殊 key::
* マジック自動生成::
* 多重定義の警告::
* 多重定義の実装::
* 多重定義の診断::
* 多重定義のバグ::


警告
====
演算子の多重定義は、軽くは考えられない問題です。詳細なインプリメンテー
ションも、構文も、内容も 100% Larry Wall が支持しているものではありませ
ん。したがって、これらは、将来のいつの時点かに変更される可能性もありま
す。


AUTHOR
======
Ilya Zakharevich <ilya@math.mps.ohio-state.edu>.





File: perl-ja.info, Node: 多重定義関数の宣言, Next: 二項演算子の呼び出し方, Prev: 多重定義, Up: 多重定義

多重定義関数の宣言
==================

     package Number;
     %OVERLOAD = (
         "+" => \&add,
         "*=" => "muas"
     );

では、加法の関数 `Number::add()' と「クラス」Number (あるいは、基底クラ
スの 1 つ) の中の乗法の代入形式 `*=' のメソッド `muas' を宣言しています。
このハッシュの value としては、 `&{ ... }' の中で使用できるものがすべて
を指定できますから、サブルーティン名、サブルーティンへのリファレンス、
無名のサブルーティンといったものがすべて使えます。

`$a+$b' を実行するときに、$A がパッケージ `Number' 内に `bless' された
オブジェクトへのリファレンスである場合か、$A がそのようなマスマジカルな
加法を用意しているパッケージのオブジェクトでなくても、 `$b' が Number
へのリファレンスである場合に、サブルーティン `$OVERLOAD{"+"}' が呼び出
されます。これは、 `$a+=7' とか `$a++' といった、シチュエーションでも呼
ばれます。「*Note マジック自動生成::,」の節を参照してください。(「マス
マジカル」という言葉は、*Note 多重定義::, されたマスマティカル演算子に
よって起動されるメソッドを指しています。)





File: perl-ja.info, Node: 二項演算子の呼び出し方, Next: 単項演算子の呼び出し方, Prev: 多重定義関数の宣言, Up: 多重定義

二項演算子の呼び出し方
======================

`%OVERLOAD' の value の関数は、3 つ (唯一特別な場合があって、その時は4
つ(「*Note 最後の楽園::,」の節を参照))の引数で呼び出されます。対応する
演算子が、 二項演算子であれば、最初の 2 つの引数は、その演算子の 2 つの
引数です。しかしながら、通常のオブジェクトメソッドの呼び出し法の規則に
よって、最初の引数は、常にそのパッケージのオブジェクトでなければなりま
せんので、`7+$a' のような場合には、引数の順序の入れ替えが行なわれます。
これは、加法のメソッドのインプリメンテーションについては、おそらく問題
にはならないものですが、減法のメソッドにとっては、引数を入替えるか否か
は、非常に重大な問題です。サブルーティン側では、この引数の入れ替えにつ
いての情報を3つめの引数を調べることで、確かめることができます。この引数
は、3種類の値をとります:

偽
     引数の順序は、現在の演算子でのものと同じである。

真
     引数は、逆になっている。

undef
     現在の演算子は、( `$a+=7' のような) 代入形式のものであるが、普通の
     関数が、代わりに呼ばれる。この付加的な情報は、何らかの最適化を行な
     うときに、使用することができる。





File: perl-ja.info, Node: 単項演算子の呼び出し方, Next: 多重定義可能な演算子, Prev: 二項演算子の呼び出し方, Up: 多重定義

単項演算子の呼び出し方
======================

単項演算子は、2 番目の引数が未定義値の二項演算子であると考えられます。つ
まり、 `$OVERLOAD{"++"}' は、 `$a++' が実行されるときに、
`($a, undef , ")' という引数で呼び出されます。





File: perl-ja.info, Node: 多重定義可能な演算子, Next: %OVERLOAD の特殊 key, Prev: 単項演算子の呼び出し方, Up: 多重定義

多重定義可能な演算子
====================

ハッシュ `%OVERLOAD' では、以下の key が認識されます:

   * <算術演算子>

     `+', `+=', `-', `-=', `*', `*=',
     `/', `/=', `%', `%=', `**', `**=',
     `<<', `<<=', `>>', `>>=', `x', `x=',
     ` .', `.=',

     これらの演算子について、代入形式のものが存在しないときには、代わり
     に非代入形式のものが呼ばれます。演算子 `+', `-', `+=', `-=' に対す
     るメソッドは、インクリメント演算子やデクリメント演算子を自動生成す
     るために呼ばれることがあります。演算子 `-' は、単項のマイナスや
     `abs' のメソッドがないときに自動生成するために使われます。

   * <比較演算子>

     `<', `<=', `>', `>=', `==', `!=', `<=>',
     `lt', `le', `gt', `ge', `eq', `ne', `cmp',

     ある演算子が無い場合にも、対応する「スペースシップ」形式が使えるな
     らば、代わりに使うことができます。配列のソートのときには、
     `%OVERLAOD' のもとの `cmp' を使って値を比較します。

   * <ビット演算子>

     `&', `^', `|', `neg', `!', `~',

     `neg' は、単項のマイナスを表わします。`neg' のメソッドが指定されて
     いないときには、引き算のメソッドを使って、自動生成されます。

   * <インクリメントとデクリメント>

     `++', `--',

     未定義であれば、足し算と引き算のメソッドが代わりに使われます。これ
     らの演算子は、プリフィクスとしても、ポストフィクスとしても使われま
     す。

   * <超越関数>

     `atan2', `cos', `sin', `exp', `abs', `log', `sqrt',

     `abs' がないときには、`<' か `<=>' のメソッドを、単項のマイナスか
     引き算のメソッドと組み合わせて、自動生成されます。

   * ブール変換、文字列変換、数値変換

     `bool', `""', `0+',

     これらの中で定義していないものがあっても、残りが一つでも定義してあ
     れば、それを代わりに使うことができます。`bool' は、( `while' のよ
     うな) フロー制御演算子や、三項演算子 `?:' で使われます。これらの関
     数は、任意の Perl値を返すことができます。この値に対応する演算子も
     多重定義されている場合には、その演算子がその時の値を使って、再度呼
     び出されることになります。

   * <特殊 key>

     `nomethod', `fallback', `=',

     「*Note %OVERLOAD の特殊 key::,」の章を参照してください。

見つからなかったメソッドが、いつ自動生成されるかという点についての説明は、
*Note Fallback::,を参照してください。





File: perl-ja.info, Node: %OVERLOAD の特殊 key, Next: マジック自動生成, Prev: 多重定義可能な演算子, Up: 多重定義

`%OVERLOAD' の特殊 key
======================

ここまでに説明してきたものの他に、3 つの key が Perl に認識されます。

* Menu:

* 最後の楽園::
* Fallback::
* コピーコンストラクタ::





File: perl-ja.info, Node: 最後の楽園, Next: Fallback, Prev: %OVERLOAD の特殊 key, Up: %OVERLOAD の特殊 key

最後の楽園
----------

`$OVERLOAD{"nomethod"}' は、4つのパラメータを持つ関数へのリファレンスで
す。これが定義されていれば、多重定義の仕組みで、何らかの演算子に対する
メソッドを見つけることができなかったときに、呼び出されます。この関数の
最初の3つの引数は、本来、呼ばれるはずだったメソッドに対する引数と一致し、
4番目の引数は、見つからなかったメソッドに対応する `%OVERLOAD' の key と
なります。いくつかのメソッドが試されている場合には、最後のものが使われ
ます。たとえば、 `1-$a' であれば、

     &{ $Pack::OVERLOAD{"nomethod"} }($a,1,1,"-").

とするのと同じかもしれません。

何らかの演算子が見つからず、`$OVERLOAD{"nomethod"}' もない場合には、(
`$OVERLOAD{"fallback"}' が真でない限り、) `die()' による例外が発生しま
す。




File: perl-ja.info, Node: Fallback, Next: コピーコンストラクタ, Prev: 最後の楽園, Up: %OVERLOAD の特殊 key

Fallback
--------

`$OVERLOAD{"fallback"}' は、特定の演算子に対するメソッドが見つからない
場合の動作を規定します。 `$OVERLOAD{"fallback"}' の value によって、3つ
の場合があります:

   * 未定義

     Perl は、代替のメソッドを使うことを試みます(「*Note マジック自動生
     成::,」の節を参照してください)。それもダメならば、
     `$OVERLOAD{"nomethod"}' を呼び出そうとします。これも無い場合には、
     例外が発生することになります。

   * 「真」

     未定義の場合と同じですが、例外を発生させません。この場合、黙って、
     もし `%OVERLOAD' がなかったときに、行なってであろう動作に戻される
     ことになります。

   * 定義済みだが「偽」

     マジック自動生成は行ないません。Perl は、まず
     `$OVERLOAD{"nomethod"}' の実行を試みて、これがなければ、例外を発生
     させます。





File: perl-ja.info, Node: コピーコンストラクタ, Prev: Fallback, Up: %OVERLOAD の特殊 key

コピーコンストラクタ
--------------------

`$OVERLOAD{"="}' は、3 引数の関数へのリファレンスです。すなわち、見かけ
上は普通の `%OVERLOAD' の `value' と同じです。このサブルーティンの特殊
な点は、(他の多くのメソッドが期待されているように) `bless' された、パッ
ケージへのリファレンスを返す必要がありませんが、被参照した引数の新しい
コピーをかえします(ただし、*Note 多重定義のバグ::, をみてください)。こ
の演算は、

     $a=$b;
     $a++;

のような、他のリファレンスとオブジェクトを共有するリファレンスに対して、
ミューテーターを使うときに呼び出されます。これを、 `$a' を変更し、
`$b' を変更しないようにするために、 `$$a' の新しいコピーを作り、このオ
ブジェクトへのリファレンスが `$a' に代入されます。この操作は、`$a++' の
実行中に (すなわち、その前に`$$a' が `$$b' に一致します)、 `++' が
`$OPERATOR{'++'}' か `$OPERATOR{'+='}' で表現されているときにだけ行なわ
れます。この演算子が、`+' を使って、

     $a=$b;
     $a=$a+1;

のように表現されていれば、 `$$a' も `$$b' も、左辺値として現われること
はありません。

コピーコンストラクタが、いくつかのミューテーターの実行中に必要となって、
`$OPERATOR{'='}' が見つからないときには、そのパッケージのオブジェクトが
単なるスカラであれば、文字列コピーとして自動生成されます。





File: perl-ja.info, Node: マジック自動生成, Next: 多重定義の警告, Prev: %OVERLOAD の特殊 key, Up: 多重定義

マジック自動生成
================

演算子に対するメソッドが見つからず、 `$OVERLOAD{"fallback"}' が「真」か
「未定義」であれば、Perl は、定義されている演算子をもとに、見つからなかっ
た演算子の代わりのメソッドを自動生成しようと試みます。以下の演算子に対
して、自動生成代替メソッドが行なえます:

算術演算子の代入形式
     `$OVERLOAD{"+="}' が定義されていないとき、`$a=+$b' は、
     `$OVERLOAD{"+"}' メソッドを使うことができます。

変換演算子
     文字列、数値、ブール値変換は、すべてが定義されてはいないとき、互い
     に別のもので計算されます。

インクリメントとデクリメント
     演算 `++$a' は、 `$a+=1' か `$a+1' で、演算 `$a--' は、`$a-=1' か
     $a-1 で表現することができます。

`abs($a)'
     `abs($a)' は、 `$a<0' と ` `-$a' ' (または
     `0-$a' ) で表現できます。

単項のマイナス
     単項のマイナスは、引き算を使って表現できます。

連結
     連結は、文字列変換を使って表現できます。

比較演算子
     比較演算は、それぞれに対応するスペースシップ演算 ( `<=>' か
     `cmp' ) を用いて表現することができます: `<', `>',
     `<=', `>=', `==', `!=' は、 `<=>' を使う
     `lt', `gt', `le', `ge', `eq', `ne' は、
     `cmp' を使う

コピー演算
     コピー演算は被参照した値が、 リファレンスではないスカラであれば、
     その値への代入という形で表現できます。





File: perl-ja.info, Node: 多重定義の警告, Next: 多重定義の実装, Prev: マジック自動生成, Up: 多重定義

多重定義の警告
==============

比較演算子に対する制限は、たとえば、`cmp' が `bless' されたリファレンス
を返さなければならないとしても、自動生成された関数`lt' は、`cmp' の結果
の数値に基づく標準の論理値だけを作り出します。特に、この場合には、(とき
には別の変換で表わされた)数値変換が使えないといけません。

同様に、 `.=' 演算子や `x=' 演算子も、文字列変換による代替が起これば、
マスマジカルな性質がなくなります。

マスマジカルなオブジェクトを `chop()' すると、まず文字列になり、マスマ
ジカルな部分はなくなります。同じことは、他の演算でも起こります。





File: perl-ja.info, Node: 多重定義の実装, Next: 多重定義の診断, Prev: 多重定義の警告, Up: 多重定義

多重定義の実装
==============

すべての演算のためのメソッドのテーブルは、該当パッケージのシンボルテーブ
ルに対するマジックとしてキャッシュされます。これは、 `bless' を行な
うときにのみ、 `%OVERLOAD' と `@ISA' の変更を再チェックします。
つまり、動的に変更したいならば、テーブルを更新するために、意味の無い
`bless' を行なう必要があります。

(すべての SV 風のものは、マジックキューを持っており、マジックがキューの
エントリになっています。これによって、1 つの変数が、同時に複数のマジッ
クの形式に関ることができるのです。たとえば、環境変数は普段、`%ENV' マジッ
クと「汚染」マジックの2 つの形式を一度に持っています。)

オブジェクトが `%OVERLOAD' を持つパッケージに属するならば、そのオブジェ
クトには、特別なフラグが用意されます。つまり、多重定義されていない算術
演算を行なうときの、スピードに対する影響は、このフラグのチェックのみで
す。

実際、 `%OVERLOAD' がアクセスされない間は、多重定義可能な演算に対するオー
バヘッドはほとんど無く、ほとんどのプログラムで、認識できるようなパフォー
マスの低下はないはずです。 `%OVERLOAD' がアクセスされ、その時の演算が多
重定義可能なものであったときにも、対象の引数が `%OVERLOAD' を持ったパッ
ケージに属していない場合には、オーバヘッドの最小限にする最大限の努力が
為されました。疑わしいときには、 `%OVERLOAD' がある場合と無い場合で、ス
ピードのテストをしてください。これまでのところ、Perl が最適化を指定して
コンパイル場合には、顕著なスピードの低下の報告はあがっていません。

`%OVERLOAD' が存在しないときには、データの大きさには影響しません。

`$a=$b' のようなコピーは、表層的なものです。しかし、 `$b++' のように、
`$b' (または、 `$a' ) が参照するオブジェクトへの代入を意味する演算の前
に、1 層深度のコピーが行なわれます。この動作は、自分でコピーコンストラ
クタを定義することによって変更することができます (「コピーコンストラク
タ」の項を参照してください)。

明示的にサポートされていないメソッドに対する引数は、定数であることが期
待されます (が、強制はされません)。





File: perl-ja.info, Node: 多重定義の診断, Next: 多重定義のバグ, Prev: 多重定義の実装, Up: 多重定義

多重定義の診断
==============

Perl を `-Do' スイッチか同等のものを使って起動すると、多重定義が、診断
メッセージを誘発します。





File: perl-ja.info, Node: 多重定義のバグ, Prev: 多重定義の診断, Up: 多重定義

多重定義のバグ
==============

多重定義に使用されるため、Perl では、連想配列 {%OVERLOAD} は、パッケー
ジごとに特別な意味を持つことになります。

コピーコンストラクタは、配列へのリファレンスを伴う多重定義演算をより単
純にするように、特別に設計されていますが、動作するときには、現在はこの
事には役に立ちません。(Perl 内部の視点からすると) サブルーティンは、ス
カラを返すのと同じようには、配列を返すことができないからです。コピーコ
ンストラクタのためのインタフェースが変更されることを期待します。

出荷時、 `%OVERLOAD' は `@ISAsel' によって継承されていません。これに対
するパッチが、作者(author)から得られます。このドキュメントは混乱してい
ます。




File: perl-ja.info, Node: 書籍の情報, Prev: 多重定義, Up: Top

書籍の情報
**********

Perl の書籍は、O'Reilly & Associates, 1-800-998-9938 へ注文して入手でき
ます。通常および海外からは 1-707-829-0515 です。O'Reilly の注文票をお持
ちであれば、1-707-829-0104 への FAX も可能です。"Programming Perl" は、
Perl (version 4 なんですが) のほとんどすべてをカバーするリファレンスで
あり、 "Learning Perl" は、この言語のもっとも使われる部分をカバーする
チュートリアルです。(訳注: 通常でない、アメリカの 1-800- で始まる番号は、
0120-のフリーダイヤルのようなサービスです。)

Programming Perl (キャメルブック):
     ISBN 0-937175-64-1 (英語) ISBN 4-89052-384-7 (日本語)

Learning Perl (リャマブック):
     ISBN 1-56592-042-2 (英語)

(訳注: 日本語版はソフトバンクから発売されています。また、サイエンス社、
アスキーより

Perl の国へようこそ:
     ISBN 4-7819-0697-4

Perl 書法:
     ISBN 4-7561-0281-6

入門 Perl:
     ISBN 4-7561-0292-1

が出ています。)





File: perl-ja.info, Node: Function Index, Next: Variable Index, Prev: Top, Up: Top

Function Index
**************


* Menu:

sort: string comparison failed: Illegal byte sequence
sort: Set LC_ALL='C' to work around the problem.
sort: The strings compared were ` UNLESS                       \303\303\302\324\312             LINE  18' and ` IF                           \303\303\302\324\312             LINE  18'.



File: perl-ja.info, Node: Variable Index, Next: Concept Index, Prev: Function Index, Up: Top

Variable Index
**************


* Menu:

sort: string comparison failed: Illegal byte sequence
sort: Set LC_ALL='C' to work around the problem.
sort: The strings compared were `                            \304 \301\272\321\337\312\321\324           LINE  47' and ` ARG                         \304 \301\272\321\337\312\321\324           LINE  46'.



File: perl-ja.info, Node: Concept Index, Prev: Variable Index, Up: Top

Concept Index
*************


* Menu:

sort: string comparison failed: Illegal byte sequence
sort: Set LC_ALL='C' to work around the problem.
sort: The strings compared were ` FILE                     \311\303\315\316\300         LINE  42' and ` LINE                     \311\303\315\316\300         LINE  42'.

