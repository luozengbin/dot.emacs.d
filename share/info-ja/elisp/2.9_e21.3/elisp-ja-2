Info file: elisp-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp-ja.texi'
using `texinfmt.el' version 2.41 of  1 Mar 2005.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Elisp-ja: (elisp-ja).	　　　　　　Emacs-Lisp 2.9日本語マニュアル.
END-INFO-DIR-ENTRY




Emacs Lispリファレンスマニュアル2.9版であり、Emacs 21.3版に対応します。

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
              2000, 2002 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.  A copy of the license is included in the section
entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have freedom to copy and modify
this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."




File: elisp-ja  Node: Copying-Footnotes, Up: Copying

(1) 【注意】現在、このバージョン2の発行者(FSF)住所は、正式に新しい
住所の
 　59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA
 に変わっている。

(2) 【注意】現在、このバージョン2の発行者(FSF)住所は、正式に新しい
住所の59 Temple Place, Suite 330, Boston, MA 02111-1307, USA に変
わっている。



File: elisp-ja, Node: Introduction

はじめに
********

GNU Emacsテキストエディタの大部分は、Emacs Lispと呼ばれるプログラム言語
で記述してあります。Emacs Lispで新たなコードを書いて、それをエディタの
拡張としてインストールできます。しかし、Emacs Lispは、単なる『拡張言語』
ではありません。それ自身、れっきとしたプログラム言語です。他のプログラ
ム言語でできることは、Emacs Lispでできます。

Emacs Lispは、エディタで使うために設計してあるため、ファイル、バッファ、
ディスプレイ、サブプロセスなどを扱う機能に加えて、テキストを走査し解析
する特別な機能もあります。Emacs Lispは編集機構に密に組み込まれています。
このため、編集コマンドはLispプログラムからも呼び出せる関数ですし、カス
タマイズのためのパラメータは普通のLisp変数です。

本書は、Emacs Lispを完全に記述することを目指しています。初心者向けの入
門には、Free Software Foundation刊、Bob Chassellの`An Introduction to
Emacs Lisp Programming' (1) (*Note Introduction-Footnotes::) をご覧くだ
さい。本書では、Emacsの操作を熟知しているものと仮定します。操作に関する
基本的な情報は、`The GNU Emacs Manual' (2) (*Note
Introduction-Footnotes::) を参照してください。

おおまかにいえば、始めのほうの章では、多くのプログラム言語に見られる機
能に相当するEmacs Lispの機能を説明し、あとのほうの章では、Emacs Lispに
特有の機能や編集に特化した機能を説明します。

本書は、2.5版です。

* Menu:

* Caveats::             Flaws and a request for help.
* Lisp History::        Emacs Lisp is descended from Maclisp.
* Conventions::         How the manual is formatted.
* Version Info::        Which Emacs version is running?
* Acknowledgements::    The authors, editors, and sponsors of this manual.


File: elisp-ja  Node: Introduction-Footnotes, Up: Introduction

(1) 【訳注】日本語訳：『Emacs Lispプログラミング入門』、アスキー出版局、
ISBN 4-7561-1805-4

(2) 【訳注】日本語訳：『GNU Emacsマニュアル』、アスキー出版局、ISBN
4-7561-3002-X



File: elisp-ja, Node: Caveats, Next: Lisp History, Prev: Introduction, Up: Introduction

警告
====

本書は、数多くの草稿を重ねてきました。ほぼ完璧に近いはずですが、誤りは
皆無ではありません。ふれていない話題も少なからずあります。（大部分の個
別のモードのような）副次的と捉えている話題や、まだ執筆していない話題も
あります。完全にはこれらに対処しきれませんので、意図的に省いたことがら
もあります。たとえば、VMSにおける利用方法に関する情報です。

本書で取り上げたことがらに関しては、本書は完璧であるべきですから、例題
や記述内容から章や節の構成順序といったことまで、広く意見を求めています。
混乱を招くような記述や、本書でふれていないことがらを学ぶためにソースや
実験で調べる必要があるときには、本書を改訂すべきなのでしょう。そのとき
は、ぜひ、教えてください。


本書を読むときには、訂正箇所をみつけたらすぐ送ってくださるようにお願い
します。1つの関数や一連の関数向けに、簡素で実用に即した例を思い付いたな
らば、それを書き上げて、送ってください。章／節／関数の名前を適宜入れて
ください。それから、どの版に対する意見かも書いてください。

意見や訂正は、下記へメイルしてください。

     bug-lisp-manual@gnu.org

ここに蓄積されたメイルは、誰かが改訂作業を始めるまでは、読み出しません。
改訂までに、数か月、ときには、数年経過することもあります。
ですから、返事がないと憤慨しないでください。
あなたのメイルは、そのうち処理*されます*。
Emacs保守グループに迅速に連絡したい場合には、
`bug-gnu-emacs@gnu.org'にメイルしてください。



File: elisp-ja, Node: Lisp History, Next: Conventions, Prev: Caveats, Up: Introduction

Lispの歴史
==========

Lisp（LISt Processing language、リスト処理言語）は、人工知能の研究向け
に1950年代末にMITで初めて開発されました。Lisp言語はとても強力なので、エ
ディタコマンドを記述するなどの他の目的にも理想的なのです。

長年にわたって何ダースものLispが実装されており、それぞれが独自の特徴を
有しています。その多くは、1960年代のMITのMACプロジェクトで開発された
Maclispの影響を受けています。最終的には、Maclispの系統の実装者達は共同
して、Common Lispと呼ばれるLispシステムの規格を開発しました。そうこうす
るうちに、MITのGerry SussmanとGuy Steeleは、単純化してあるが非常に強力
なSchemeと呼ばれるLispの方言を開発しました。

GNU EmacsはMaclispの影響を強く受けていますが、Common Lispからの影響は少
ないです。Common Lispを知っている読者は、Common Lispとの多くの類似点に
気づかれるでしょう。しかしながら、Common Lispの多くの機能は、省いてある
か、単純化してあります。これは、GNU Emacsが必要とするメモリ量を削減する
ためです。ときには、劇的に単純化してあるために、Common Lispユーザーは混
乱するかもしれません。GNU Emacs LispとCommon Lispとの相違点は、ことある
ごとに指摘するつもりです。Common Lispを知らない読者は、何も心配すること
はありません。本書は自己完結しています。

`cl'ライブラリにより、Common Lispをかなりエミュレートできます。
*Note Common Lisp Extension: (cl)Top。

Emacs LispはSchemeの影響をまったく受けていません。しかし、GNUプロジェク
トには、Guileと呼ばれるSchemeの実装があります。拡張が必要なすべての新た
なGNUソフトウェアではGuileを使います。



File: elisp-ja, Node: Conventions, Next: Version Info, Prev: Lisp History, Up: Introduction

表記法
======

本節では、本書で用いる表記法を説明します。本節を読み飛ばして、あとで参
照してもかまいません。

* Menu:

* Some Terms::               Explanation of terms we use in this manual.
* nil and t::                How the symbols `nil' and `t' are used.
* Evaluation Notation::      The format we use for examples of evaluation.
* Printing Notation::        The format we use when examples print text.
* Error Messages::           The format we use for examples of errors.
* Buffer Text Notation::     The format we use for buffer contents in examples.
* Format of Descriptions::   Notation for describing functions, variables, etc.



File: elisp-ja, Node: Some Terms, Next: nil and t, Prev: Conventions, Up: Conventions

用語
----

本書では、『Lispリーダ』および『Lispプリンタ』という言葉で、Lispオブジェ
クトのテキスト表現を実際のLispオブジェクトに変換するLisp内部のルーティ
ン群、および、逆の変換を行うルーティン群を指します。詳しくは、*Note
Printed Representation::。本書の読者を『プログラマ』と考えて『読者』と
呼びます。『ユーザー』とは作者自身を含めたLispプログラムを使う人のこと
です。

Lispコードの例は、`(list 1 2 3)'という形式で、
このフォントで記します。
メタな変数の名前や説明対象の関数に対する引数の名前は、
FIRST-NUMBERという形式で、このフォントで書きます。



File: elisp-ja, Node: nil and t, Next: Evaluation Notation, Prev: Some Terms, Up: Conventions

`nil'と`t'
----------

Lispでは、シンボル`nil'には3つの異なる意味があります。まず、`nil'という
名前のシンボルです。2つめは、真理値の偽（false）です。3つめは、空リスト、
つまり、要素数が0個のリストです。変数として使った場合、`nil'の値はつね
に`nil'です。

Lispリーダにとっては、`()'と`nil'は同一です。どちらも、同じオブジェクト、
シンボル`nil'を表します。シンボルを異なった書き方にするのは、完全に人間
向けです。`()'や`nil'をLispリーダが読み取ったあとでは、プログラマが実際
にどちらの表記を用いたかわかりません。

本書では、空リストを強調するときには`()'を使い、真理値の偽を強調すると
きには`nil'を使います。これは、Lispプログラムでも使うとよい慣習です。

     (cons 'foo ())                ; 空リストであることを強調する
     (not nil)                     ; 真理値の偽であることを強調する

真理値の真を必要とする場面では、`nil'以外の値は、真（true）であるとみな
します。しかし、真を表す望ましい書き方は`t'です。真を表す値が必要なとき、
適当な判断基準がない場合には`t'を使います。シンボル`t'の値はつねに`t'で
す。

Emacs Lispでは、`nil'と`t'は特別なシンボルであり、
評価するとそれ自身になります。
そのため、これらをプログラム内で定数として使うとき、
これらをクォートする必要はありません。
これらの値を変更しようとすると、エラー`setting-constant'になります。
コロン（`:'）で始まる名前のシンボルも同様です。
*Note Constant Variables::。



File: elisp-ja, Node: Evaluation Notation, Next: Printing Notation, Prev: nil and t, Up: Conventions

評価の表記法
------------

評価可能なLisp式を"フォーム"（form、形式）と呼びます。フォームを評価す
ると、Lispオブジェクトである結果を生じます。本書の例題では、これを`=>'
で表します。

     (car '(1 2))
          => 1

これは、『`(car '(1 2))'を評価すると1になる』と読みます。

フォームがマクロ呼び出しの場合には、Lispが評価すべき新たなフォームに展
開します。展開結果を`==>'で表します。展開したフォームの評価結果を示す場
合もあれば、示さない場合もあります。

     (third '(a b c))
          ==> (car (cdr (cdr '(a b c))))
          => c

あるフォームを説明するときに、同一の結果を生じる別のフォームを示すこと
があります。2つのまったく等価なフォームを`=='で表します。

     (make-sparse-keymap) == (list 'keymap)



File: elisp-ja, Node: Printing Notation, Next: Error Messages, Prev: Evaluation Notation, Up: Conventions

結果表示の表記法
----------------

本書の数多くの例題は、評価するとテキストを表示します。（`*scratch*'バッ
ファのような）Lisp対話バッファで例題のコードを実行すると、表示テキスト
はバッファに挿入されます。（関数`eval-region'で評価するなどの）別の手段
で例題を実行すると、表示テキストはエコー領域に表示されます。エコー領域
に表示されるテキストは、1行に切り詰められていることに注意してください。

本書の例題では、表示場所には無関係に、表示テキストを`-|'で表します。
フォームを評価した結果返される値（ここでは`bar'）は、後続の行に分けて書
きます。

     (progn (print 'foo) (print 'bar))
          -| foo
          -| bar
          => bar



File: elisp-ja, Node: Error Messages, Next: Buffer Text Notation, Prev: Printing Notation, Up: Conventions

エラーメッセージ
----------------

エラーを通知する例題もあります。これは、通常、エコー領域にエラーメッセー
ジを表示します。エラーメッセージは、`error-->'で始まる行に示します。エ
コー領域には、`error-->'は表示されないことに注意してください。

     (+ 23 'x)
     error--> Wrong type argument: number-or-marker-p, x



File: elisp-ja, Node: Buffer Text Notation, Next: Format of Descriptions, Prev: Error Messages, Up: Conventions

バッファ内のテキストの表記法
----------------------------

バッファ内のテキストを修正する例題もあります。このような場合、『実行前』
と『実行後』のテキストを示します。それらの例題では、バッファ名を含めた
ダッシュから成る2行で挟んで、当該バッファの内容を示します。さらに、ポイ
ント位置を`-!-'で表します。（もちろん、ポイントを表す記号は、バッファ内
のテキストの一部ではない。現在ポイントが位置する2つの文字の*あいだ*を表
す。）

     ---------- Buffer: foo ----------
     This is the -!-contents of foo.
     ---------- Buffer: foo ----------

     (insert "changed ")
          => nil
     ---------- Buffer: foo ----------
     This is the changed -!-contents of foo.
     ---------- Buffer: foo ----------



File: elisp-ja, Node: Format of Descriptions, Prev: Buffer Text Notation, Up: Conventions

記述形式
--------

関数、変数、マクロ、コマンド、ユーザーオプション、スペシャルフォームは、
本書では統一した形式で記述します。第1行目は、それぞれの名前と、引数があ
れば引数群です。関数、変数、マクロ、コマンド、ユーザーオプションの分類
を行頭に書きます。これに説明文が続き、場合によっては例題も示します。

* Menu:

* A Sample Function Description::       A description of an imaginary
                                          function, `foo'.
* A Sample Variable Description::       A description of an imaginary
                                          variable,
                                          `electric-future-map'.



File: elisp-ja, Node: A Sample Function Description, Next: A Sample Variable Description, Prev: Format of Descriptions, Up: Format of Descriptions

関数の記述例
............

関数の記述では、まず始めに説明対象の関数名があります。同じ行には、引数
名の並びも続きます。これらの名前は、説明文の中で引数の値を参照するため
に使います。

引数ならびにキーワード`&optional'が現れていれば、それ以降の引数を省略で
きることを示します（省略した引数の値は`nil'）。関数を呼び出すときに
`&optional'を書いてはいけません。

キーワード`&rest' （このあとには1つの引数名だけが続く）は、残りの引数が
何個でもよいことを示します。直後にある1つの引数名は、変数としての値を持
ち、その値は残りのすべての引数のリストです。関数を呼び出すときに
`&rest'を書いてはいけません。

では、仮想的な関数`foo'の記述を以下に示します。

 -- Function: foo INTEGER1 &optional INTEGER2 &rest INTEGERS
     関数`foo'は、INTEGER2からINTEGER1を引き算し、
     残りのすべての引数を減算結果に加える。
     INTEGER2を指定しないと、デフォルトでは、数19から引き算する。

          (foo 1 5 3 9)
               => 16
          (foo 5)
               => 14

     より一般的には、つぎのとおり。

          (foo W X Y...)
          ==
          (+ (- X W) Y...)

（INTEGER、INTEGER1、BUFFERなどの）型名を名前とする引数は、その型の値で
あると仮定します。（BUFFERSのように）型を複数形にした場合には、しばしば、
その型のオブジェクトのリストを意味します。OBJECTという名前の引数は、任
意の型でかまいません。（Emacsオブジェクトの型の一覧については、*Note
Lisp Data Types::）。（NEW-FILEなどの）その他の名前の引数は、関数の説明
文の中で言及します。複数の関数の引数に共通する特徴について、節の始めで
説明する場合もあります。

`&optional'と`&rest'についての詳しい説明は、
*Note Lambda Expressions::。

コマンド、マクロ、スペシャルフォームの記述も同じ形式ですが、「関数」の
かわりに「コマンド」、「マクロ」、「スペシャルフォーム」のいずれかです。
コマンドは、対話的に呼び出せる単なる関数です。マクロは関数とは違った方
法で引数を処理します（引数を評価しない）が、同じ方法で引数を記します。

スペシャルフォームの記述では、省略可能な引数や繰り返される引数を示すた
めに、より複雑な記法を使います。というのは、引数並びを個々の引数に分離
する方法が複雑だからです。`[OPTIONAL-ARG]'は、OPTIONAL-ARGが省略可能で
あることを示します。また、`REPEATED-ARGS...'は、0個以上の引数を示します。
いくつかの引数をリスト構造の内側にまとめるときには、括弧を使います。

 -- Special form: count-loop (VAR [FROM TO [INC]]) BODY...
     この仮想的なスペシャルフォームは、フォーム群BODYを実行してから変数
     VARを増やすことを反復するループを実現する。最初は、変数の値はFROM
     である。以降の反復では、変数を1（あるいは、指定があればINCだけ）増
     やす。VARがTOに等しくなると、BODYを実行せずにループから抜ける。例
     を示す。

          (count-loop (i 0 10)
            (prin1 i) (princ " ")
            (prin1 (aref vector i))
            (terpri))

     FROMとTOを省略すると、ループ開始前にVARに`nil'を束縛し、各反復の開
     始時にVARが`nil'以外であるとループから抜け出る。

          (count-loop (done)
            (if (pending)
                (fixit)
              (setq done t)))

     このスペシャルフォームでは、引数FROMとTOは省略できるが、
     両者を同時に指定するか、同時に省略すること。
     これらを指定した場合、INCを指定してもよい。
     これらの引数は、引数VARとともにリストにまとめる。
     これはBODYと区別するためであり、
     BODYは残りのフォームの要素すべてを含む。



File: elisp-ja, Node: A Sample Variable Description, Prev: A Sample Function Description, Up: Format of Descriptions

変数の記述例
............

"変数"（variable）は、値を保持するための名前です。ユーザーはどんな変数
でも設定できますが、ユーザーが変更可能な特定の変数群があり、それらを"ユー
ザーオプション"（user options）と呼びます。普通の変数もユーザーオプショ
ンも関数の記述と同じ形式で示しますが、それらに引数はありません。

仮想的な変数`electric-future-map'の記述例を示します。

 -- Variable: electric-future-map
     この変数の値は、Electric Command Futureモードで使用する完全なキー
     マップである。このマップに含まれる関数は、まだ実行していないコマン
     ドの編集を可能にする。

ユーザーオプションの記述も同じ形式ですが、「変数」のかわりに「ユーザー
オプション」です。



File: elisp-ja, Node: Version Info, Next: Acknowledgements, Prev: Conventions, Up: Introduction

版情報
======

これらの機構は、使用中のEmacsの版に関する情報を提供します。

 -- コマンド: emacs-version
     この関数は、実行中のEmacsの版を記述した文字列を返す。この文字列は
     バグの報告に含めると有益である。

          (emacs-version)
            => "GNU Emacs 20.3.5 (i486-pc-linux-gnulibc1, X toolkit)
           of Sat Feb 14 1998 on psilocin.gnu.org"

     対話的に呼び出すと、この関数は同じ情報をエコー領域に表示する。

 -- Variable: emacs-build-time
     この変数の値は、ローカルのサイトでEmacsを構築した日時を示す。
     3つの整数から成るリストであり、
     `current-time'と同様のもの（*Note Time of Day::）。

          emacs-build-time
               => (13623 62065 344633)

 -- Variable: emacs-version
     この変数の値は、実行中のEmacsの版番号。`"20.3.1"'のような文字列で
     ある。この文字列の最後の数字は、Emacsのリリース版番号の一部ではな
     く、特定のディレクトリでEmacsを構築するたびに増える。

つぎの2つの変数は、Emacs 19.23以降に存在します。

 -- Variable: emacs-major-version
     Emacsのメジャー版番号を表す整数。Emacs 20.3では、値は20。

 -- Variable: emacs-minor-version
     Emacsのマイナ版番号を表す整数。Emacs 20.3では、値は3。



File: elisp-ja, Node: Acknowledgements, Prev: Version Info, Up: Introduction

謝辞
====

本書は、Robert Krawitz、Bil Lewis、Dan LaLiberte、Richard M. Stallman、
Chris Welty、GNUマニュアルプロジェクトのボランティアによる何年にもわた
る努力で執筆されました。Computational Logic社のWarren A. Hunt, Jr.が手
配した国防省Advanced Research Projects Agency、ARPA Order 6082の援助の
もと、Robert J. Chassellは本書のレビューと編集に協力してくれました。

以下の方々が訂正を送ってくれました。Karl Berry、Jim Blandy、Bard Bloom、
Stephane Boucher、David Boyes、Alan Carroll、Richard Davis、Lawrence
R. Dodd、Peter Doornbosch、David A. Duff、Chris Eich、Beverly
Erlebacher、David Eckelkamp、Ralf Fassel、Eirik Fuller、Stephen Gildea、
Bob Glickstein、Eric Hanchrow、George Hartzell、Nathan Hess、Masayuki
Ida、Dan Jacobson、Jak Kirman、Bob Knighten、Frederick M. Korz、Joe
Lammens、Glenn M. Lewis、K. Richard Magill、Brian Marick、Roland
McGrath、Skip Montanaro、John Gardiner Myers、Thomas A. Peterson、
Francesco Potorti、Friedrich Pukelsheim、Arnold D. Robbins、Raul
Rockwell、Per Starback、Shinichirou Sugou、Kimmo Suominen、Edward
Tharp、Bill Trost、Rickard Westman、Jean White、Matthew Wilding、Carl
Witty、Dale Worley、Rusty Wright、David D. Zuhn。


File: elisp-ja, Node: Lisp Data Types, Next: Numbers, Prev: Introduction, Up: Top

Lispのデータ型
**************

Lisp"オブジェクト"（object）とは、Lispプログラムが使用し操作するデータ
のことです。"型"（type）や"データ型"（data type）とは、ここでは、可能な
オブジェクトの集合を意味します。

各オブジェクトは、少なくとも、1つの型に属します。同じ型のオブジェクトは、
構造に類似性があり、普通、同じ文脈で使われます。型は互いに重複していて
もよく、オブジェクトは複数の型に属することができます。そのため、オブジェ
クトが特定の型に属するかどうかは判断できますが、オブジェクトの型を『1つ』
に限定することはできません。

Emacsには少数の基本オブジェクト型を組み込んであります。これらの型は他の
すべてのオブジェクト型を構成するもとであり、"基本型"（primitive types）
と呼びます。各オブジェクトはたった1つの基本型に属します。基本型には、"
整数"（integer）、"浮動小数点数"（float）、"コンス"（cons）、"シンボル
（symbol）、"文字列"（string）、"ベクトル"（vector）、"subr"、"バイトコー
ド関数"（byte-code function）、ならびに、編集に関連する"バッファ
（buffer）などの特別な型があります。（*Note Editing Types::。）

各基本型には、その型に属するオブジェクトであるかどうかを検査する対応す
るLisp関数があります。

Lispオブジェクトは"型を自己記述"（self-typing）するという点で、Lispは他
の多くの言語とは異なります。つまり、オブジェクトの基本型は、オブジェク
ト自体に暗に含まれています。たとえば、オブジェクトがベクトルであれば、
それを数と扱うことはありません。Lispには、ベクトルは数ではないとわかっ
ているのです。

多くの言語では、プログラマは各変数のデータ型を宣言する必要があります。
型はコンパイラが知っているのであって、データの中には入っていません。こ
のような型宣言はEmacs Lispには存在しません。Lisp変数はどんな型の値でも
保持でき、変数に入れた値と型を記録しています。

本章では、GNU Emacs Lispの各標準型の表示表現と入力構文を説明します。こ
れらの型の使用方法の詳細は、あとの章に譲ります。

* Menu:

* Printed Representation::      How Lisp objects are represented as text.
* Comments::                    Comments and their formatting conventions.
* Programming Types::           Types found in all Lisp systems.
* Editing Types::               Types specific to Emacs.
* Type Predicates::             Tests related to types.
* Equality Predicates::         Tests of equality between any two objects.



File: elisp-ja, Node: Printed Representation, Next: Programming Types, Prev: Lisp Data Types, Up: Lisp Data Types

表示表現と入力構文
==================

オブジェクトの"表示表現"（printed representation）とは、
Lispプリンタ（関数`prin1'）がそのオブジェクトを出力表示するときの
書式です。
オブジェクトの"入力構文"（read syntax）とは、
Lispリーダ（関数`read'）がそのオブジェクトを入力として受理する書式です。
*Note Read and Print::。

ほとんどのオブジェクトには1つ以上の可能な入力構文があります。ある種の型
のオブジェクトには入力構文はありませんが、そのような型のオブジェクトを
Lispプログラムに直接入力する意味がないからです。このような場合を除くと、
オブジェクトの表示表現はそのオブジェクトの入力構文でもあります。

他の言語では、式はテキストであって、これ以外の形はありません。Lispでは、
式はとにかくLispオブジェクトであって、オブジェクトの入力構文であるテキ
ストは副次的なものです。この違いを強調する必要はありませんが、このこと
を心に留めておかないと混乱することがあります。

各型には表示表現があります。入力構文のない型もあります。たとえば、バッ
ファ型には入力構文はありません。このような型のオブジェクトは"ハッシュ記
法"（hash notation）で表示します。つまり、文字列`#<'のあとに説明用の文
字列（典型的には型名にオブジェクトの名前を続けたもの）を続け、対応する
`>'で閉じます。ハッシュ記法を読み取ることはできませんから、Lispリーダが
`#<'に出会うとエラー`invalid-read-syntax'を通知します。

     (current-buffer)
          => #<buffer objects.texi>

読者が対話的に式を評価するとき、
Lispインタープリタは、まず、
式のテキスト表現を読み取ってLispオブジェクトを生成し、
そのオブジェクトを評価します（*Note Evaluation::）。
しかしながら、評価と読み取りは別々の動作です。
読み取りでは、読み取ったテキストが表すLispオブジェクトを返します。
このオブジェクトを、のちに評価する場合もありますが、
評価しない場合もあります。
オブジェクトを読み取る基本関数`read'については、
*Note Input Functions::。



File: elisp-ja, Node: Comments, Next: Programming Types, Prev: Lisp Data Types, Up: Lisp Data Types

コメント
========

"コメント"（comment）は、プログラム内に書かれたテキストであり、プログラ
ムを読む人間のためだけにあり、プログラムの意味にはまったく影響しません。
Lispでは、文字列や文字定数の外にあるセミコロン（`;'）でコメントを始めま
す。コメントは行末までです。Lispリーダは、コメントを破棄します。コメン
トは、Lispシステム内部でプログラムを表すLispオブジェクトの一部にはなり
ません。

`#@COUNT'という書き方は、後続のCOUNT個の文字を飛び越します。これは、プ
ログラムで生成したバイナリデータを含むコメントに便利です。Emacs Lispの
バイトコンパイラは、出力ファイルにこのようなコメントを使います（*Note
Byte Compilation::）。しかしながら、ソースファイル向きではありません。

コメントの体裁に関する慣習については、*Note Comment Tips::。



File: elisp-ja, Node: Programming Types, Next: Editing Types, Prev: Lisp Data Types, Up: Lisp Data Types

プログラミング向けの型
======================

Emacs Lispには、大きく2種類の型があります。Lispのプログラミングに関わる
ものと、編集に関わるものです。前者は、さまざまな形でLispの多くの実装に
見られます。後者は、Emacs Lispに固有です。

* Menu:

* Integer Type::        Numbers without fractional parts.
* Floating Point Type:: Numbers with fractional parts and with a large range.
* Character Type::      The representation of letters, numbers and
                        control characters.
* Symbol Type::         A multi-use object that refers to a function,
                        variable, or property list, and has a unique identity.
* Sequence Type::       Both lists and arrays are classified as sequences.
* Cons Cell Type::      Cons cells, and lists (which are made from cons cells).
* Array Type::          Arrays include strings and vectors.
* String Type::         An (efficient) array of characters.
* Vector Type::         One-dimensional arrays.
* Char-Table Type::     One-dimensional sparse arrays indexed by characters.
* Bool-Vector Type::    One-dimensional arrays of `t' or `nil'.
* Function Type::       A piece of executable code you can call from elsewhere.
* Macro Type::          A method of expanding an expression into another
                          expression, more fundamental but less pretty.
* Primitive Function Type::     A function written in C, callable from Lisp.
* Byte-Code Type::      A function written in Lisp, then compiled.
* Autoload Type::       A type used for automatically loading seldom-used
                        functions.



File: elisp-ja, Node: Integer Type, Next: Floating Point Type, Prev: Programming Types, Up: Programming Types

整数型
------

Emacs Lispにおける整数の値の範囲は、ほとんどの計算機では、
-134217728から134217727（28ビット長。つまり
-2**27
から2**27 - 1）
です。
（計算機によっては、より広い範囲になる。）
Emacs Lispの算術演算関数は、桁溢れ（オーバフロー）を
検査しないことを覚えておいてください。
したがって、ほとんどの計算機では、
`(1+ 134217727)'は-134217728となります。

整数の入力構文は、（10を基数とした）数字の並びであり、先頭に符号があっ
てもよく、また、最後にピリオドがあってもかまいません。Lispインタープリ
タが生成する表示表現では、先頭の`+'や最後の`.'はありません。

     -1               ; 整数 -1
     1                ; 整数 1
     1.               ; これも整数 1
     +1               ; これも整数 1
     268435457        ; 28ビット長整数では、これも整数 1

より詳しくは、*Note Numbers::。



File: elisp-ja, Node: Floating Point Type, Next: Character Type, Prev: Integer Type, Up: Programming Types

浮動小数点数
------------

Emacsは浮動小数点数を扱えます（ただし、コンパイル時のオプションで使用不
可にできる）。浮動小数点数の範囲は、計算機に依存します。

浮動小数点数の表示表現には、小数点（に続けて1桁以上の小数部分）または指
数、あるいは、その両方が必要です。たとえば、`1500.0'、`15e2'、`15.0e2'、
`1.5e3'、`.15e4'は、同じ1500という値の浮動小数点数を書く5つの方法です。
どれも、まったく等価です。

詳しくは、*Note Numbers::。



File: elisp-ja, Node: Character Type, Next: Symbol Type, Prev: Floating Point Type, Up: Programming Types

文字型
------

Emacs Lispにおける"文字"（character）は、
整数以外の何物でもありません。
いいかえれば、文字はその文字コードで表現されます。
たとえば、文字`A'は整数 65と表現されます。

プログラムで個々の文字を独立に使うことはあまりありません。
文字を並べた*文字列*（strings）として扱うことが断然多いのです。
*Note String Type::。

文字列内、バッファ内、ファイル内の文字は、現時点では、0から524287までの
範囲、19ビット長に制限されます。しかし、この範囲の値すべてが正しい文字
コードではありません。0から127までのコードはASCIIコードです。それ以外は、
非ASCIIです（*Note Non-ASCII Characters::）。キーボード入力を表す文字は、
コントロール、メタ、シフトなどの修飾キーを符号化するために、範囲がより
広くなります。

文字は、実際には整数ですから、文字の表示表現は10進数です。また、文字の
入力構文として10進数も可能ですが、Lispプログラムでこのように文字を書く
のは最悪です。Emacs Lispに用意してある文字向けの特別な入力構文を*つねに
*使うべきです。これらの構文は疑問符で始まります。

英数字向けの普通の入力構文は、疑問符に続けて1つの英数字を書きます。した
がって、文字`A'は`?A'、文字`B'は`?B'、文字`a'は`?a'と書きます。

たとえば、つぎのとおりです。

     ?Q => 81     ?q => 113

同じ入力構文を句読点文字にも使えますが、
`\'を追加して、Lispコードを編集するEmacsコマンドが混乱しないように
することがよいでしょう。
たとえば、空白文字は`?\ 'と書きます。
文字`\'は、クォートするために2つめの`\'を使う*必要があり*
`?\\'です。

コントロールg、バックスペース、タブ、改行、垂直タブ、ページ送り、復帰、
エスケープは、それぞれ、`?\a'、`?\b'、`?\t'、`?\n'、`?\v'、`?\f'、
`?\r'、`?\e'と書きます。つまり、つぎのとおりです。

     ?\a => 7                 ; C-g
     ?\b => 8                 ; バックスペース、 BS、C-h
     ?\t => 9                 ; タブ、 TAB、C-i
     ?\n => 10                ; 改行、C-j
     ?\v => 11                ; 垂直タブ、C-k
     ?\f => 12                ; ページ送り文字、C-l
     ?\r => 13                ; 復帰、RET, C-m
     ?\e => 27                ; エスケープ文字、ESC、C-[
     ?\\ => 92                ; バックスラッシュ文字、\

バックスラッシュで始まる系列は"エスケープシーケンス"（escape sequences）
とも呼びます。バックスラッシュが、エスケープ文字の役割を果たすからです。
この使い方は、文字ESCとは関係ありません。

コントロール文字は別の入力構文でも表現できます。疑問符に続けてバックス
ラッシュ、カレット（`^'）、そして、対応するコントロールでない文字を大文
字か小文字で書きます。たとえば、`?\^I'も`?\^i'も、値が9である文字`C-i'
の正しい入力構文です。

カレットのかわりに、`C-'を使ってもかまいません。ですから、`?\C-i'は、
`?\^I'や`?\^i'と等価です。

     ?\^I => 9     ?\C-I => 9

文字列やバッファ内ではASCIIのコントロール文字だけが許されますが、キーボー
ド入力においては`C-'で任意の文字をコントロール文字にできます。これらの
非ASCIIコントロール文字の文字コードは、対応する非コントロール文字の文字
コードと2**26 のビットを含みます。普通の端末では、非ASCIIコントロール文
字を生成する手立てはありませんが、Xウィンドウシステムや他のウィンドウシ
ステムでは、簡単に生成できます。

歴史的な理由で、EmacsはDEL文字を`?'に対応したコントロール文字として扱い
ます。

     ?\^? => 127     ?\C-? => 127

その結果、今のところ、
Xウィンドウシステムのもとでは意味のある文字`Control-?'を
`\C-'では表現できません。

ファイルや文字列に現れるコントロール文字を表現するには、`^'構文を勧めま
す。キーボード入力のコントロール文字には、`C-'構文が好ましいです。どち
らを使ってもプログラムの意味には影響しませんが、それを読む人には理解の
手助けになるかもしれません。

"メタ文字"（meta character）は、META修飾キーを使って打った文字です。そ
のような文字を表す整数は、（ほとんどの計算機では負の数になる）2**27 の
ビットがセットされています。上位のビットをメタや他の修飾子に用いること
で、基本となる文字コードの範囲をできるだけ大きくします。

文字列では、メタ文字を表すASCII文字には2**7 のビットを付加します。つま
り、文字列に収められるメタ文字のコードは128から255の範囲であり、任意の
ASCII文字のメタ変種を使えます。（Emacs 18やそれ以前では、この方式を文字
列の外にある文字にも使っていた。）

メタ文字の入力構文には`\M-'を使います。
たとえば、`?\M-A'は`M-A'です。
`\M-'と一緒に8進文字コードも使えますし（下記参照）、
`\C-'や文字向けの他の構文も使えます。
したがって、`M-A'は`?\M-A'と書いたり`?\M-\101'と書けます。
同様に、`C-M-b'は`?\M-\C-b'、
`?\C-\M-b'、`?\M-\002'と書けます。

図形文字の大文字小文字は、その文字コードで示されます。たとえば、ASCIIで
は`a'と`A'の文字を区別します。しかし、ASCIIではコントロール文字の大文字
小文字を表現できません。Emacsでは、コントロール文字を打つときに使ったシ
フトキーを表すために2**25 のビットを付加します。このような区別はX端末や
他の特別な端末を使っている場合に限り可能です。普通の端末ではこのような
区別を計算機に送れません。

Xウィンドウシステムでは、文字に設定可能な修飾ビットが他に3つあります。
ハイパー"（hyper）、"スーパー"（super）、"アルト"（alt）です。これらの
修飾ビットの構文は、`\H-'、`\s-'、`\A-'です。（これらのプレフィックスで
は、大文字小文字を区別する。）したがって、`?\H-\M-\A-x'は
`Alt-Hyper-Meta-x'を表します。数値的には、アルトは2**22、スーパーは
2**23、ハイパーは2**24のビット値です。

文字向けのもっとも汎用の入力構文では、
文字コードを8進数や16進数で表現します。
8進数を使うには、順に、
疑問符、バックスラッシュ、（3桁までの）8進数字文字コードを書きます。
たとえば、`?\101'は文字`A'を表し、
`?\001'は文字`C-a'を表し、`?\002'は文字`C-b'を表します。
この構文で任意のASCII文字を表現できますが、
ASCIIでの表現よりも8進数値で表現することが重要な場合に限るべきです。

     ?\012 => 10         ?\n => 10         ?\C-j => 10
     ?\101 => 65         ?A => 65

16進数を使うには、順に、疑問符、バックスラッシュ、`x'、16進数字文字コー
ドを書きます。16進数の桁数はいくつでもよいので、任意の文字コードを表現
できます。したがって、`?\x41'は文字`A'を表し、`?\x1'は文字`C-a'を表し、
`?\x8e0'はグレーブアクセント付きの文字`a'を表します。

特別なエスケープの意味を持たないどんな文字のまえにもバックスラッシュを
付けることができ、しかも、無害です。
したがって、`?\+'は`?+'に等価です。
ほとんどの文字のまえにバックスラッシュを付ける理由はありません。
しかしながら、Lispコードを編集するEmacsコマンドが混乱しないように、
`()\|;'`"#.,'のいずれかの文字のまえにはバックスラッシュを付けるべきです。
空白、タブ、改行、ページ送りのような白文字のまえにも
バックスラッシュを付けるべきです。
しかしながら、タブなどの実際の白文字のかわりに、
`\t'などの読みやすいエスケープシーケンスを使ったほうが明確です。



File: elisp-ja, Node: Symbol Type, Next: Sequence Type, Prev: Character Type, Up: Programming Types

シンボル型
----------

GNU Emacs Lispにおける"シンボル"（symbol）は、名前を持ったオブジェクト
です。シンボル名は、シンボルの表示表現としての役割があります。普通の使
い方では、名前は一意です。つまり、2つのシンボルが同じ名前を持つことはあ
りません。

シンボルは、変数としての役割、関数名としての役割、あるいは、属性リスト
を保持する役割を果たします。また、他のすべてのLispオブジェクトと区別す
るためだけの役割を果たすこともあり、データ構造の内部にそのようなシンボ
ルが存在することを正確に認識できます。ある場面においては、普通、これら
のうちの1つの使い方をします。しかし、ある1つのシンボルに対してすべての
使い方をしてもかまいません。

シンボル名には、どんな文字でも含められます。ほとんどのシンボル名は、英
文字、数字、`-+=*/'の句読点文字で書かれます。そのような名前では、特別な
書き方は必要ありません。名前が数に見えなければ、名前を構成する文字はな
んでもよいのです。（名前が数に見えるときには、名前の先頭に`\'を書いてシ
ンボルであると強制する。）`_~!@$%^&:<>{}'の文字はあまり使われませんが、
これらにも特別な書き方は必要ありません。これら以外の文字は、バックスラッ
シュでエスケープすれば、シンボル名に含められます。文字列におけるバック
スラッシュの用法とは対照的に、シンボル名におけるバックスラッシュは、直
後の1文字をクォートするだけです。たとえば、文字列では`\t'はタブ文字を表
しますが、シンボル名では英文字`t'をクォートするだけです。名前にタブ文字
を含むシンボルを書くには、実際に（バックスラッシュの直後に）タブを使う
必要があります。しかし、そのようなことをするのは皆無でしょう。

     Common Lispに関した注意：` ' Common Lispでは、小文字を明示的にエス
     ケープしない限り、小文字をつねに大文字に『変換』する。Emacs Lispで
     は、大文字と小文字を区別する。

シンボル名の例をいくつかあげましょう。5番目の例の`+'は、数として読まれ
るのを防ぐためにエスケープしてあることに注意してください。6番目の例では、
これは必要ありません。なぜなら、名前の残りの部分が数としては不正だから
です。

     foo                 ; `foo'という名前のシンボル
     FOO                 ; `FOO'という名前のシンボル、`foo'とは別
     char-to-string      ; `char-to-string'という名前のシンボル
     1+                  ; `1+'という名前のシンボル
                         ;   （整数の`+1'ではない）
     \+1                 ; `+1'という名前のシンボル
                         ;   （読みにくい名前）
     \(*\ 1\ 2\)         ; `(* 1 2)'という名前のシンボル（悪い名前）
     +-*/_~!@$%^&=:<>{}  ; `+-*/_~!@$%^&=:<>{}'という名前のシンボル
                         ;   これらの文字をエスケープする必要はない



File: elisp-ja, Node: Sequence Type, Next: Cons Cell Type, Prev: Symbol Type, Up: Programming Types

シーケンス型
------------

"シーケンス"（sequence）とは、要素の順序集合を表現するLispオブジェクト
です。Emacs Lispには2種類のシーケンス、つまり、リストと配列があります。
したがって、リスト型や配列型のオブジェクトは、シーケンス型でもあると考
えられます。

配列はさらに、文字列、ベクトル、文字テーブル、ブールベクトルに細分され
ます。ベクトルは任意の型の要素を保持できますが、文字列の要素は文字であ
る必要があり、ブールベクトルの要素は`t'か`nil'のいずれかである必要があ
ります。バッファ内の文字のように、文字列内の文字はテキスト属性を持てま
す（*Note Text Properties::）。ベクトルとブールベクトル (1) (*Note
Sequence Type-Footnotes::) では、それらの要素が文字であったとしても、テ
キスト属性を扱えません。文字テーブルは、ベクトルに似ていますが、正しい
文字コードで添字付けします。

リスト、文字列、および、その他の配列型は別のものですが、
それらには重要な類似性があります。
たとえば、それらすべてに長さLがあり、
それらのすべての要素は0からL-1で添字付けできます。
シーケンス関数と呼ばれるいくつかの関数は、
任意のシーケンス型を扱います。
たとえば、シーケンスから指定した添字の要素を取り出すには、
関数`elt'を使います。
*Note Sequences Arrays Vectors::。

一般には、同一のシーケンスを二度読み取ることは不可能です。というのは、
読むたびにつねに新たにシーケンスを作成するからです。シーケンスの入力構
文を二度読むと、同じ内容の2つのシーケンスを得ることになります。1つ例外
があります。空リスト`()'は、つねに同じオブジェクト`nil'を表します。


File: elisp-ja  Node: Sequence Type-Footnotes, Up: Sequence Type

(1) 【訳注】ベクトルのみの誤り？



File: elisp-ja, Node: Cons Cell Type, Next: Array Type, Prev: Sequence Type, Up: Programming Types

コンスセルとリスト型
--------------------

"コンスセル"（cons cell）とは、
CARスロットおよびCDRスロットと呼ばれる
2つのポインタから成るオブジェクトです。
各スロットは、任意のLispオブジェクトを"指す"ことができます。
また、現在CARスロットが指しているオブジェクトがなんであれ、
『コンスセルのCARは』といったいい方をします。
CDRについても同様です。

"リスト"（list）はコンスセルが連なったものであり、各コンスセルのCDRスロッ
トは、後続のコンスセルを指すか空リストを指します。リストに作用する関数
については、*Note Lists::。ほとんどのコンスセルは、リストの一部分として
使われるので、"リスト構造"（list structure）という用語は、コンスセルか
ら成る任意の構造のことを意味します。

CARやCDRという名称は、Lispの歴史に由来します。
最初のLispはIBM 704で動作していました。
この計算機では、ワードを2つの部分、『番地』（address）部分、
『減数』（decrement）部分と呼ばれるものに分けていました。
CARはレジスタの番地部分の内容（Contents of Address Register）を
取り出す命令であり、
CDRはレジスタの減数部分の内容（Contents of Decrement Register）を
取り出す命令でした。
一方、『コンスセル』という名称は、
これらを作成する関数`cons'からきています。
この関数名は、その目的、セルを作る（construction of cells）からきています。

コンスセルはLispの核心なので、『コンスセルではないオブジェクト』に対す
る名称もあります。これらのオブジェクトを"アトム"（atoms）と呼びます。

リストの入力構文と表示表現は同一です。開き括弧で始まり、任意個の要素、
閉じ括弧で終えます。

読み取り時には、括弧の内側の各オブジェクトが、リストの各要素になります。
つまり、これらの要素からなるコンスセルを作ります。コンスセルのCARスロッ
トで要素を指します。同じコンスセルのCDRスロットで、リスト上のつぎの要素
を保持している、リストのつぎのコンスセルを指します。最後のコンスセルの
CDRスロットは`nil'を指します。

リストは、コンスセルを1対の箱で表して図示できます。（Lispリーダがこのよ
うな図表示を読むことはない。人間や計算機が理解できるテキスト表記と違い、
箱を用いた図表示は人間だけが理解できる。）つぎの図は、3つの要素から成る
リスト`(rose violet buttercup)'を表します。

         -- ---      -- ---      -- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         -- ---      -- ---      -- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup

この図で、各箱は、任意のLispオブジェクトを指すことができるスロットを表
します。箱の対でコンスセルを表します。各矢印は、アトムや他のコンスセル
であるLispオブジェクトを指すポインタです。

この例では、最初のコンスセルのCARを表す最初の箱は、`rose'（シンボル）を
指しています。あるいは、`rose'（シンボル）を『含んでいる』ともいいます。
最初のコンスセルのCDRを表す2番目の箱は、つぎの1対の箱、2番目のコンスセ
ルを指しています。2番目のコンスセルのCARは`violet'であり、このコンスセ
ルのCDRは3番目のコンスセルです。3番目の（最後の）コンスセルのCDRは、
`nil'です。

同じリスト`(rose violet buttercup)'を別の方法で図表示するとつぎのように
なります。

      ---------------       ----------------       -------------------
     | car   | cdr   |     | car    | cdr   |     | car       | cdr   |
     | rose  |   o-------->| violet |   o-------->| buttercup |  nil  |
     |       |       |     |        |       |     |           |       |
      ---------------       ----------------       -------------------

内部に要素を持たないリストは、"空リスト"（empty list）です。これはシン
ボル`nil'と同一です。いいかえれば、`nil'はシンボルでもありリストでもあ
ります。

Lispの構文で書き表したリストの例を示します。

     (A 2 "A")            ; 3要素のリスト
     ()                   ; 要素を持たないリスト（空リスト）
     nil                  ; 要素を持たないリスト（空リスト）
     ("A ()")             ; 文字列`"A ()"'だけの1要素のリスト
     (A ())               ; `A'と空リストから成る2要素のリスト
     (A nil)              ; 上と同じ
     ((A B C))            ; 1要素のリスト
                          ;   （その要素は3要素のリスト）

リスト`(A ())'や、これと同じ`(A nil)'を箱と矢印で書くとつぎのようになり
ます。

         -- ---      -- ---
        |   |   |--> |   |   |--> nil
         -- ---      -- ---
          |            |
          |            |
           --> A        --> nil

* Menu:

* Dotted Pair Notation::        An alternative syntax for lists.
* Association List Type::       A specially constructed list.



File: elisp-ja, Node: Dotted Pair Notation, Prev: Cons Cell Type, Up: Cons Cell Type

ドット対記法
............

"ドット対記法"（dotted pair notation）とは、CARとCDRを明示したコンスセ
ルを表すもう1つの構文です。この構文では、`(A . B)'で、CARがオブジェクト
AでありCDRがオブジェクトBであるコンスセルを表します。したがって、ドット
対記法は、リストの構文よりさらに汎用性があります。ドット対記法では、リ
スト`(1 2 3)'は、`(1 .  (2 . (3 . nil)))'と書けます。`nil'で終るリスト
ならば、どちらの記法でも書き表せますが、リスト記法のほうがわかりやすく
て便利です。リストを表示するときには、コンスセルのCDRがリスト以外の場合
に限ってドット対記法を使います。

ドット対記法を箱で表現してみます。つぎの例は`(rose . violet)'を表したも
のです。

         -- ---
        |   |   |--> violet
         -- ---
          |
          |
           --> rose

最後のCDRが`nil'以外であるようなコンスセルの連鎖を表現するために、リス
ト記法にドット対記法を組み合わせることもできます。リストの最後の要素の
あとにドットを書き、続けて、最後のコンスセルのCDRを書きます。たとえば、
`(rose violet . buttercup)'は、`(rose . (violet . buttercup))'に等価で
す。このオブジェクトはつぎのようになります。

         -- ---      -- ---
        |   |   |--> |   |   |--> buttercup
         -- ---      -- ---
          |            |
          |            |
           --> rose     --> violet

`(rose . violet . buttercup)'という構文は不正です。
これが意味することはなにもありません。
たとえあったとしても、CDRを`violet'用にすでに使っているコンスセルの
CDRに`buttercup'を置けということになります。

リスト`(rose violet)'は、`(rose . (violet))'に等価であり、つぎのように
図示できます。

         -- ---      -- ---
        |   |   |--> |   |   |--> nil
         -- ---      -- ---
          |            |
          |            |
           --> rose     --> violet

同様に、3要素のリスト`(rose violet buttercup)'は、`(rose . (violet .
(buttercup)))'に等価です。つぎのように図示できます。

         -- ---      -- ---      -- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         -- ---      -- ---      -- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup



File: elisp-ja, Node: Association List Type, Prev: Cons Cell Type, Up: Cons Cell Type

連想リスト型
............

"連想リスト"（association list）、すなわち、"alist"は、各要素がコンスセ
ルであるように特別に構成したリストのことです。各要素では、CARを"キー
（key）と考え、CDRを"連想値"（associated value）と考えます。（場合によっ
ては、連想値を、CDRのCARに保持することもある。）連想リストはスタックと
して使われることがままあります。というのは、リストの先頭に対応関係を追
加／削除するのが簡単だからです。

たとえば、

     (setq alist-of-colors
           '((rose . red) (lily . white)  (buttercup . yellow)))

は、変数`alist-of-colors'に、3要素の連想リストを設定します。最初の要素
では、`rose'がキーであり、`red'が値です。

連想リストとそれらを操作する関数について詳しい説明は、
*Note Association Lists::。



File: elisp-ja, Node: Array Type, Next: String Type, Prev: Cons Cell Type, Up: Programming Types

配列型
------

"配列"（array）は、任意のLispオブジェクトを指すための任意個のスロットか
ら成り、メモリの連続した場所に取ります。配列のどの要素を参照しても、ほ
ぼ同じ時間かかります。一方、リストの要素を参照するときには、リスト内の
要素の位置に比例した時間が必要です。（リストの末尾の要素を参照するには、
リストの先頭の要素を参照するより時間がかかる。）

Emacsには、4つの配列型、つまり、文字列、ベクトル、ブールベクトル、文字
テーブルがあります。

文字列は文字の配列であり、ベクトルは任意のオブジェクトの配列です。ブー
ルベクトルは、`t'や`nil'だけを保持できます。これらの種類の配列は、最大
の整数値までなら、任意の長さにできます。文字テーブルは、正しい文字コー
ドで添字付けする疎な配列であり、任意のオブジェクトを保持できます。

配列の最初の要素は0で添字付けする、
2番目の要素は1で添字付けする、というようになります。
これを"ゼロ原点"（zero-origin）の添字付けと呼びます。
たとえば、4つの要素からなる配列の添字は、0、1、2、そして、3です。
最大の添字は、配列の長さより1だけ小さくなります。
いったん配列を作成すると、その長さは固定されます。

Emacs Lispのすべての配列は1次元です。（多くの他のプログラム言語では多次
元配列を扱えるが、それは本質的ではない。配列の配列を作れば同じ効果を得
られる。）配列のそれぞれの型に応じて、専用の入力構文があります。詳しく
は、以下を参照してください。

配列型はシーケンス型に含まれ、配列型は、文字型、ベクトル型、ブールベク
トル型、文字テーブル型を含みます。



File: elisp-ja, Node: String Type, Next: Vector Type, Prev: Array Type, Up: Programming Types

文字列型
--------

"文字列"（string）とは文字の配列です。テキストエディタということから予
想されるように、Emacsではさまざまな目的に文字列を使います。たとえば、
Lispシンボルの名前として、ユーザーへのメッセージとして、バッファから取
り出したテキストを表現するためなどです。Lispの文字列は定数です。つまり、
文字列を評価すると同じ文字列になります。

文字列を操作する関数については、*Note Strings and Characters::。

* Menu:

* Syntax for Strings::
* Non-ASCII in Strings::
* Nonprinting Characters::
* Text Props and Strings::



File: elisp-ja, Node: Syntax for Strings, Next: Non-ASCII in Strings, Prev: String Type, Up: String Type

文字列の構文
............

文字列の入力構文は、`"like this"'のように、ダブルクォートで始めて、任意
個の文字を書き、ダブルクォートで終えます。文字列の中にダブルクォートを
含めるには、バックスラッシュを直前に置きます。つまり、`"\""'は、ダブル
クォート1個だけから成る文字列です。同様に、バックスラッシュを含めるには、
`"this \\ is a single embedded backslash"'のように、バックスラッシュを
直前に置きます。

文字列の入力構文において、改行文字は特別ではありません。
ダブルクォートのあいだに改行を書けば、
改行は文字列の文字になります。
一方、エスケープした改行、つまり、`\'を直前に書くと、
文字列の一部にはなりません。
すなわち、Lispリーダは、文字列を読む際にエスケープした改行を無視します。
エスケープした空白`\ 'も、同様に無視します。

     "It is useful to include newlines
     in documentation strings,
     but the newline is \
     ignored if escaped."
          => "It is useful to include newlines
     in documentation strings,
     but the newline is ignored if escaped."



File: elisp-ja, Node: Non-ASCII in Strings, Next: Nonprinting Characters, Prev: Syntax for Strings, Up: String Type

文字列内の非ASCII文字
.....................

非ASCIIである国際化文字を文字列に含めるには、その文字をそのまま書きます。
Emacsの文字列（および、バッファ）では、非ASCIIの表現方法が2つあります。
ユニバイトとマルチバイトです。マルチバイトバッファやマルチバイト文字列、
あるいは、マルチバイトとして訪問しているファイルなどのマルチバイトのソー
スから文字列定数を読み取るときには、文字をマルチバイト文字として読み取
り、マルチバイト文字列にします。ユニバイトのソースから文字列定数を読み
取るときには、文字をユニバイト文字として読み取り、文字列はユニバイトに
なります。

マルチバイトの非ASCII文字は、
必要な桁数の16進エスケープ`\xNNNNNNN'を用いて
書くこともできます。
（マルチバイトの非ASCII文字のコードは、256より大きい。）
16進数字として正しくない文字で16進エスケープを終端します。
16進数字の文字があとに続く場合には、`\ '（バックスラッシュと空白）と
書いて16進エスケープを終端します。
たとえば、`\x8e0\ 'は、グレーブアクセント付きの`a'を表します。
文字列定数内の`\ 'は、バックスラッシュ＋改行と同じです。
文字列内の文字には含まれませんが、先行する16進エスケープを終えます。

マルチバイトの16進エスケープを使うと、文字列はマルチバイトになります。
ユニバイトの非ASCIIを文字コードで表現することもできますが、文字コードは
128（8進0200）から255（8進0377）の範囲である必要があります。こうすると、
文字列はユニバイトになります。

2種類のテキストの表現方法について詳しくは、*Note Text
Representations::。



File: elisp-ja, Node: Nonprinting Characters, Next: Text Props and Strings, Prev: Non-ASCII in Strings, Up: String Type

文字列内の非印字文字
....................

文字定数と同じバックスラッシュのエスケープシーケンスを文字列定数でも使
えます（ただし、文字定数を開始する疑問符は書かない）。たとえば、コンマ
と空白で区切った非印字文字のタブと`C-a'を含む文字列を書くには、`"\t,
C-a"'のようにします。文字の入力構文については、*Note Character Type::。

しかしながら、バックスラッシュのエスケープシーケンスすべてが、文字列に
おいて正しいとは限りません。文字列に含めることが可能なコントロール文字
は、ASCIIコントロール文字に限ります。文字列では、ASCIIコントロール文字
の大文字小文字を区別しません。

正確にいえば、文字列はメタ文字を保持できません。しかし、文字列をキー列
として使う場合には、文字列内のASCII文字のメタ変種を表現するための特別な
慣習があります。文字列定数内でメタ文字を表すために`\M-'の構文を使うと、
文字列内のその文字に2**7
のビットを設定します。
`define-key'や`lookup-key'に文字列を使うと、
このコードは、等価なメタ文字に変換されます。
*Note Character Type::。

文字列では、ハイパー、スーパー、アルトの修飾子を保持できません。



File: elisp-ja, Node: Text Props and Strings, Prev: Nonprinting Characters, Up: String Type

文字列内のテキスト属性
......................

文字列は、文字そのものに加えて、文字の属性も保持できます。このため、特
別なことをしなくても、文字列とバッファのあいだでテキストをコピーするプ
ログラムは、テキスト属性をコピーできます。テキスト属性の意味については、
*Note Text Properties::。テキスト属性付きの文字列には、特別な入力構文が
あります。

     #("CHARACTERS" PROPERTY-DATA...)

ここで、PROPERTY-DATAは0個以上のつぎのような3つ組みです。

     BEG END PLIST

3つ組みの要素、BEGとENDは整数であり、文字列内の添字の範囲を表します。
PLISTはその範囲の属性リストです。たとえば、

     #("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))

は、最初の3文字が`face'属性として`bold'を持ち、最後の3文字が`face'属性
として`italic'を持つ、`foo bar'という文字列を表します。（4番目の文字に
はテキスト属性はなく、その属性リストは`nil'。デフォルトでは、範囲に含ま
れない文字には属性はないので、属性リストが`nil'であるような範囲を言及す
る必要はない。）



File: elisp-ja, Node: Vector Type, Next: Char-Table Type, Prev: String Type, Up: Programming Types

ベクトル型
----------

"ベクトル"（vector）は、任意の型の要素から成る1次元配列です。ベクトルの
任意の要素を参照しても、それに必要な時間は一定です。（リストでは、ある
要素を参照するために必要な時間は、リストの先頭からの距離に比例する。）

ベクトルの表示表現は、開き角括弧、要素、閉じ角括弧です。これは、入力構
文でもあります。数や文字列と同様に、ベクトルは評価時には定数です。

     [1 "two" (three)]      ; 3要素のベクトル
          => [1 "two" (three)]

ベクトルに作用する関数については、*Note Vectors::。



File: elisp-ja, Node: Char-Table Type, Next: Bool-Vector Type, Prev: Vector Type, Up: Programming Types

文字テーブル型
--------------

"文字テーブル"（char-table）は、任意の型の要素から成る1次元配列であり、
文字コードで添字付けします。文字テーブルには、文字コードに情報を与える
ための多くの操作を簡単にする付加的な機能があります。たとえば、文字テー
ブルは、情報を継承するための親、デフォルト値、特定目的向けの少数の追加
スロットを持てます。文字テーブルでは、文字集合全体に対して1つの値を指定
することもできます。

文字テーブルの表示表現はベクトルに似ていますが、先頭に`#^'が余分に付き
ます。

文字テーブルを操作する特別の関数については、*Note Char-Tables::。文字テー
ブルはつぎのように使います。

   * 大文字小文字テーブル（*Note Case Tables::）。

   * 文字カテゴリテーブル（*Note Categories::）。

   * 表示テーブル（*Note Display Tables::）。

   * 構文テーブル（*Note Syntax Tables::）。



File: elisp-ja, Node: Bool-Vector Type, Next: Function Type, Prev: Char-Table Type, Up: Programming Types

ブールベクトル型
----------------

"ブールベクトル"（bool-vector）は、
`t'か`nil'だけの要素から成る1次元配列です。

ブールベクトルの表示表現は文字列に似ていますが、`#&'と長さで始まります。
これに続く文字列定数が、ブールベクトルの実際の内容をビットマップで表し
ます。つまり、文字列の『各文字』は8ビット長のデータであり、ブールベクト
ルのつぎの8個の要素を表します（1は`t'を表し、0は`nil'を表す）。文字の最
下位ビットが、ブールベクトルの小さい添字に対応します。長さが8の倍数でな
い場合には、表示表現には余計な要素が含まれますが、余計な部分に意味はあ
りません。

     (make-bool-vector 3 t)
          => #&3"\007"
     (make-bool-vector 3 nil)
          => #&3"\0"
     ;; 最初の3ビットだけを使っているので、以下はすべて同じ
     (equal #&3"\377" #&3"\007")
          => t



File: elisp-ja, Node: Function Type, Next: Macro Type, Prev: Bool-Vector Type, Up: Programming Types

関数型
------

他のプログラム言語の関数が実行可能であるように、"Lisp関数"（Lisp
function）は実行可能なコードです。しかしながら、Lispにおいては、関数は
基本Lispオブジェクトであり、そのテキスト表現は副次的なものです。これら
のLispオブジェクトはラムダ式です。つまり、先頭要素がシンボル`lambda'で
あるリストです（*Note Lambda Expressions::）。

ほとんどのプログラム言語では、名前のない関数を書くことは不可能です。
Lispでは、本質的には、関数に名前はありません。ラムダ式のことを"無名関数
（anonymous function）とも呼びます（*Note Anonymous Functions::）。
Lispにおける名前付き関数は、実際には、関数セルに正しい関数を収めたシン
ボルです（*Note Defining Functions::）。

多くの場合、LispプログラムのLisp式中に関数名を書くと関数が呼ばれます。
しかし、実行時に関数オブジェクトを構成したり取得して、
基本関数`funcall'や`apply'で、それを呼び出すことができます。
*Note Calling Functions::。



File: elisp-ja, Node: Macro Type, Next: Primitive Function Type, Prev: Function Type, Up: Programming Types

マクロ型
--------

"Lispマクロ"（Lisp macro）は、Lisp言語を拡張するユーザー定義の構造です。
関数に似たオブジェクトで表現しますが、引数渡しの意味は異なります。Lisp
マクロは、リストの最初の要素がシンボル`macro'であり、リストのCDRが
`lambda'シンボルを含むLisp関数オブジェクトであるフォームです。

Lispマクロオブジェクトは、通常、組み込み関数`defmacro'で定義しますが、
Emacsにとっては、`macro'で始まるリストはマクロです。マクロの書き方の説
明は、*Note Macros::。

*警告*：` 'Lispマクロとキーボードマクロ（*Note Keyboard Macros::）は、
まったく別のものです。単に『マクロ』といった場合には、Lispマクロを意味
するのであって、キーボードマクロのことではありません。



File: elisp-ja, Node: Primitive Function Type, Next: Byte-Code Type, Prev: Macro Type, Up: Programming Types

基本関数型
----------

"基本関数型"（primitive function）は、Lispから呼び出し可能な関数ですが、
C言語で書いてあります。基本関数のことを"subr"とか"組み込み関数
（built-in functions）とも呼びます。（『subr』は『subroutine』からきて
いる。）ほとんどの基本関数は、呼び出すときにすべての引数を評価します。
引数すべてを評価しない基本関数を"スペシャルフォーム"（special form）と
呼びます（*Note Special Forms::）。

関数を呼び出す側からすれば、関数が基本関数かどうかは関係ありません。し
かし、Lispで書いた関数で基本関数を再定義しようとすると、問題があります。
というのは、基本関数はCのコードから直接呼ばれるからです。再定義した関数
をLispから呼び出す場合には新しい定義を使いますが、Cのコードは組み込みの
定義を使い続けるでしょう。したがって、*基本関数を再定義しないでください
*。

"関数"（function）という用語で、LispやCで書かれたEmacsのすべての関数を
指します。Lispで書いた関数に関しては、*Note Function Type::。

基本関数には入力構文はなく、サブルーティン名を含むハッシュ記法で表示し
ます。

     (symbol-function 'car)          ; シンボルの関数セルを参照する
          => #<subr car>
     (subrp (symbol-function 'car))  ; 基本関数か？
          => t                       ; そのとおり



File: elisp-ja, Node: Byte-Code Type, Next: Autoload Type, Prev: Primitive Function Type, Up: Programming Types

バイトコード関数型
------------------

バイトコンパイラは、"バイトコード関数オブジェクト" （byte-code
function objects）を作り出します。内部的には、バイトコード関数オブジェ
クトはベクトルによく似ています。しかしながら、評価過程においては、関数
呼び出しのように見えるときには、このデータ型を特別に扱います。バイトコ
ンパイラについては、*Note Byte Compilation::。

バイトコード関数オブジェクトの表示表現と入力構文は、ベクトルに似ていま
すが、開き角括弧`['のまえに`#'が付きます。



File: elisp-ja, Node: Autoload Type, Prev: Byte-Code Type, Up: Programming Types

自動ロード型
------------

"自動ロードオブジェクト"（autoload object）は、先頭要素がシンボル
`autoload'であるリストです。実際の定義のかわりにシンボルの関数定義とし
て使われ、必要なときにロードすべき実際の定義を収めたLispコードファイル
を示します。自動ロードオブジェクトには、ファイル名に加えて、実際の関数
定義に関する他の情報も入っています。

ファイルをロードし終えると、シンボルには、自動ロードオブジェクトではな
い新たな関数定義が入ります。この新たな定義を始めからあったかのように呼
び出します。ユーザーの視点からは、ロードしたファイル内の関数定義を使っ
て、予想どおりに関数呼び出しが行われます。

自動ロードオブジェクトは、普通、関数`autoload'で作ります。この関数は、
シンボルの関数セルにオブジェクトを格納します。より詳しくは、*Note
Autoload::。



File: elisp-ja, Node: Editing Types, Next: Type Predicates, Prev: Programming Types, Up: Lisp Data Types

編集向けの型
============

前節の型は一般のプログラム向けに使うもので、そのほとんどは、ほんどの
Lisp方言に共通しています。Emacs Lispには、編集に関連した目的向けにいく
つかのデータ型があります。

* Menu:

* Buffer Type::         The basic object of editing.
* Marker Type::         A position in a buffer.
* Window Type::         Buffers are displayed in windows.
* Frame Type::		Windows subdivide frames.
* Window Configuration Type::   Recording the way a frame is subdivided.
* Frame Configuration Type::    Recording the status of all frames.
* Process Type::        A process running on the underlying OS.
* Stream Type::         Receive or send characters.
* Keymap Type::         What function a keystroke invokes.
* Overlay Type::        How an overlay is represented.



File: elisp-ja, Node: Buffer Type, Next: Marker Type, Prev: Editing Types, Up: Editing Types

バッファ型
----------

"バッファ"（buffer）は、編集可能なテキストを保持するオブジェクトです
（*Note Buffers::）。ほとんどのバッファは、ディスクファイル（*Note
Files::）の内容を保持して編集できるようにしますが、他の目的に使われるも
のもあります。ほとんどのバッファは、ユーザーが見るためのものであり、あ
る期間、ウィンドウ（*Note Windows::）に表示されます。しかし、バッファが
いずれかのウィンドウに必ずしも表示される必要はありません。

バッファの内容は文字列によく似ていますが、Emacs Lispにおいては、バッファ
は文字列のようには使われず、適用可能な操作も異なります。たとえば、既存
のバッファにテキストを効率よく挿入できますが、文字列にテキストを『挿入』
するには、部分文字列を連結する必要があり、まったく新しい文字列オブジェ
クトになります。

各バッファには、"ポイント"（point）と呼ばれる特別な箇所があります
（*Note Positions::）。どんなときにも、1つのバッファが"カレントバッファ
（current buffer）です。ほとんどの編集コマンドは、カレントバッファのポ
イント付近の内容に作用します。多くのEmacsの標準関数は、カレントバッファ
内にある文字を操作したり検査します。本書には、これらの関数の説明にあて
た章が1つあります（*Note Text::）。

各バッファに関連付けられたデータ構造には、つぎのものがあります。

   * ローカル構文テーブル（*Note Syntax Tables::）

   * ローカルキーマップ（*Note Keymaps::）。および

   * バッファにローカルな変数束縛リスト（*Note Buffer-Local
     Variables::）。

   * オーバレイ（*Note Overlays::）。

   * バッファ内のテキストのテキスト属性（*Note Text Properties::）。

ローカルキーマップと変数リストには、それぞれ、グローバルな束縛や値に優
先するものが入っています。これらは、プログラムを変更せずに、各バッファ
ごとに、プログラムのふるまいをカスタマイズするために使われます。

バッファは"間接"（indirect）でもよく、その場合、
別のバッファとテキストを共有しつつ異なった表示を行えます。
*Note Indirect Buffers::。

バッファには入力構文はありません。バッファ名を含んだハッシュ記法で表示
します。

     (current-buffer)
          => #<buffer objects.texi>



File: elisp-ja, Node: Marker Type, Next: Window Type, Prev: Buffer Type, Up: Editing Types

マーカ型
--------

"マーカ"（marker）は、特定のバッファ内の位置を表します。したがって、マー
カには2つの構成要素、つまり、バッファを示すものと位置を示すものがありま
す。バッファ内のテキストを変更すると、マーカがバッファ内の同じ2つの文字
のあいだをつねに指すことを保証するように、位置の値を更新します。

マーカには入力構文はありません。バッファ内の文字位置とバッファ名を含ん
だハッシュ記法で表示します。

     (point-marker)
          => #<marker at 10779 in objects.texi>

マーカの検査、作成、コピー、移動の方法については、*Note Markers::。



File: elisp-ja, Node: Window Type, Next: Frame Type, Prev: Marker Type, Up: Editing Types

ウィンドウ型
------------

"ウィンドウ"（window）は、Emacsがバッファを表示するために使用する端末画
面の部分のことです。各ウィンドウには、対応付けられたバッファが1つあり、
そのバッファの内容をウィンドウに表示しています。一方、あるバッファが、
1つのウィンドウや複数のウィンドウに表示されることもあり、どのウィンドウ
にも表示されないこともあります。

同時に複数のウィンドウが存在できますが、どんなときにも1つのウィンドウだ
けが"選択されたウィンドウ" （selected window）です。これは、Emacsがコマ
ンドを受け付け可能なときにカーソルを（通常）表示するウィンドウです。選
択されたウィンドウは、通常、カレントバッファを表示しますが、これは必須
ではありません。

画面上のウィンドウはフレームにまとめられています。
各ウィンドウは、たった1つのフレームに属します。
*Note Frame Type::。

ウィンドウには入力構文はありません。ウィンドウ番号と表示中のバッファ名
を含んだハッシュ記法で表示します。ウィンドウ番号は、ウィンドウを一意に
識別するためにあります。これは、ウィンドウが表示しているバッファは頻繁
に変わるからです。

     (selected-window)
          => #<window 1 on objects.texi>

ウィンドウを操作する関数の説明は、*Note Windows::。



File: elisp-ja, Node: Frame Type, Next: Window Configuration Type, Prev: Window Type, Up: Editing Types

フレーム型
----------

"フレーム"（frame）は、画面上の矩形領域であって、1つ以上のEmacsウィンド
ウを含みます。フレームには最初は1つのウィンドウ（とミニバッファウィンド
ウ）が含まれますが、これを左右や上下に小さなウィンドウに分割できます。

フレームには入力構文はありません。フレームのタイトルとメモリ内のアドレ
ス（フレームを一意に識別するのに有用）を含んだハッシュ記法で表示します。

     (selected-frame)
          => #<frame emacs@psilocin.gnu.org 0xdac80>

フレームを操作する関数の説明は、*Note Frames::。



File: elisp-ja, Node: Window Configuration Type, Next: Frame Configuration Type, Prev: Frame Type, Up: Editing Types

ウィンドウ構成型
----------------

"ウィンドウ構成"（window configuration）は、フレーム内のウィンドウの位
置／サイズ／内容に関する情報を記録し、同じ配置のウィンドウをあとで再度
作成できるようにします。

ウィンドウ構成には入力構文はありません。表示表現は、
`#<window-configuration>'のようになります。ウィンドウ構成に関連した関数
の説明は、*Note Window Configurations::。



File: elisp-ja, Node: Frame Configuration Type, Next: Process Type, Prev: Window Configuration Type, Up: Editing Types

フレーム構成型
--------------

"フレーム構成"（frame configuration）は、すべてのフレームのウィンドウの
位置／サイズ／内容に関する情報の記録です。これは、実際には、リストの
CARが`frame-configuration'であり、リストのCDRが連想リストであるリストで
す。連想リストの各要素で、そのCARに現れるフレーム1個を記述します。

フレーム構成に関連した関数の説明は、*Note Frame Configurations::。



File: elisp-ja, Node: Process Type, Next: Stream Type, Prev: Frame Configuration Type, Up: Editing Types

プロセス型
----------

単語"プロセス"（process）は、通常、実行中のプログラムを意味します。
Emacs自身、この種のプロセスとして実行されています。しかし、Emacs Lispで
は、プロセスとは、Emacsプロセスが作成したサブプロセスを表すLispオブジェ
クトのことです。Emacsのサブプロセスで実行される、シェル、GDB、ftp、コン
パイラなどのプログラムは、Emacsの能力を拡張します。

Emacsサブプロセスは、Emacsからテキスト入力を受け取り、さらに処理できる
ようにEmacsにテキスト出力を返します。Emacsはサブプロセスにシグナルを送
ることもできます。

プロセスオブジェクトに入力構文はありません。プロセス名を含んだハッシュ
記法で表示します。

     (process-list)
          => (#<process shell>)

プロセスを作成したり削除したり、プロセスに関する情報を返したり、プロセ
スへ入力やシグナルを送ったり、プロセスから出力を受け取る関数に関する情
報は、*Note Processes::。



File: elisp-ja, Node: Stream Type, Next: Keymap Type, Prev: Process Type, Up: Editing Types

ストリーム型
------------

"ストリーム"（stream）は、文字を出し入れする対象、つまり、入力用に文字
を供給したり、出力として文字を受け取ったりといったことに使えるオブジェ
クトです。多くの異なる型をこのように使えます。マーカ、バッファ、文字列、
関数です。ほとんどの場合、入力ストリーム（文字の供給源）は、キーボード、
バッファ、ファイルから文字を取得します。出力ストリーム（文字の消費先）
は、`*Help*'バッファなどのバッファやエコー領域に文字を送ります。

オブジェクト`nil'は、他の意味に加えて、ストリームとしても使えます。変数
`standard-input'や`standard-output'の値になります。また、オブジェクト
`t'も、ミニバッファ（*Note Minibuffers::）を使う入力ストリームやエコー
領域への出力（*Note The Echo Area::）を意味します。

ストリームには表示形式も入力構文もなく、その基本型で表示します。

構文解析関数や表示関数を含むストリームに関連した関数の説明は、
*Note Read and Print::。



File: elisp-ja, Node: Keymap Type, Next: Overlay Type, Prev: Stream Type, Up: Editing Types

キーマップ型
------------

"キーマップ"（keymap）は、ユーザーが打ったキーをコマンドに対応付けます。
この対応付けは、ユーザーのコマンド入力をどのように実行するかを制御しま
す。キーマップは、実際には、リストであり、そのCARはシンボル`keymap'です。

キーマップの作成、プレフィックスキーの扱い方、
グローバルやローカルなキーマップ、キーバインディングの変更に関する情報は、
*Note Keymaps::。



File: elisp-ja, Node: Overlay Type, Prev: Keymap Type, Up: Editing Types

オーバレイ型
------------

"オーバレイ"（overlay）は、バッファのある部分に作用する属性を指定します。
各オーバレイは、バッファの指定した範囲に作用し、属性リスト（属性名と値
の要素を交互に繰り返すリスト）を含んでいます。オーバレイ属性は、バッファ
の一部を一時的に異なった方式で表示するために使われます。オーバレイ属性
に入力構文はなく、バッファ名と位置範囲を含んだハッシュ記法で表示します。

オーバレイの作成と使用法については、*Note Overlays::。



File: elisp-ja, Node: Type Predicates, Next: Equality Predicates, Prev: Editing Types, Up: Lisp Data Types

型述語
======

Emacs Lispインタープリタ自身は、関数を呼び出すときに渡す実引数の型検査
を行いません。そうできないのは、他のプログラム言語が行うようには、Lisp
の関数の引数にはデータ型の宣言がないからです。したがって、各実引数がそ
の関数で扱える型に属するかどうかを検査するのは、各関数の責任です。

すべての組み込み関数は、必要なときには実引数の型検査を行い、引数が誤っ
た型であれば、エラー`wrong-type-argument'を通知します。たとえば、`+'に
扱えない引数を渡すと、つぎのようになります。

     (+ 2 'a)
          error--> Wrong type argument: number-or-marker-p, a

読者のプログラムで、異なる型を異なるように扱いたい場合には、明示的に型
検査を行う必要があります。オブジェクトの型を検査するもっとも一般的な方
法は、"型述語"（type predicate）関数を呼び出すことです。Emacsには、各型
ごとに型述語があり、型を組み合わせたものに対する述語もあります。

型述語関数は1つの引数を取ります。引数が適切な型に属していれば`t'を返し、
さもなければ`nil'を返します。述語関数に関するLisp一般の慣習に従って、ほ
とんどの型述語の名前は`p'で終ります。

以下は、リストの検査に述語`listp'を使い、シンボルの検査に述語`symbolp'
を使う例です。

     (defun add-on (x)
       (cond ((symbolp x)
              ;; Xがシンボルならば、それをLISTに加える
              (setq list (cons x list)))
             ((listp x)
              ;; Xがリストならば、その要素をLISTに追加する
              (setq list (append x list)))
             (t
              ;; シンボルとリストだけを扱う
              (error "Invalid argument %s in add-on" x))))

定義済みの型述語を、アルファベット順に、参照先を併記してあげておきます。

`atom'
     *Note atom: List-related Predicates.。

`arrayp'
     *Note arrayp: Array Functions.。

`bool-vector-p'
     *Note bool-vector-p: Bool-Vectors.。

`bufferp'
     *Note bufferp: Buffer Basics.。

`byte-code-function-p'
     *Note byte-code-function-p: Byte-Code Type.。

`case-table-p'
     *Note case-table-p: Case Tables.。

`char-or-string-p'
     *Note char-or-string-p: Predicates for Strings.。

`char-table-p'
     *Note char-table-p: Char-Tables.。

`commandp'
     *Note commandp: Interactive Call.。

`consp'
     *Note consp: List-related Predicates.。

`display-table-p'
     *Note display-table-p: Display Tables.。

`floatp'
     *Note floatp: Predicates on Numbers.。

`frame-configuration-p'
     *Note frame-configuration-p: Frame Configurations.。

`frame-live-p'
     *Note frame-live-p: Deleting Frames.。

`framep'
     *Note framep: Frames.。

`functionp'
     *Note functionp: Functions.。

`integer-or-marker-p'
     *Note integer-or-marker-p: Predicates on Markers.。

`integerp'
     *Note integerp: Predicates on Numbers.。

`keymapp'
     *Note keymapp: Creating Keymaps.。

`listp'
     *Note listp: List-related Predicates.。

`markerp'
     *Note markerp: Predicates on Markers.。

`wholenump'
     *Note wholenump: Predicates on Numbers.。

`nlistp'
     *Note nlistp: List-related Predicates.。

`numberp'
     *Note numberp: Predicates on Numbers.。

`number-or-marker-p'
     *Note number-or-marker-p: Predicates on Markers.。

`overlayp'
     *Note overlayp: Overlays.。

`processp'
     *Note processp: Processes.。

`sequencep'
     *Note sequencep: Sequence Functions.。

`stringp'
     *Note stringp: Predicates for Strings.。

`subrp'
     *Note subrp: Function Cells.。

`symbolp'
     *Note symbolp: Symbols.。

`syntax-table-p'
     *Note syntax-table-p: Syntax Tables.。

`user-variable-p'
     *Note user-variable-p: Defining Variables.。

`vectorp'
     *Note vectorp: Vectors.。

`window-configuration-p'
     *Note window-configuration-p: Window Configurations.。

`window-live-p'
     *Note window-live-p: Deleting Windows.。

`windowp'
     *Note windowp: Basic Windows.。

オブジェクトの型を調べるもっとも一般的な方法は、関数`type-of'を呼び出す
ことです。各オブジェクトはたった1つの基本型に属することを思い出してくだ
さい。`type-of'はどの1つかを教えてくれます（*Note Lisp Data Types::）。
しかし、`type-of'は、基本型以外についてはなにも知りません。多くの場合、
`type-of'より型述語を使うほうが便利でしょう。

 -- Function: type-of OBJECT
     この関数は、OBJECTの基本型を示すシンボルを返す。その値は、
     `symbol'、`integer'、`float'、`string'、`cons'、`vector'、
     `char-table'、`bool-vector'、`subr'、`compiled-function'、
     `marker'、`overlay'、`window'、`buffer'、`frame'、`process'、
     `window-configuration'のシンボルのうちの1つ。

          (type-of 1)
               => integer
          (type-of 'nil)
               => symbol
          (type-of '())    ; `()'は`nil'
               => symbol
          (type-of '(x))
               => cons



File: elisp-ja, Node: Equality Predicates, Prev: Type Predicates, Up: Lisp Data Types

同値述語
========

2つのオブジェクトの同値関係を調べる2つの関数を説明します。文字列などの
特定のオブジェクトが同値であるかを調べる関数群もあります。これらの述語
については、データ型を述べている適切な章を参照してください。

 -- Function: eq OBJECT1 OBJECT2
     この関数は、OBJECT1とOBJECT2が同一オブジェクトであれば`t'を返し、
     さもなければ`nil'を返す。『同一オブジェクト』とは、一方を変更する
     と、他方にも同じ変更が反映されることを意味する。

     `eq'は、OBJECT1とOBJECT2が同じ値の整数であると`t'を返す。また、シ
     ンボル名は、普通、一意であるので、引数が同じ名前のシンボルであれば、
     それらは`eq'である。（リスト、ベクトル、文字列などの）それ以外の型
     の場合、2つの引数が同じ内容や要素であっても、互いに`eq'であるとは
     限らない。それらが同一オブジェクトである場合に限り`eq'である。

          (eq 'foo 'foo)
               => t

          (eq 456 456)
               => t

          (eq "asdf" "asdf")
               => nil

          (eq '(1 (2 (3))) '(1 (2 (3))))
               => nil

          (setq foo '(1 (2 (3))))
               => (1 (2 (3)))
          (eq foo foo)
               => t
          (eq foo '(1 (2 (3))))
               => nil

          (eq [(1 2) 3] [(1 2) 3])
               => nil

          (eq (point-marker) (point-marker))
               => nil

     関数`make-symbol'は、インターンしたシンボルを返す。
     このシンボルは、Lisp式に書いた同じ名前のシンボルと区別される。
     名前が同じでも区別されるシンボルは`eq'ではない。
     *Note Creating Symbols::。

          (eq (make-symbol "foo") 'foo)
               => nil

 -- Function: equal OBJECT1 OBJECT2
     この関数は、 OBJECT1とOBJECT2が等しい要素を持てば`t'を返し、さもな
     ければ`nil'を返す。`eq'は引数が同一オブジェクトかどうかを調べるが、
     `equal'は、同一ではない引数の内部を調べ、それらの要素が同じかどう
     かを調べる。したがって、2つのオブジェクトが`eq'ならば、それらは
     `equal'であるが、その逆はつねに真とは限らない。

          (equal 'foo 'foo)
               => t

          (equal 456 456)
               => t

          (equal "asdf" "asdf")
               => t
          (eq "asdf" "asdf")
               => nil

          (equal '(1 (2 (3))) '(1 (2 (3))))
               => t
          (eq '(1 (2 (3))) '(1 (2 (3))))
               => nil

          (equal [(1 2) 3] [(1 2) 3])
               => t
          (eq [(1 2) 3] [(1 2) 3])
               => nil

          (equal (point-marker) (point-marker))
               => t

          (eq (point-marker) (point-marker))
               => nil

     文字列の比較では大文字小文字を区別するが、テキスト属性は考慮しない。
     つまり、文字列内の文字だけを比較する。文字列の内容がすべてASCIIで
     なければ、ユニバイト文字列とマルチバイト文字列が等しいことはない
     （*Note Text Representations::）。

          (equal "asdf" "ASDF")
               => nil

     たとえ内容が同じであっても、異なる2つのバッファが`equal'であること
     はない。

`equal'の検査は再帰で実装されているので、リストに循環があると無限再帰を
引き起こし（エラーになり）ます。


