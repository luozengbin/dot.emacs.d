Info file: elisp-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp-ja.texi'
using `texinfmt.el' version 2.41 of  1 Mar 2005.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Elisp-ja: (elisp-ja).	　　　　　　Emacs-Lisp 2.9日本語マニュアル.
END-INFO-DIR-ENTRY




Emacs Lispリファレンスマニュアル2.9版であり、Emacs 21.3版に対応します。

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
              2000, 2002 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.  A copy of the license is included in the section
entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have freedom to copy and modify
this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."




File: elisp-ja, Node: Indent Tabs, Next: Motion by Indent, Prev: Relative Indent, Up: Indentation

調整可能な『タブストップ』
--------------------------

本節では、ユーザー指定の『タブストップ』の機構と、それを使ったり設定す
るための機構について説明します。『タブストップ』という名前を使うのは、
この機構がタイプライタのタブストップに似た機能だからです。この機能は、
適切な個数の空白とタブ文字を挿入してつぎのタブストップのコラムへ到達し
ますが、バッファ内のタブ文字の表示に影響することはありません（*Note
Usual Display::）。テキスト（text）モードなどの少数のメジャーモードでの
み、入力としての文字TABがこのタブストップ機能を使います。

 -- コマンド: tab-to-tab-stop
     このコマンドは、`tab-stop-list'で定義されたつぎのタブストップコラ
     ムまで、ポイントのまえに空白やタブを挿入する。このリストで現在のコ
     ラム番号より大きな要素を探し、その要素を字下げ位置のコラムとして使
     う。そのような要素がなければ、このコマンドはないもしない。

 -- User Option: tab-stop-list
     この変数は、`tab-to-tab-stops'が使うタブストップコラムのリストであ
     る。それらの要素は、昇順の整数であること。タブストップコラムの間隔
     は、等間隔である必要はない。

     タブストップを対話的に編集するには`M-x edit-tab-stops'を使う。



File: elisp-ja, Node: Motion by Indent, Prev: Relative Indent, Up: Indentation

字下げに基づく移動コマンド
--------------------------

これらのコマンドは、主に対話的に使うもので、テキストの字下げに基づいて
動作します。

 -- コマンド: back-to-indentation
     このコマンドは、現在行（ポイントが位置する行）の
     白文字でない最初の文字へポイントを移動する。
     `nil'を返す。

 -- コマンド: backward-to-indentation ARG
     このコマンドは、ARG行だけポイントを後方へ移動してから、
     当該行の白文字でない最初の文字へポイントを移動する。
     `nil'を返す。

 -- コマンド: forward-to-indentation ARG
     このコマンドは、ARG行だけポイントを前方へ移動してから、
     当該行の白文字でない最初の文字へポイントを移動する。
     `nil'を返す。



File: elisp-ja, Node: Case Changes, Next: Text Properties, Prev: Indentation, Up: Text

大文字小文字の変更
==================

ここに述べる大文字小文字の変更コマンドは、カレントバッファのテキストに
作用します。文字列や文字の大文字小文字を変換する関数については、*Note
Case Conversion::。どの文字が大文字でどの文字が小文字であり、それらをど
のように変換するかをカスタマイズする方法については、*Note Case
Tables::。

 -- コマンド: capitalize-region START END
     この関数は、STARTとENDで定義される領域内のすべての単語をキャピタラ
     イズ（大文字で始まるように）する。つまり、各単語の最初の文字を大文
     字に、残りの文字を小文字に変換する。この関数は`nil'を返す。

     領域の端が単語の途中にあると、その単語の領域内の部分を1つの単語と
     みなす。

     `capitalize-region'を対話的に呼び出すと、
     STARTとENDはポイントとマークであり、小さいほうがさきにくる。

          ---------- Buffer: foo ----------
          This is the contents of the 5th foo.
          ---------- Buffer: foo ----------

          (capitalize-region 1 44)
          => nil

          ---------- Buffer: foo ----------
          This Is The Contents Of The 5th Foo.
          ---------- Buffer: foo ----------

 -- コマンド: downcase-region START END
     この関数は、STARTとENDで定義される領域内のすべての文字を小文字に変
     換する。この関数は`nil'を返す。

     `downcase-region'を対話的に呼び出すと、
     STARTとENDはポイントとマークであり、小さいほうが先にくる。

 -- コマンド: upcase-region START END
     この関数は、STARTとENDで定義される領域内のすべての文字を大文字に変
     換する。この関数は`nil'を返す。

     `upcase-region'を対話的に呼び出すと、
     STARTとENDはポイントとマークであり、小さいほうが先にくる。

 -- コマンド: capitalize-word COUNT
     この関数は、ポイントのうしろのCOUNT個の単語をキャピタライズ（大文
     字で始まるように）し、ポイントをそれらの末尾に移動する。つまり、各
     単語の最初の文字を大文字に、残りの文字を小文字に変換する。COUNTが
     負であると、まえの-COUNT個の単語を大文字で始まるようにするが、ポイ
     ントは移動しない。値は`nil'である。

     ポイントが単語の途中にあると、単語を前方へ移動するときにはポイント
     よりまえにある単語の部分を無視する。単語の残りの部分を1つの単語と
     して扱う。

     `capitalize-word'を対話的に呼び出すと、
     COUNTは数値前置引数である。

 -- コマンド: downcase-word COUNT
     この関数は、ポイントのうしろのCOUNT個の単語をすべて小文字に替え、
     ポイントをそれらの末尾に移動する。COUNTが負であると、まえの-COUNT
     個の単語を変換するが、ポイントは移動しない。値は`nil'である。

     `downcase-word'を対話的に呼び出すと、
     COUNTは数値前置引数である。

 -- コマンド: upcase-word COUNT
     この関数は、ポイントのうしろのCOUNT個の単語をすべて大文字に替え、
     ポイントをそれらの末尾に移動する。COUNTが負であると、まえの-COUNT
     個の単語を変換するが、ポイントは移動しない。値は`nil'である。

     `upcase-word'を対話的に呼び出すと、
     COUNTは数値前置引数である。



File: elisp-ja, Node: Text Properties, Next: Substitution, Prev: Indentation, Up: Text

テキスト属性
============

シンボルの属性リスト（*Note Property Lists::）のように、バッファや文字
列の各文字には"テキスト属性リスト" （text property list）を持てます。こ
の属性は、（本節の原文のタイトルの）文字`T'や`foo'の最初の`o'のような特
定の箇所の特定の文字に属します。同じ文字が異なる箇所に現れるとき、一般
にはそれぞれに異なる属性を持てます。

各属性には、名前と値があります。どちらも任意のLispオブジェクトでかまい
ませんが、名前は普通はシンボルです。属性リストを参照する普通の方法では、
名前を指定してそれに対応する値を問い合わせます。

文字に属性`category'があるとき、それを文字の"カテゴリ"（category）とい
います。それはシンボルであるべきです。そのシンボルの属性が、文字の属性
のデフォルトとして働きます。

文字列とバッファのあいだでテキストをコピーすると、文字とともにその属性
も保たれます。`substring'、`insert'、`buffer-substring'などのさまざまな
関数がそうします。

* Menu:

* Examining Properties::	Looking at the properties of one character.
* Changing Properties::		Setting the properties of a range of text.
* Property Search::		Searching for where a property changes value.
* Special Properties::		Particular properties with special meanings.
* Format Properties::           Properties for representing formatting of text.
* Sticky Properties::           How inserted text gets properties from
                                  neighboring text.
* Saving Properties::           Saving text properties in files, and reading
                                  them back.
* Lazy Properties::             Computing text properties in a lazy fashion
                                  only when text is examined.
* Clickable Text::              Using text properties to make regions of text
                                  do something when you click on them.
* Not Intervals::		Why text properties do not use
				  Lisp-visible text intervals.



File: elisp-ja, Node: Examining Properties, Next: Changing Properties, Prev: Text Properties, Up: Text Properties

テキスト属性を調べる
--------------------

テキスト属性を調べるもっとも簡単な方法は、
特定の文字の特定の属性の値を問い合わせることです。
それには、`get-text-property'を使います。
文字の属性リスト全体を取得するには`text-properties-at'を使います。
複数の文字の属性を一度に調べるための関数については、
*Note Property Search::。

これらの関数は、文字列とバッファの両方を扱えます。文字列内の位置は0から
始まり、バッファ内の位置は1から始まることに注意してください。

 -- Function: get-text-property POS PROP &optional OBJECT
     この関数は、OBJECT（バッファか文字列）内の位置POSのうしろの1文字の
     属性PROPの値を返す。引数OBJECTは省略でき、デフォルトはカレントバッ
     ファである。

     その文字に属性PROPがなくてもシンボルであるカテゴリがあれば、
     `get-text-property'は当該シンボルの属性PROPを返す。

 -- Function: get-char-property POS PROP &optional OBJECT
     この関数は`get-text-property'に似ているが、
     まずオーバレイを調べてからテキスト属性を調べる。
     *Note Overlays::。

     引数OBJECTは、文字列、バッファ、ウィンドウのいずれかである。ウィン
     ドウであると、そのウィンドウに表示しているバッファのテキスト属性と
     オーバレイを対象にするが、対象となるオーバレイはそのウィンドウに対
     して活性なものだけである。OBJECTがバッファであると、テキスト属性に
     加えてそのバッファのすべてのオーバレイを対象にする。OBJECTが文字列
     であると、文字列にはオーバレイはないので、テキスト属性のみを対象に
     する。

 -- Function: text-properties-at POSITION &optional OBJECT
     この関数は、文字列やバッファであるOBJECT内の
     位置POSITIONにある1文字の属性リスト全体を返す。
     OBJECTが`nil'であると、デフォルトはカレントバッファである。

 -- Variable: default-text-properties
     この変数は、テキスト属性のデフォルト値を与える属性リストを保持する。
     直接的にもカテゴリシンボルを介して間接的にも文字に属性の値が指定さ
     れていないと、このリストに収めた値をかわりに使う。つぎに例を示す。

          (setq default-text-properties '(foo 69))
          ;; 位置1の文字に属性がないことを保証する
          (set-text-properties 1 2 nil)
          ;; 問い合わせたときに見えるのはデフォルト値である
          (get-text-property 1 'foo)
               => 69



File: elisp-ja, Node: Changing Properties, Next: Property Search, Prev: Examining Properties, Up: Text Properties

テキスト属性の変更
------------------

属性を変更する基本関数は、バッファや文字列の指定した範囲に作用します。
関数`set-text-properties'（本節の最後）は、その範囲のテキストの属性リス
ト全体を設定します。これは、名前で指定した特定の属性のみを追加／変更／
削除するのにしばしば有用です。

テキスト属性はバッファ（や文字列）の一部分であるとみなされ、スクリーン
上でのバッファの見た目に影響するので、バッファのテキスト属性を変更する
と、バッファには変更済みの印を付けます。バッファのテキスト属性の変更も
アンドゥ（*Note Undo::）できます。

 -- Function: put-text-property START END PROP VALUE &optional OBJECT
     この関数は、文字列やバッファであるOBJECT内の
     STARTとENDのあいだのテキストの属性PROPの値を
     VALUEとする。
     OBJECTが`nil'であると、デフォルトはカレントバッファである。

 -- Function: add-text-properties START END PROPS &optional OBJECT
     この関数は、文字列やバッファであるOBJECT内の
     STARTとENDのあいだのテキストの
     テキスト属性に追加／上書きする。
     OBJECTが`nil'であると、デフォルトはカレントバッファである。

     引数PROPSで追加する属性を指定する。これは属性リスト（*Note
     Property Lists::）の形であること。つまり、属性名とその値を交互に並
     べたリストであること。

     この関数が属性の値をどれか実際に変更したならば、戻り値は`t'である。
     さもなければ（PROPSが`nil'だったり、テキスト内の値と同じ値であると）
     `nil'である。

     たとえば、テキストのある範囲の属性`comment'と`face'を設定するには
     つぎのようにする。

          (add-text-properties START END
                               '(comment t face highlight))

 -- Function: remove-text-properties START END PROPS &optional OBJECT
     この関数は、文字列やバッファであるOBJECT内の
     STARTとENDのあいだのテキストから
     指定したテキスト属性を削除する。
     OBJECTが`nil'であると、デフォルトはカレントバッファである。

     引数PROPSで削除する属性を指定する。これは属性リスト（*Note
     Property Lists::）の形であること。つまり、属性名とその値を交互に並
     べたリストであること。ただし、意味があるのは名前のみであり、その値
     は無視する。たとえば、属性`face'を削除するにはつぎのようにする。

          (remove-text-properties START END '(face nil))

     この関数が属性の値をどれか実際に変更したならば、戻り値は`t'である。
     さもなければ（PROPSが`nil'だったり、
     指定したテキスト内の文字にそれらのいずれの属性もなければ）
     `nil'である。

     特定のテキストからすべてのテキスト属性を削除するには、
     新たな属性リストとして`nil'を指定して
     `set-text-properties'を使う。

 -- Function: set-text-properties START END PROPS &optional OBJECT
     この関数は、文字列やバッファであるOBJECT内のSTARTとENDのあいだのテ
     キストのテキスト属性を完全に置き換える。OBJECTが`nil'であると、デ
     フォルトはカレントバッファである。

     引数PROPSは新たな属性リストである。これは、属性名とその値を交互に
     並べたリストであること。

     `set-text-properties'から戻ると、指定した範囲のすべての文字は同一
     の属性を持つことになる。

     PROPSが`nil'であると、テキストの指定した範囲からすべての属性を削除
     する効果がある。たとえば、つぎのようにする。

          (set-text-properties START END nil)

バッファからテキストをコピーするがその属性はコピーしない関数
`buffer-substring-no-properties'（*Note Buffer Contents::）も参照してく
ださい。



File: elisp-ja, Node: Property Search, Next: Special Properties, Prev: Changing Properties, Up: Text Properties

テキスト属性を探す関数
----------------------

テキスト属性の典型的な用途では、ほとんどの場合多くの連続した文字の1つの
属性には同じ値があります。1つずつ文字を調べるようにプログラムするよりは、
同じ属性値を持つテキストの塊を処理するほうがとても速いです。

このために使える関数をここで説明します。
これらは属性値の比較に`eq'を使います。
OBJECTのデフォルトは、すべての場合でカレントバッファです。

高い効率のためには、これらの関数に引数LIMITを使うことが重要であり、1つ
の属性を探す関数には特にあてはまります。さもないと、読者が望む属性が変
更されないような場合、それらの関数はバッファの末尾まで走査して長い時間
を費すことになります。

これらの関数はポイントを移動しませんが、そのかわりに位置（あるいは
`nil'）を返します。位置はつねに2つの文字のあいだにあることに注意してく
ださい。これらの関数が返す位置は、異なる属性を持つ2つの文字のあいだです。

 -- Function: next-property-change POS &optional OBJECT LIMIT
     この関数は、文字列やバッファであるOBJECT内の位置POSからテキスト属
     性のいずれかが異なるまでテキストを走査し、その変化する位置を返す。
     いいかえれば、POSの直後の文字のテキスト属性とは異なる属性を持つ
     POSのあとにある最初の文字の位置を返す。

     LIMITが`nil'以外であると、LIMITの位置で走査を終える。
     その箇所まで異なる属性がないと、
     `next-property-change'はLIMITを返す。

     LIMITが`nil'でありOBJECTの末尾まで属性に変化がないと、値は`nil'で
     ある。値が`nil'以外であると、それはPOSより大きいか等しい位置である。
     値がPOSに等しいのは、LIMITがPOSに等しい場合のみである。

     バッファからすべての属性が同じであるテキストの塊を走査する方法の例
     をつぎに示す。

          (while (not (eobp))
            (let ((plist (text-properties-at (point)))
                  (next-change
                   (or (next-property-change (point) (current-buffer))
                       (point-max))))
              ポイントからNEXT-CHANGEまでのテキストを処理する...
              (goto-char next-change)))

 -- Function: next-single-property-change POS PROP &optional OBJECT LIMIT
     この関数は、文字列やバッファであるOBJECT内の位置POSから属性PROPが
     異なるまでテキストを走査し、その変化する位置を返す。いいかえれば、
     POSの直後の文字の属性PROPとは異なる属性PROPをもつPOSのあとにある最
     初の文字の位置を返す。

     LIMITが`nil'以外であると、LIMITの位置で走査を終える。
     その箇所まで異なる属性がないと、
     `next-single-property-change'はLIMITを返す。

     LIMITが`nil'でありOBJECTの末尾まで属性に変化がないと、値は`nil'で
     ある。値が`nil'以外であると、それはPOSより大きいか等しい位置である。
     値がPOSに等しいのは、LIMITがPOSに等しい場合のみである。

 -- Function: previous-property-change POS &optional OBJECT LIMIT
     これは`next-property-change'と同様であるが、前方へではなくPOSから
     後方へ走査する。値が`nil'以外であると、それはPOSより小さいか等しい
     位置である。値がPOSに等しいのは、LIMITがPOSに等しい場合のみである。

 -- Function: previous-single-property-change POS PROP &optional OBJECT LIMIT
     これは`next-single-property-change'と同様であるが、前方へではなく
     POSから後方へ走査する。値が`nil'以外であると、それはPOSより小さい
     か等しい位置である。値がPOSに等しいのは、LIMITがPOSに等しい場合の
     みである。

 -- Function: next-char-property-change POSITION &optional LIMIT
     これは`next-property-change'と同様であるが、テキスト属性に加えてオー
     バレイも対象にする。この関数はカレントバッファにのみ作用するため、
     OBJECTを表す引数はない。どちらかの属性が異なるつぎの位置を返す。

 -- Function: previous-char-property-change POSITION &optional LIMIT
     これは`next-char-property-change'と同様であるが、前方へではなく
     POSから後方へ走査する。

 -- Function: text-property-any START END PROP VALUE &optional OBJECT
     STARTとENDのあいだに属性PROPの値がVALUEである文字が1つでもあれば、
     この関数は`nil'以外を返す。より正確には、そのような最初の文字の位
     置を返す。さもなければ`nil'を返す。

     省略可能な5番目の引数OBJECTは、走査すべき文字列やバッファを指定する。
     位置はOBJECTに相対である。
     OBJECTのデフォルトはカレントバッファである。

 -- Function: text-property-not-all START END PROP VALUE &optional OBJECT
     STARTとENDのあいだに属性PROPの値がVALUEでない文字が1つでもあれば、
     この関数は`nil'以外を返す。より正確には、そのような最初の文字の位
     置を返す。さもなければ`nil'を返す。

     省略可能な5番目の引数OBJECTは、走査すべき文字列やバッファを指定する。
     位置はOBJECTに相対である。
     OBJECTのデフォルトはカレントバッファである。



File: elisp-ja, Node: Special Properties, Next: Format Properties, Prev: Property Search, Up: Text Properties

特別な意味を持つ属性
--------------------

特別な組み込みの意味を持つテキスト属性名の一覧を以下に示します。以降の
節では、詰め込みや属性の継承を制御する特別な属性名も示します。それ以外
の名前には標準的な意味はないので、読者はそれらを好きなように使ってかま
いません。

`category'
     文字に属性`category'があるとき、これを文字の"カテゴリ"（category）
     と呼ぶ。これはシンボルであること。そのシンボルの属性が、文字の属性
     のデフォルトとして働く。

`face'
     テキストのフォントと表示色を制御するために属性`face'を使う。その値
     はフェイス名かフェイス名のリストである。詳しくは、*Note Faces::。

     属性値がリストであると、その要素は、`(foreground-color .
     COLOR-NAME)'や`(background-color . COLOR-NAME)'の形でもよい。これ
     らの要素は、前景色だけや背景色だけを指定する。したがって、使用する
     各色を表すフェイスを作成する必要はない。

     テキストの内容に基づいて属性`face'を自動的に更新する方法に関しては、
     *Note Font Lock Mode::。

`mouse-face'
     マウスが文字の上やその近くにあると、属性`face'のかわりに属性
     `mouse-face'が使われる。この目的において『近く』とは、文字とマウス
     の位置のあいだの属性`mouse-face'の値が同じであるすべてのテキストで
     ある。

`local-map'
     属性`local-map'を用いることで、
     バッファ内のテキストの一部分に対して別のキーマップを指定できる。
     ポイントのうしろの文字のこの属性の値が`nil'以外であると、
     バッファのローカルマップのかわりにその値をキー探索に使う。
     属性値がシンボルであると、シンボルの関数定義をキーマップとして使う。
     *Note Active Keymaps::。

`syntax-table'
     属性`syntax-table'は、構文テーブルがこの文字に指定するものに優先する。
     *Note Syntax Properties::。

`read-only'
     文字に属性`read-only'があると、その文字を変更できない。変更するど
     のようなコマンドもエラーになる。

     挿入されるテキストがスティッキ性のために属性`read-only'を
     継承する場合には、読み出し専用文字のつぎにテキストを挿入するとエラーになる。
     したがって、スティッキ性を制御することで、
     読み出し専用テキストのつぎへのテキスト挿入を許すかどうかを制御できる。
     *Note Sticky Properties::。

     属性を変更するとバッファを変更したとみなすため、
     特別なトリックを知らない限り、属性を`read-only'を削除できない。
     つまり、`inhibit-read-only'に`nil'以外の値を束縛して、
     属性を削除する。
     *Note Read Only Buffers::。

`invisible'
     属性`invisible'が`nil'以外であると、その文字はスクリーンに表示され
     ない。詳しくは、*Note Invisible Text::。

`intangible'
     連続する文字に属性`intangible'の`nil'でない同じ値があると、それら
     のあいだにポイントを置けなくなる。前方に向けてこれらの文字の中にポ
     イントを移動しようとすると、ポイントは実際にはそれらの末尾へ移動す
     る。後方に向けてこれらの文字の中にポイントを移動しようとすると、ポ
     イントは実際にはそれらの先頭へ移動する。

     変数`inhibit-point-motion-hooks'が`nil'以外であると、属性
     `intangible'は無視される。

`modification-hooks'
     文字に属性`modification-hooks'がある場合、それは関数のリストである
     こと。その文字の変更にはそれらの関数すべてが呼び出される。各関数は
     2つの引数、つまり、バッファの変更対象部分の先頭と末尾を受け取る。
     1つの操作で変更される一連の文字に同じ変更フック関数が現れる場合、
     関数が実際に何回呼ばれるか予測できないことに注意してほしい。

`insert-in-front-hooks'
`insert-behind-hooks'
     バッファにテキストを挿入する操作でも、挿入箇所のうしろの文字の属性
     `insert-in-front-hooks'とまえの文字の属性`insert-behind-hooks'に指
     定されている関数群を呼び出す。これらの関数は2つの引数、つまり、挿
     入されたテキストの先頭と末尾を受け取る。これらの関数が呼ばれるのは、
     実際の挿入操作を*終えてから*である。

     バッファ内のテキストを変更するときに呼び出される他のフックについては、
     *Note Change Hooks::も参照。

`point-entered'
`point-left'
     特別な属性`point-entered'と`point-left'は、ポイント移動を報告する
     フック関数を保持する。ポイントが動くたびに、Emacsはこれらの2つの属
     性値、つまり、

        * 移動前のポイントのうしろの文字の属性`point-left'と
        * 移動後のポイントのうしろの文字の属性`point-entered'

     を比較する。これら2つの値が異なれば、ポイントの古い値と新しい値の
     2つの引数で（`nil'でなければ）それぞれを呼び出す。

     同じことを移動前後のポイントのまえの文字についても行う。その結果、
     （同じかもしれない）`point-left'の関数を2回、かつ／あるいは、（同
     じかもしれない）`point-entered'の関数を2回実行する。いずれにしても、
     `point-left'の関数が最初に呼ばれ、そのあとで`point-entered'の関数
     が呼ばれる。

     これらの関数では、`char-after'を使ってポイントを移動せずにさまざま
     な箇所の文字を調べられる。ポイントの値が実際に変わったときにのみ、
     これらのフック関数が実行される。

 -- Variable: inhibit-point-motion-hooks
     この変数が`nil'以外であると、`point-left'と`point-entered'のフック
     関数は実行されなくなり、属性`intangible'の効果もなくなる。この変数
     はグローバルに設定せずに、`let'で束縛すること。



File: elisp-ja, Node: Format Properties, Next: Sticky Properties, Prev: Special Properties, Up: Text Properties

整形済みテキストの属性
----------------------

これらのテキスト属性は、詰め込みコマンドのふるまいに影響します。
これらは整形済みのテキストを表現するために使われます。
*Note Filling::と*Note Margins::。

`hard'
     改行文字にこの属性があると、『ハード』改行である。
     詰め込みコマンドは『ハード』改行を変更せず、
     それらをまたがって単語を移動しない。
     しかし、この属性は`use-hard-newlines'が
     `nil'以外の場合にのみ効果を持つ。

`right-margin'
     テキストのこの部分を詰め込むための余分な右端余白を指定する。

`left-margin'
     テキストのこの部分を詰め込むための余分な左端余白を指定する。

`justification'
     テキストのこの部分を詰め込むための幅揃えスタイルを指定する。



File: elisp-ja, Node: Sticky Properties, Next: Saving Properties, Prev: Format Properties, Up: Text Properties

テキスト属性のスティッキ性
--------------------------

自己挿入文字は、通常、先行する文字と同じ属性を持ちます。これを属性の"継
承"（inheritance）と呼びます。

Lispプログラムでは、挿入基本関数を選べば、継承して挿入したり継承せずに
挿入できます。`insert'などの普通のテキスト挿入関数は、いかなる属性も継
承しません。これらは、挿入する文字列の属性をそのまま持ったテキストを挿
入し、それ以外の属性はありません。キルリングなどのある文脈から別の文脈
へテキストをコピーするプログラムには、これは正しい動作です。継承して挿
入するには、本節で述べる特別な基本関数を使います。自己挿入文字はこれら
の基本関数を使っているので、属性を継承します。

継承して挿入するとき、*どの*属性を継承するかは、2つの特別な属性
`front-sticky'と`rear-nonsticky'に依存します。

文字のうしろに挿入すると、その文字の"後続スティッキ"（rear-sticky）であ
る属性を継承します。文字のまえに挿入すると、その文字の"先行スティッキ"
（front-sticky）である属性を継承します。デフォルトでは、テキスト属性は
先行スティッキではなく後続スティッキです。したがって、デフォルトでは、
まえの文字のすべての属性を継承して、うしろの文字からはなにも継承しませ
ん。特定の属性のスティッキ性を指定することで、異なるふるまいを指定でき
ます。

文字の属性`front-sticky'が`t'であると、その文字のすべての属性は先行ス
ティッキです。属性`front-sticky'がリストであると、リストに現れる名前の
その文字の属性は先行スティッキです。たとえば、文字の属性`front-sticky'
の値が`(face read-only)'であると、この文字のまえに挿入するとこの文字の
属性`face'と`read-only'を継承しますが、それ以外には継承しません。

`rear-nonsticky'は反対の働きをします。すべての属性はデフォルトでは後続
スティッキですから、属性`rear-nonsticky'はどの属性が後続スティッキで*な
い*かを指定します。文字の属性`rear-nonsticky'が`t'であると、その文字に
は後続スティッキである属性はありません。属性`rear-nonsticky'がリストで
あると、リストに名前が現れ*ない限り*、属性は後続スティッキです。

継承するようにテキストを挿入すると、まえの文字からは後続スティッキであ
るすべての属性を継承し、うしろの文字からは先行スティッキであるすべての
属性を継承します。両側の文字に異なるスティッキ性の同じ属性がある場合に
は、まえの文字の属性が優先します。

属性を継承してテキストを挿入する関数はつぎのとおりです。

 -- Function: insert-and-inherit &rest STRINGS
     関数`insert'と同様に文字列STRINGSを挿入するが、前後のテキストから
     任意のスティッキ性の属性を継承する。

 -- Function: insert-before-markers-and-inherit &rest STRINGS
     関数`insert-before-markers'と同様に文字列STRINGSを挿入するが、前後
     のテキストから任意のスティッキ性の属性を継承する。

継承しない普通の挿入関数については、*Note Insertion::。



File: elisp-ja, Node: Saving Properties, Next: Lazy Properties, Prev: Sticky Properties, Up: Text Properties

テキスト属性をファイルへ保存する
--------------------------------

つぎの2つのフックを使って、テキスト属性を（テキストそのものとともに）ファ
イルに保存しておき、ファイルを訪問したり挿入するときに同じテキスト属性
を復元できます。

 -- Variable: write-region-annotate-functions
     この変数の値は、ファイルへ書き込むテキストに対する注記の形で
     テキスト属性を符号化するために`write-region'が呼び出す関数の
     リストである。
     *Note Writing to Files::。

     リスト内の各関数は2つの引数、つまり、書き込む領域の先頭と末尾で呼
     び出される。これらの関数はバッファの内容を変更しないこと。そのかわ
     りに、バッファのテキストに加えてファイルに書き込むべき注記を表すリ
     ストを返すべきである。

     各関数は、`(POSITION . STRING)'の形の要素から成る
     リストを返すべきである。
     ここで、POSITIONは書き込まれるテキスト内の相対位置を指定する整数、
     STRINGはそこへ追加する注記である。

     これらの関数が返す各リストは、POSITIONの昇順になっている必要がある。
     複数の関数があると、`write-region'はリストを破壊的に併合して1つの
     ソートしたリストにする。

     `write-region'がバッファからファイルにテキストを実際に書くときに、
     指定された注記を対応する位置に混在させる。バッファを変更せずにこれ
     らすべてを行う。

 -- Variable: after-insert-file-functions
     この変数は、`insert-file-contents'がファイルの内容を挿入してから呼
     び出す関数のリストを保持する。これらの関数は挿入されたテキストで注
     記を走査し、それらが表すテキスト属性にそれらを変換する。

     各関数は1つの引数、つまり、挿入されたテキストの長さで呼ばれ、ポイ
     ントは挿入されたテキストの先頭を表す。関数は当該テキストで注記を走
     査して注記を削除し、注記が指定するテキスト属性を作成する。関数は、
     変更を反映した挿入されたテキストの更新された長さを返すこと。関数が
     返した値がつぎの関数の引数になる。

     これらの関数は、挿入されたテキストの先頭にポイントをつねに戻すこと。

     `after-insert-file-functions'の意図された用途は、テキスト表現の注
     記を実際のテキスト属性に変換することである。しかし、別の使い方も可
     能である。

これらのフックを使ってファイルにテキスト属性を保存したり復元するLispプ
ログラムを書いて、さまざまなデータ書式を試してよいものをみつけるように
お願いします。最終的には、Emacsに取り込める良質で汎用の拡張をユーザーが
作り出すことを願っています。

テキスト属性の名前や値として任意のLispオブジェクトを処理しないように忠
告しておきます。そのような汎用のプログラムは書くのが難しく動作が遅くな
りがちです。そのかわりに、適当に柔軟性があり符号化が難しくないデータ型
の集合を選びます。

関連する機能については、*Note Format Conversion::。




File: elisp-ja, Node: Lazy Properties, Next: Clickable Text, Prev: Saving Properties, Up: Text Properties

テキスト属性の遅延計算
----------------------

バッファ内のすべてのテキストのテキスト属性を計算するかわりに、必要になっ
た時点でテキストの一部分のテキスト属性を計算するようにできます。

バッファからテキスト属性とともにテキストを取り出す基本関数は、
`buffer-substring'です。
属性を調べるまえに、この関数はアブノーマルフック
`buffer-access-fontify-functions'を実行します。

 -- Variable: buffer-access-fontify-functions
     この変数は、テキスト属性を計算する関数のリストを保持する。
     `buffer-substring'がバッファの一部分からテキストとテキスト属性をコ
     ピーするまえに、この関数はこのリスト内の関数すべてを呼び出す。各関
     数は、バッファの参照される範囲を指定する2つの引数を受け取る。（バッ
     ファはつねにカレントバッファである。）

関数`buffer-substring-no-properties'はテキスト属性を無視するので、これ
らの関数を呼び出しません。

バッファの同じ部分に対してフック関数が複数回呼び出されるのを防ぐには、
変数`buffer-access-fontified-property'を使います。

 -- Variable: buffer-access-fontified-property
     この変数の値が`nil'以外であると、それはテキスト属性の名前として使
     われるシンボルである。そのテキスト属性に対する`nil'以外の値は、
     『この文字の他のテキスト属性はすでに計算済みである』ことを意味する。

     `buffer-substring'に指定された範囲のすべての文字において、この属性
     に対して`nil'以外の値があると、`buffer-substring'は
     `buffer-access-fontify-functions'の関数を呼び出さない。それらの文
     字にはすでに正しいテキスト属性があるとみなし、それらにすでにある属
     性をコピーする。

     この機能を使う普通の方法は、`buffer-access-fontify-functions'の関
     数が他の属性ととともにこの属性をそれらが操作した文字に追加する。そ
     うすれば、同じテキストに対して何回も呼び出されるのを防ぐことができ
     る。



File: elisp-ja, Node: Clickable Text, Next: Not Intervals, Prev: Lazy Properties, Up: Text Properties

クリック可能なテキストを定義する
--------------------------------

バッファ内に"クリック可能なテキスト"（clickable text）を設定するには2つ
の方法があります。これは典型的には2つの部分から成ります。つまり、マウス
が重なるとテキストを強調表示し、テキストのその部分をクリックするとマウ
スボタンがなんらかの処理を行うようにします。

強調表示はテキスト属性`mouse-face'で行います。diredでの方法を例として示
します。

     (condition-case nil
         (if (dired-move-to-filename)
             (put-text-property (point)
                                (save-excursion
                                  (dired-move-to-end-of-filename)
                                  (point))
                                'mouse-face 'highlight))
       (error nil))

`put-text-property'の最初の2つの引数は、テキストの先頭と末尾を指定しま
す。

このテキストをクリックしたときにマウスになにかをさせるようにする普通の
方法は、メジャーモードのキーマップで`mouse-2'を定義することです。クリッ
ク可能なテキストをクリックしたかどうかの検査は、コマンド定義で行われま
す。diredではつぎのようにしています。

     (defun dired-mouse-find-file-other-window (event)
       "In dired, visit the file or directory name you click on."
       (interactive "e")
       (let (file)
         (save-excursion
           (set-buffer (window-buffer (posn-window (event-end event))))
           (save-excursion
             (goto-char (posn-point (event-end event)))
             (setq file (dired-get-filename))))
         (select-window (posn-window (event-end event)))
         (find-file-other-window (file-name-sans-versions file t))))

外側の`save-excursion'は、カレントバッファが変わることを防ぎます。内側
のは、クリックしたバッファのポイントを恒久的に変更することを防ぎます。
この例では、diredは関数`dired-get-filename'を用いて、イベントの位置に基
づいて訪問すべきファイルを決定します。

メジャーモードのマウスコマンドを定義するかわりに、テキスト属性
`local-map'を使って、クリック可能なテキストそのものにキーバインディング
を定義することもできます。

     (let ((map (make-sparse-keymap)))
       (define-key-binding map [mouse-2] 'operate-this-button)
       (put-text-property (point)
                          (save-excursion
                            (dired-move-to-end-of-filename)
                            (point))
                          'local-map map))

この方法では、テキストのさまざまなクリック可能な部分に異なるコマンドを
定義できます。さらに、バッファの残りの部分に対しては、メジャーモードの
定義（やグローバルな定義）がそのまま有効です。



File: elisp-ja, Node: Not Intervals, Prev: Clickable Text, Up: Text Properties

テキスト属性が範囲でない理由
----------------------------

バッファ内のテキストに属性を付加できるエディタのなかには、ユーザーにテ
キスト内の『範囲』を指定させ、その範囲に属性を付加するものがあります。
このようなエディタでは、ユーザーやプログラマが個々の範囲の先頭と末尾を
決定できます。テキスト変更に伴うある種の矛盾するようなふるまいを避ける
ために、熟考の結果Emacs Lispでは別の種類のインターフェイスを提供するこ
とにしました。

複数の範囲に細分することが意味を持つならば、ある属性の1つの範囲があるだ
けのバッファと、その同じテキストをその同じ属性の2つの範囲にしてあるバッ
ファとを区別できるはずです。

1つの範囲だけを持つバッファにおいて、そのテキストの一部をキルしたとしま
す。バッファに残っているテキストは1つの範囲であり、キルリング（とアンドゥ
リスト）内のコピーは1つの別の範囲になります。そしてキルされたテキストを
ヤンクして戻すと、同じ属性を持つ2つの範囲ができます。つまり、編集すると、
1つの範囲と2つの範囲の区別を保存できなくなります。

テキストを挿入すると2つの範囲を融合することでこの問題を『修正』したとし
ます。バッファにもともと1つの範囲しかなければ、うまくいきます。しかし、
同じ属性の範囲が連続して2つある場合に、一方の範囲をキルしてからヤンクし
て戻したとします。別の場面では救いになる同じ属性の範囲を融合する機能が、
ここではトラブルを引き起こします。つまり、ヤンクすると1つの範囲になって
しまいます。ここでも、編集すると、1つの範囲と2つの範囲の区別を保存でき
なくなります。

2つの範囲の境界にテキストを挿入する場合でも、満足できる解決方法がない問
題を提起します。

しかし、『この文字の属性はなにか』といった形の問いに対して一貫したふる
まいをするような編集にするのは簡単です。そのために、これらが唯一の意味
ある問いかけであると判断したのです。範囲の先頭と末尾を問うようなものは
実装してありません。

実用上は、明示的な範囲の境界のかわりに、
テキスト属性を探索する関数を普通は使えます。
それらの関数は、可能な場合にはつねに範囲は融合されると仮定して
範囲の境界を探すと考えることができます。
*Note Property Search::。

Emacsには表示機能として明示的な範囲もあります。
*Note Overlays::を参照してください。



File: elisp-ja, Node: Substitution, Next: Registers, Prev: Text Properties, Up: Text

文字コードの置換
================

つぎの関数は、指定した領域内の文字をそれらの文字コードに基づいて置き換
えます。

 -- Function: subst-char-in-region START END OLD-CHAR NEW-CHAR &optional NOUNDO
     この関数は、カレントバッファのSTARTとENDで定義される領域のすべての
     文字OLD-CHARを文字NEW-CHARに置き換える。

     NOUNDOが`nil'以外であると、`subst-char-in-region'はアンドゥ用の変
     更を記録せず、バッファに変更済みの印も付けない。この機能は、選択表
     示（*Note Selective Display::）の制御に使われている。

     `subst-char-in-region'はポイントを移動せず、
     `nil'を返す。

          ---------- Buffer: foo ----------
          This is the contents of the buffer before.
          ---------- Buffer: foo ----------

          (subst-char-in-region 1 20 ?i ?X)
               => nil

          ---------- Buffer: foo ----------
          ThXs Xs the contents of the buffer before.
          ---------- Buffer: foo ----------

 -- Function: translate-region START END TABLE
     この関数は、バッファのSTARTとENDのあいだの文字に変換表を適用する。

     変換表TABLEは文字列であり、
     `(aref TABLE OCHAR)'は、
     OCHARに対応する変換した文字を与える。
     TABLEの長さが256未満であると、
     TABLEの長さより大きなコードの文字は変換によっては変更されない。

     `translate-region'の戻り値は、変換によって実際に変更した文字の個数
     を返す。これには、変換表で自分自身に変換された文字は数えない。



File: elisp-ja, Node: Registers, Next: Transposition, Prev: Substitution, Up: Text

レジスタ
========

レジスタは、Emacsの編集においてさまざまな種類の値を保持できる変数の一種
です。各レジスタには1文字の名前が付いています。すべてのASCII文字とそれ
らのメタ変種（ただし`C-g'を除く）をレジスタの名前に使えます。したがって、
255個のレジスタを使えます。Emacs Lispでは、レジスタ名でレジスタを区別し
ます。

 -- Variable: register-alist
     この変数は、`(NAME . CONTENTS)'の形の要素の連想リストである。通常、
     使用中のEmacsの各レジスタに対して1つの要素がある。

     オブジェクトNAMEは、レジスタを識別する文字（整数）である。

レジスタの内容（CONTENTS）に可能な型はいくつかあります。

数
     数そのものを表す。
     `insert-register'がレジスタ内で数をみつけると10進数に変換する。

マーカ
     マーカはジャンプ先のバッファ内位置を表す。

文字列
     文字列はレジスタに保存されたテキストである。

矩形領域
     矩形領域は文字列のリストで表現される。

`(WINDOW-CONFIGURATION POSITION)'
     これは、1つのフレームに復元するウィンドウ構成とカレントバッファで
     のポイントの移動先を表す。

`(FRAME-CONFIGURATION POSITION)'
     これは、復元するフレーム構成とカレントバッファでのポイントの移動先
     を表す。

(file FILENAME)
     訪問すべきファイルを表す。この値にジャンプするとファイルFILENAMEを
     訪問する。

(file-query FILENAME POSITION)
     これは、訪問すべきファイルとその中での位置を表す。この値にジャンプ
     するとファイルFILENAMEを訪問しバッファ内位置POSITIONへ移動する。こ
     の種の位置を復元すると、まずユーザーに確認を取る。

本節の関数は、明記してない場合には予測できない値を返します。

 -- Function: get-register REG
     この関数は、レジスタREGの内容、あるいは、内容がなければ`nil'を返す。

 -- Function: set-register REG VALUE
     この関数は、レジスタREGの内容をVALUEとする。レジスタには任意の値を
     設定できるが、他のレジスタ関数は特定のデータ型を期待する。戻り値は
     VALUEである。

 -- コマンド: view-register REG
     このコマンドは、レジスタREGになにが入っているかを表示する。


 -- コマンド: insert-register REG &optional BEFOREP
     このコマンドはレジスタREGの内容をカレントバッファに挿入する。

     通常、このコマンドは挿入したテキストのまえにポイントを置き、そのあ
     とにマークを置く。しかし、省略可能な2番目の引数BEFOREPが`nil'以外
     であると、まえにマークを置きあとにポイントを置く。この関数を対話的
     に呼び出すときに前置引数を指定すれば、2番目の引数BEFOREPに`nil'以
     外を渡せる。

     レジスタに矩形領域が含まれる場合、ポイント位置に矩形領域の左上隅が
     くるように挿入される。つまり、テキストは現在行とそのしたの連続する
     行に挿入される。

     保存したテキスト（文字列）や矩形領域（リスト）以外がレジスタに入っ
     ていると、現状では有用なことは起こらない。将来これは変更されるであ
     ろう。




File: elisp-ja, Node: Transposition, Next: Change Hooks, Prev: Registers, Up: Text

テキストの転置
==============

つぎのサブルーティンは転置コマンドで使われます。

 -- Function: transpose-regions START1 END1 START2 END2 &optional LEAVE-MARKERS
     この関数は、バッファの重なり合わない2つの部分を入れ換える。引数
     START1とEND1で一方の部分の境界を指定し、引数START2とEND2で他方の部
     分の境界を指定する。

     通常、`transpose-regions'は転置したテキスト内のマーカを再配置する。
     つまり、2つの転置部分の一方の内側を指していたマーカはその部分とと
     もに移動して、新しい位置で同じ2つの文字のあいだに留まる。しかし、
     LEAVE-MARKERSが`nil'以外であると、`transpose-regions'はこれを行わ
     ず、すべてのマーカは再配置されない。



File: elisp-ja, Node: Change Hooks, Prev: Transposition, Up: Text

変更フック
==========

これらのフックにより、すべてのバッファ
（それらをバッファローカルにしておけば特定のバッファ）における
すべての変更を知るようにできます。
テキストの特定部分の変更を検出する方法については、
*Note Special Properties::も参照してください。

これらのフックに使う関数において正規表現を使う場合には、マッチデータを
保存し復元する必要があります。さもないと、それらを呼び出す編集操作と奇
妙な干渉を引き起こします。

 -- Variable: before-change-functions
     この変数は、バッファを変更するまえに呼び出すべき関数のリストを保持
     する。各関数は2つの引数、つまり、整数で表した変更対象の領域の先頭
     と末尾を受け取る。変更対象のバッファはつねにカレントバッファである。

 -- Variable: after-change-functions
     この変数は、バッファを変更したあとに呼び出すべき関数のリストを保持
     する。各関数は3つの引数、つまり、変更されたばかりの領域の先頭と末
     尾、変更前に存在していたテキストの長さを受け取る。3つの引数はすべ
     て整数である。変更対象のバッファはつねにカレントバッファである。

     古いテキストの長さは、変更前のそのテキストの先頭と末尾のバッファ内
     位置の差である。変更済みのテキストの長さは、単純に始めの2つの引数
     の差である。

 -- Macro: combine-after-change-calls BODY...
     このマクロは通常どおりBODYを実行するが、
     一連の変更に対して安全と思えるときには、
     `after-change-functions'の関数を一度だけ呼び出す。

     プログラムからバッファの同じ部分でテキスト変更を複数回行う場合、プ
     ログラムの当該部分の周りでマクロ`combine-after-change-calls'を使う
     と、フック`after-change-functions'を使用してるときには動作がかなり
     速くなりうる。最終的にフック`after-change-functions'が呼ばれると、
     `combine-after-change-calls'の本体で行った変更すべてを含むようなバッ
     ファ部分が引数に指定される。

     *警告：*` ' フォーム`combine-after-change-calls'の本体の内側では
     `after-change-functions'と`after-change-function'の値を変更しない
     こと。

     *注意：*` ' 変更がバッファの広く分散した部分に行われるときにもこれ
     は動作するが、推奨できない。非効率なふるまいをするようなフック関数
     があるからである。

 -- Variable: before-change-function
     この廃れた変数は、任意のバッファの変更を行うまえに
     呼ばれる1つの関数を保持する
     （`nil'ならばそのような関数はなし）。
     `before-change-functions'の関数と同様に呼ばれる。

 -- Variable: after-change-function
     この廃れた変数は、任意のバッファの変更を行ったあとに
     呼ばれる1つの関数を保持する
     （`nil'ならばそのような関数はなし）。
     `after-change-functions'の関数と同様に呼ばれる。

上の4つの変数は、これらの関数が実行中には一時的に`nil'に束縛されます。
つまり、これらの関数の1つがバッファを変更しても、その変更ではこれらの関
数を呼び出しません。フック関数においてこれらの関数を実行するような変更
を行いたい場合には、フック関数でこれらの変数をそれらの通常の値に束縛し
直します。

この保護的な機構の1つの不便な帰結は、`after-change-functions'や
`before-change-functions'には、その変数の値を変更する関数を持てないこと
です。しかし、これは本当の制限ではありません。それらの関数で実行すべき
関数のリストを変更したければ、単純に1つの定まった関数をフックに追加し、
その関数では呼び出すべき別の関数を指定する別の変数を調べます。つぎのよ
うにします。

     (setq my-own-after-change-functions nil)
     (defun indirect-after-change-function (beg end len)
       (let ((list my-own-after-change-functions))
         (while list
           (funcall (car list) beg end len)
           (setq list (cdr list)))))

     (add-hooks 'after-change-functions
                'indirect-after-change-function)

 -- Variable: first-change-hook
     この変数は、未変更状態のバッファを変更するたびに実行されるノーマル
     フックである。


File: elisp-ja, Node: Non-ASCII Characters, Next: Searching and Matching, Prev: Text, Up: Top

非ASCII文字
***********

本章では、非ASCIIに関連する特別なことがらとそれらが文字列やバッファにど
のように保存されるかについて述べます。

* Menu:

* Text Representations::
* Converting Representations::
* Selecting a Representation::
* Character Codes::
* Character Sets::
* Chars and Bytes::
* Splitting Characters::
* Scanning Charsets::
* Translation of Characters::
* Coding Systems::
* Input Methods::



File: elisp-ja, Node: Text Representations, Next: Converting Representations, Prev: Non-ASCII Characters, Up: Non-ASCII Characters

テキスト表現
============

Emacsには2つの"テキスト表現"、つまり、文字列やバッファでテキストを表す
方法が2つあります。これらは、"ユニバイト"（unibyte）と"マルチバイト
（multibyte）と呼ばれます。各文字列や各バッファでは、これらの2つの表現
の一方を使います。ほとんどの目的には、Emacsがこれらのあいだで適切に変換
するので、読者はこれらの表現に関しては無視できます。Lispプログラムでは、
これらの違いに注意する必要がしばしばあります。

ユニバイト表現では、各文字は1バイトを占め、そのため、可能な文字コードの
範囲は0から255です。コード0から127はASCII文字です。コード128から255は非
ASCII文字集合の1つ（変数`nonascii-insert-offset'に設定して文字集合を選
べる）に使われます。

マルチバイト表現では、1文字は1バイト以上を占め、そのため、Emacsの文字コー
ドの範囲全体を格納できるのです。マルチバイト文字の最初のバイトはつねに
128から159（8進数で0200から0237）の範囲にあります。これらの値を"リーディ
ングコード"（leading code）と呼びます。マルチバイト文字の2バイト以降は
つねに160から255（8進数で0240から0377）の範囲にあります。これらの値を"
トレイリングコード"（trailing code）と呼びます。

バッファでは、変数`enable-multibyte-characters'のバッファローカルな値が
使用する表現を指定します。文字列の表現は、文字列を作成するときの文字列
の内容に基づいて決定されます。

 -- Variable: enable-multibyte-characters
     この変数は、バッファのテキスト表現を指定する。これが`nil'以外であ
     ると、バッファはマルチバイトテキストを保持する。さもなければユニバ
     イトテキストを保持する。

     この変数に直接設定することはできない。そのかわりに、バッファの表現
     を変更するには、関数`set-buffer-multibyte'を使う。

 -- Variable: default-enable-multibyte-characters
     この変数の値は、`(default-value 'enable-multibyte-characters)'に完
     全に等価であり、この変数に設定するとデフォルト値を変更する。バッファ
     の`enable-multibyte-characters'のローカルな束縛に設定することは許
     されていないが、デフォルト値を変更することは可能であり、そうしても
     既存のバッファには影響しないので理にかなっている。

     コマンド行オプション`--unibyte'は、起動時の早い段階でデフォルト値
     に`nil'を設定することで役目を果たす。

 -- Function: multibyte-string-p STRING
     文字列STRINGにマルチバイト文字が含まれると`t'を返す。



File: elisp-ja, Node: Converting Representations, Next: Selecting a Representation, Prev: Text Representations, Up: Non-ASCII Characters

テキスト表現の変換
==================

Emacsはユニバイトテキストをマルチバイトに変換できます。マルチバイトテキ
ストをユニバイトにも変換できますが、この変換では情報が欠落します。バッ
ファにテキストを挿入するとき、あるいは、複数の文字列から1つの文字列にテ
キストを収めるときに、一般にこれらの変換が行われます。文字列の内容をど
ちらかの表現に明示的にも変換できます。

Emacsは、文字列を作成するときにはその内容に基づいて文字列の表現を選びま
す。一般則は、ユニバイトテキストを他のマルチバイトテキストに組み入れる
ときにはユニバイトテキストをマルチバイトテキストに変換します。マルチバ
イト表現のほうが汎用であり、ユニバイトテキストのどんな文字でも保持でき
るからです。

バッファにテキストを挿入するときには、Emacsは、当該バッファの
`enable-multibyte-characters'の指定に従ったバッファの表現にテキストを変
換します。特に、ユニバイトバッファにマルチバイトテキストを挿入するとき
には、マルチバイトテキスト内のすべての文字を一般には保存できなくても、
Emacsはテキストをユニバイトに変換します。自然な代替案はバッファ内容をマ
ルチバイトに変換することですが、これは受け入れられません。バッファの表
現はユーザーが選択したものであり自動的には無視できないからです。

ユニバイトテキストをマルチバイトテキストに変換してもASCII文字は無変更で
あり、128から159も同様です。160から255の非ASCIIについては、各文字に
`nonascii-insert-offset'の値を加算することで変換します。この変数に設定
すると、ユニバイト文字がどの文字集合に対応するかを指定できます（*Note
Character Sets::）。たとえば、`nonascii-insert-offset'が`(- (make-char
'latin-iso8859-1) 128)'の2048であると、非ASCIIのユニバイトはLatin 1に対
応します。`(- (make-char 'greek-iso8859-7) 128)'の2688であると、ギリシャ
文字に対応します。

マルチバイトテキストをユニバイトに変換するのは簡単で、各文字コードと
255の論理積をとります。`nonascii-insert-offset'に文字集合の始まりに対応
する合理的な値が設定されていれば、この変換は逆変換になります。つまり、
ユニバイトテキストをマルチバイトに変換し、それをユニバイトに戻すともと
のユニバイトテキストになります。

 -- Variable: nonascii-insert-offset
     この変数は、ユニバイトテキストをマルチバイトに変換するときに非
     ASCII文字に加算する値を指定する。これは、128から255のユニバイトの
     非ASCIIの範囲の文字を挿入する`self-insert-command'にも適用される。
     しかし、関数`insert-char'はこの変換を行わない。

     文字集合CSを選択する正しい値は、`(- (make-char CS) 128)'である。
     `nonascii-insert-offset'の値が0であると、実際の変換には0ではなく
     Latin 1文字集合に対する値を使う。

 -- Variable: nonascii-translation-table
     この変数は、`nonascii-insert-offset'のより一般的な代替を提供する。
     128から255の範囲の各コードをマルチバイト文字に変換する方法を独立し
     て指定するために使える。その値はベクトルか`nil'であること。これが
     `nil'以外であると、`nonascii-insert-offset'に優先する。

 -- Function: string-make-unibyte STRING
     この関数は、STRINGのテキストがすでにユニバイトでなければ
     ユニバイト表現に変換してから結果を返す。
     STRINGがユニバイトであれば無変更で返す。

 -- Function: string-make-multibyte STRING
     この関数は、STRINGのテキストがすでにマルチバイトでなければ
     マルチバイト表現に変換してから結果を返す。
     STRINGがマルチバイトであれば無変更で返す。



File: elisp-ja, Node: Selecting a Representation, Next: Character Codes, Prev: Converting Representations, Up: Non-ASCII Characters

表現の選択
==========

既存のバッファや文字列がユニバイトであるときにマルチバイトとして調べた
り、その逆のように調べるのが有用なこともあります

 -- Function: set-buffer-multibyte MULTIBYTE
     カレントバッファの表現方法を設定する。
     MULTIBYTEが`nil'以外であると、バッファはマルチバイトになる。
     MULTIBYTEが`nil'であると、バッファはユニバイトになる。

     この関数は、バイト列としてみたバッファ内容を変更しない。その結果、
     文字として見たときの内容を変更できる。マルチバイト表現では1文字と
     みなされる2バイトの列は、ユニバイト表現では2文字になる。

     この関数は、`enable-multibyte-characters'にどちらの表現を使用して
     いるかを記録する。さらに（オーバレイ、テキスト属性、マーカなどの）
     バッファ内のさまざまなデータを調整して、それ以前と同様に同じテキス
     トに及ぶようにする。

 -- Function: string-as-unibyte STRING
     この関数は、各バイトを1文字とみなしてSTRINGと同じバイトの文字列を
     返す。つまり、値にはSTRINGより多くの文字が含まれることがある。

     STRINGがすでにユニバイトであると、値はSTRINGそのものである。

 -- Function: string-as-multibyte STRING
     この関数は、マルチバイトの各列を1文字とみなしてSTRINGと同じバイト
     の文字列を返す。つまり、値にはSTRINGより少ない文字が含まれることが
     ある。

     STRINGがすでにマルチバイトであると、値はSTRINGそのものである。



File: elisp-ja, Node: Character Codes, Next: Character Sets, Prev: Selecting a Representation, Up: Non-ASCII Characters

文字コード
==========

ユニバイトとマルチバイトのテキスト表現では、異なる文字コードを使ってい
ます。ユニバイト表現において正しい文字コードは0から255の範囲であり、こ
れらの値は1バイトに収まります。マルチバイト表現において正しい文字コード
は0から524287の範囲ですが、この範囲のすべての値が正しいとは限りません。
特に、値128から255は（『生のバイト』にはありうる。*Note Explicit
Encoding::）、マルチバイトテキストでは正しくありません。0から127の
ASCIIコードのみが、どちらの表現でも完全に正しいのです。

 -- Function: char-valid-p CHARCODE
     この関数は、CHARCODEが2つのテキスト表現のどちらか一方で正しければ
     `t'を返す。

          (char-valid-p 65)
               => t
          (char-valid-p 256)
               => nil
          (char-valid-p 2248)
               => t



File: elisp-ja, Node: Character Sets, Next: Chars and Bytes, Prev: Character Codes, Up: Non-ASCII Characters

文字集合
========

Emacsは文字をさまざまな"文字集合"（character set）に分類します。文字集
合にはシンボルである名前があります。各文字はたった1つの文字集合に属しま
す。

一般に、異なる文字体系ごとに1つの文字集合があります。たとえば、
`latin-iso8859-1'は1つの文字集合であり、`greek-iso8859-7'は別の文字集合
であり、`ascii'も別の文字集合です。Emacsの1つの文字集合には最大9025個の
文字を保持できます。したがって、論理的には1つの文字集合にまとめられる文
字群を、複数の文字集合に分割する場合もあります。たとえば、Big 5として一
般には知られている中国文字の1つの集合は、Emacsの2つの文字集合、
`chinese-big5-1'と`chinese-big5-2'に分割されます。

 -- Function: charsetp OBJECT
     OBJECTが文字集合の名前のシンボルであれば`t'を返す。さもなければ
     `nil'を返す。

 -- Function: charset-list
     この関数は、定義されているすべての文字集合の名前のリストを返す。

 -- Function: char-charset CHARACTER
     この関数は文字CHARACTERが属する文字集合の名前を返す。



File: elisp-ja, Node: Chars and Bytes, Next: Splitting Characters, Prev: Character Sets, Up: Non-ASCII Characters

文字とバイト
============

マルチバイト表現では、各文字は1バイトかそれ以上のバイトを占めます。各文
字集合には、通常は1バイト長か2バイト長の"導入列"（introduction
sequence）があります（例外：ASCIIの導入列は0バイト長である）。導入列は、
文字集合の任意の文字のバイト列の始まりです。文字のバイト列の残りの部分
は、同じ文字集合内で他の文字とその文字を区別します。文字集合に依存して、
区別するためのバイトは1バイトか2バイトです。そのようなバイト数を文字集
合の"次元"（dimension）と呼びます。

 -- Function: charset-dimension CHARSET
     この関数は、文字集合CHARSETの次元を返す。現在、次元はつねに1か2で
     ある。

文字集合の導入列のバイト長を判定するもっとも簡単な方法はつぎのとおりで
す。

     (- (char-bytes (make-char CHARSET))
        (charset-dimension CHARSET))



File: elisp-ja, Node: Splitting Characters, Next: Scanning Charsets, Prev: Chars and Bytes, Up: Non-ASCII Characters

文字の分割
==========

本節の関数は、文字とそれを表現するために用いられるバイト値のあいだの変
換を行います。ほとんどの目的に関しては、Emacsが必要に応じて自動的に行う
ため、文字を表現するためのバイト列を扱う必要はありません。

 -- Function: char-bytes CHARACTER
     この関数は、文字CHARACTERを表現するために必要なバイト数を返す。こ
     れは、文字CHARACTERが属する文字集合だけに依存し、その文字集合
     （*Note Character Sets::）の次元とその導入列の和に等しい。

          (char-bytes 2248)
               => 2
          (char-bytes 65)
               => 1
          (char-bytes 192)
               => 1

     マルチバイト表現とユニバイト表現のどちらに対してもこの関数で正しい
     結果を得られるのは、2つの表現で用いられる非ASCII文字コードに重なり
     がないからである。

 -- Function: split-char CHARACTER
     文字CHARACTERの文字集合の名前に続けて、その文字集合でCHARACTERを識
     別する1バイトか2バイトの値（整数）から成るリストを返す。バイト値の
     個数はその文字集合の次元である。

          (split-char 2248)
               => (latin-iso8859-1 72)
          (split-char 65)
               => (ascii 65)

     ユニバイトの非ASCII文字は、文字集合`ascii'の一部とみなす。

          (split-char 192)
               => (ascii 192)

 -- Function: make-char CHARSET &rest BYTE-VALUES
     この関数は、文字集合CHARSETにおいてBYTE-VALUESで識別される文字を返
     す。これは、`split-char'のほぼ逆関数にあたる。通常、文字集合
     CHARSETの次元に応じて、1つか2つのBYTE-VALUESを指定する。たとえばつ
     ぎのとおり。

          (make-char 'latin-iso8859-1 72)
               => 2248

BYTE-VALUESを指定せずに`make-char'を呼び出すと、その結果は文字集合
CHARSETを代表する"汎用文字"（generic character）である。汎用文字は整数
であるが、文字としてバッファに挿入するには正しく*ない*ものである。1つの
文字集合全体を表すために`char-table-range'で使える（*Note
Char-Tables::）。`char-valid-p'は汎用文字に対しては`nil'を返す。たとえ
ばつぎのとおり。

     (make-char 'latin-iso8859-1)
          => 2176
     (char-valid-p 2176)
          => nil
     (split-char 2176)
          => (latin-iso8859-1 0)



File: elisp-ja, Node: Scanning Charsets, Next: Translation of Characters, Prev: Splitting Characters, Up: Non-ASCII Characters

文字集合の走査
==============

バッファや文字列の一部分にどの文字集合が現れるかを調べられると有用なこ
とがあります。その1つの用途は、当該テキストすべてを表現する能力があるコー
ディングシステム（*Note Coding Systems::）を探すことです。

 -- Function: find-charset-region BEG END &optional TRANSLATION
     この関数は、カレントバッファのBEGとENDのあいだに現れる文字集合のリ
     ストを返す。

     省略可能な引数TRANSLATIONは、テキストを走査するときに使用する変換
     表を指定する（*Note Translation of Characters::）。これが`nil'以外
     であると、領域内の各文字をこの表を介して変換し、戻り値は、バッファ
     内の実際の文字のかわりに変換した文字に関する情報を与える。

 -- Function: find-charset-string STRING &optional TRANSLATION
     この関数は、文字列STRINGに現れる文字集合のリストを返す。

     省略可能な引数TRANSLATIONは変換表を指定する。上記の
     `find-charset-region'を参照。



File: elisp-ja, Node: Translation of Characters, Next: Coding Systems, Prev: Scanning Charsets, Up: Non-ASCII Characters

文字の変換
==========

"変換表"（translation table）は、文字群を文字群へ対応付けます。これらの
表は、符号化と復号化、他の目的に使われます。独自の変換表を指定するコー
ディングシステムもあります。他のすべてのコーディングシステムに適用され
るデフォルトの変換表もあります。

 -- Function: make-translation-table TRANSLATIONS
     この関数は、引数TRANSLATIONSに基づいた変換表を返す。引数
     TRANSLATIONSの各要素は、`(FROM . TO)'の形であり、文字FROMをTOへ変
     換することを意味する。

     1つの文字集合全体を同じ次元の別の文字集合へ対応付けることも可能である。
     それには、FROMに（文字集合を表す）汎用文字を指定する
     （*Note Splitting Characters::）。
     この場合、TOも、同じ次元の別の文字集合の汎用文字であること。
     こうすると、この変換表は、FROMの文字集合の各文字を
     TOの文字集合の対応する文字へ変換する。

復号化では、もとの復号化結果の文字に変換表による変換を適用します。
コーディングシステムに属性`character-translation-table-for-decode'が
あれば、これは使用する変換表を指定します。
さもなければ、`standard-character-translation-table-for-decode'が
`nil'以外であれば、復号化ではその表を使います。

符号化では、バッファ内の文字に変換表による変換を適用し、変換結果を実際
に符号化します。コーディングシステムに属性
`character-translation-table-for-encode'があれば、これは使用する変換表
を指定します。さもなければ、変数
`standard-character-translation-table-for-encode'が使用する変換表を指定
します。

 -- Variable: standard-character-translation-table-for-decode
     これは、変換表を指定しないコーディングシステムに対する復号化時のデ
     フォルトの変換表である。

 -- Variable: standard-character-translation-table-for-encode
     これは、変換表を指定しないコーディングシステムに対する符号化時のデ
     フォルトの変換表である。



File: elisp-ja, Node: Coding Systems, Next: Input Methods, Prev: Translation of Characters, Up: Non-ASCII Characters

コーディングシステム
====================

Emacsがファイルを読み書きしたり、Emacsがサブプロセスへテキストを送った
りサブプロセスからテキストを受け取るときには、"コーディングシステム
（coding system）で指定される文字コード変換と行末変換を行います。

* Menu:

* Coding System Basics::
* Encoding and I/O::
* Lisp and Coding Systems::
* User-Chosen Coding Systems::
* Default Coding Systems::
* Specifying Coding Systems::
* Explicit Encoding::
* Terminal I/O Encoding::
* MS-DOS File Types::



File: elisp-ja, Node: Coding System Basics, Next: Encoding and I/O, Prev: Coding Systems, Up: Coding Systems

コーディングシステムの基本概念
------------------------------

"文字コード変換"（character code conversion）とは、Emacsの内部で使用す
る符号と他の符号とのあいだでの変換のことです。Emacsでは、相互に変換でき
る多くの異なる符号を扱えます。たとえば、Emacsは、Latin 1、Latin 2、
Latin 3、Latin 4、Latin 5、ISO 2022のいくつかの変種を相互に変換できます。
同じ文字集合に対する異なる符号を扱うこともできます。たとえば、キリル
（ロシア語）文字に対してはISO、Alternativnyj、KOI8の3つのコーディングシ
ステムがあります。

ほとんどのコーディングシステムでは変換する文字コードを特定しますが、指
定せずにデータに基づいて発見的手法で選ぶものもあります。

"行末変換"（end of line conversion）は、ファイル内の行の終りを表すさま
ざまなシステムで使われている3つの異なる慣習を扱います。UNIXの慣習では、
行送り文字（改行文字とも呼ぶ）を使います。DOSの慣習では、行末には復帰と
行送りの2文字の列を使います。Macの慣習では、復帰のみを使います。

`latin-1'のような"基底コーディングシステム"（base coding system）では、
行末変換を指定せずにデータに基づいて選びます。`latin-1-unix'、
`latin-1-dos'、`latin-1-mac'のような"変種コーディングシステム
（variant coding system）では、明示的に行末変換も指定します。ほとんどの
基底コーディングシステムには、`-unix'、`-dos'、`-mac'を付加して作られる
名前の対応する3つの変種があります。

コーディングシステム`raw-text'は文字コード変換を行わない特別なもので、
このコーディングシステムで訪問したバッファはユニバイトバッファになりま
す。行末変換も指定しないので内容に基づいて決定でき、行末変換を指定する
3つの変種もあります。`no-conversion'は`raw-text-unix'に等価であり、文字
コードも行末も変換しないことを指定します。

コーディングシステム`emacs-mule'は、Emacs内部での符号でデータを表現する
ことを指定します。これは、コード変換を行わないという意味では`raw-text'
に似ていますが、結果がマルチバイトデータになる点が異なります。

 -- Function: coding-system-get CODING-SYSTEM PROPERTY
     この関数は、コーディングシステムCODING-SYSTEMの指定した属性を返す。
     コーディングシステムのほとんどの属性は内部目的用であるが、読者が有
     用と思うものが1つ、`mime-charset'がある。この属性の値は、当該コー
     ディングシステムで読み書きする文字コード向けのMIMEに使用する名前で
     ある。

          (coding-system-get 'iso-latin-1 'mime-charset)
               => iso-8859-1
          (coding-system-get 'iso-2022-cn 'mime-charset)
               => iso-2022-cn
          (coding-system-get 'cyrillic-koi8 'mime-charset)
               => koi8-r

     属性`mime-charset'の値は、コーディングシステムの別名としても定義さ
     れている。



File: elisp-ja, Node: Encoding and I/O, Next: Lisp and Coding Systems, Prev: Coding System Basics, Up: Coding Systems

符号化と入出力
--------------

コーディングシステムの主目的は、ファイルの読み書きに使うことです。関数
`insert-file-contents'はファイルのデータを復号化するためにコーディング
システムを使い、`write-region'はバッファ内容を符号化するためにコーディ
ングシステムを使います。

使用するコーディングシステムを明示する（*Note Specifying Coding
Systems::）こともできるし、デフォルトの機構（*Note Default Coding
Systems::）を暗に使うこともできます。しかし、これらの方式ではすべきこと
を完全に指定しきれないこともあります。たとえば、`undefined'のようなコー
ディングシステムを選んで、データに基づいて文字コード変換を行うようにす
るかもしれません。そのような場合、コーディングシステムの選択は入出力操
作によって完了します。しばしば、選択されたコーディングシステムをあとで
知りたくなります。

 -- Variable: buffer-file-coding-system
     この変数は、カレントバッファで訪問するときに使用したコーディングシ
     ステムを記録する。これは、バッファを保存したり、`write-region'でバッ
     ファの一部を書くときに使われる。これらの操作において、ユーザーに別
     のコーディングシステムを指定するように問い合わせた場合には、
     `buffer-file-coding-system'は指定された別のコーディングシステムに
     更新される。

 -- Variable: save-buffer-coding-system
     この変数は、`write-region'には使わないが、バッファを保存するために
     使うコーディングシステムを指定する。バッファを保存する際に、ユーザー
     に別のコーディングシステムを指定するように問い合わせ、かつ、
     `save-buffer-coding-system'を用いている場合には、これは指定された
     別のコーディングシステムに更新される。

 -- Variable: last-coding-system-used
     ファイルやサブプロセスに対する入出力操作では、使用したコーディング
     システム名をこの変数に設定する。明示的に符号化／復号化する関数
     （*Note Explicit Encoding::）もこの変数に設定する。

     *警告：*` ' サブプロセスから出力を受け取るとこの変数が設定されるた
     め、Emacsが待つたびに変化する可能性がある。したがって、読者の興味
     がある値を保存するような関数を呼び出した直後にその値をコピーして使
     うこと。

変数`selection-coding-system'は、
ウィンドウシステムのセレクションを符号化する方法を指定します。
*Note Window System Selections::。



File: elisp-ja, Node: Lisp and Coding Systems, Next: User-Chosen Coding Systems, Prev: Encoding and I/O, Up: Coding Systems

Lispにおけるコーディングシステム
--------------------------------

コーディングシステムを扱うLispの機能について述べます。

 -- Function: coding-system-list &optional BASE-ONLY
     この関数は、すべてのコーディングシステム名（シンボル）のリストを返
     す。BASE-ONLYが`nil'以外であると、値には基底コーディングシステムの
     みを含める。さもなければ、値には変種コーディングシステムも含まれる。

 -- Function: coding-system-p OBJECT
     この関数は、OBJECTがコーディングシステム名であると`t'を返す。

 -- Function: check-coding-system CODING-SYSTEM
     この関数は、CODING-SYSTEMの正当性を調べる。正しいものならば
     CODING-SYSTEMを返す。さもなければ、条件`coding-system-error'付きの
     エラーを通知する。

 -- Function: coding-system-change-eol-conversion CODING-SYSTEM EOL-TYPE
     この関数は、CODING-SYSTEMに類似のコーディングシステムを返すが、
     `eol-type'で指定された行末変換のものである。EOL-TYPEは、`unix'、
     `dos'、`mac'、`nil'のいずれかであること。`nil'であると、返されたコー
     ディングシステムは、データから行末変換を決定する。

 -- Function: coding-system-change-text-conversion EOL-CODING TEXT-CODING
     この関数は、行末変換にEOL-CODINGを使い、
     テキストの変換にTEXT-CODINGを使っているコーディングシステムを返す。
     TEXT-CODINGが`nil'であると、
     `undecided'かEOL-CODINGに応じた`undecided'の変種の1つを返す。

 -- Function: find-coding-systems-region FROM TO
     この関数は、FROMとTOのあいだのテキストの符号化に使用できるコーディ
     ングシステムのリストを返す。リスト内のすべてのコーディングシステム
     は、当該部分のテキストのどんなマルチバイト文字も安全に符号化できる。

     テキストにマルチバイト文字が含まれない場合、関数はリスト
     `(undecided)'を返す。

 -- Function: find-coding-systems-string STRING
     この関数は、文字列STRINGのテキストの符号化に使用できるコーディング
     システムのリストを返す。リスト内のすべてのコーディングシステムは、
     STRINGのどんなマルチバイト文字も安全に符号化できる。テキストにマル
     チバイト文字が含まれない場合、これはリスト`(undecided)'を返す。

 -- Function: find-coding-systems-for-charsets CHARSETS
     この関数は、リストCHARSETS内のすべての文字集合の符号化に使用できる
     コーディングシステムのリストを返す。

 -- Function: detect-coding-region START END &optional HIGHEST
     この関数は、STARTからENDまでのテキストを復号化するもっともらしいコー
     ディングシステムを選ぶ。このテキストは『生のバイト』（*Note
     Explicit Encoding::）であること。

     この関数は、通常、走査したテキストの復号化を扱えるコーディングシス
     テムのリストを返す。それらは優先順位の降順に並ぶ。しかし、HIGHEST
     が`nil'以外であると、戻り値はもっとも順位の高い1つのコーディングシ
     ステムである。

     領域にASCII文字だけが含まれる場合、値は`undecided'か`(undecided)'
     である。

 -- Function: detect-coding-string STRING HIGHEST
     この関数は`detect-coding-region'と同様であるが、バッファ内のバイト
     のかわりに文字列STRINGの内容に作用する。

サブプロセスとの入出力に使用されるコーディングシステムを調べたり設定す
る方法については、*Note Process Information::。



File: elisp-ja, Node: User-Chosen Coding Systems, Next: Default Coding Systems, Prev: Lisp and Coding Systems, Up: Coding Systems

ユーザー指定のコーディングシステム
----------------------------------

 -- Function: select-safe-coding-system FROM TO &optional PREFERRED-CODING-SYSTEM
     この関数はFROMとTOのあいだのテキストを符号化するコーディングシステ
     ムを選ぶが、必要ならばユーザーに問い合わせる。

     省略可能な引数PREFERRED-CODING-SYSTEMは、
     最初に試すコーディングシステムを指定する。
     それが指定領域のテキストを処理できるならば、それを使う。
     この引数を省略すると、
     `buffer-file-coding-system'のカレントバッファでの値をまず試す。

     領域内にPREFERRED-CODING-SYSTEMで符号化できないマルチバイト文字が
     ある場合、この関数は、当該テキストを符号化可能なコーディングシステ
     ム一覧からユーザーに選択してもらい、ユーザーが選択したものを返す。

     特殊機能：` 'FROMが文字列であると、文字列を調べる対象とし、TOは無
     視する。

補完を用いてユーザーにコーディングシステムを指定させるために使える
2つの関数はつぎのとおりです。
*Note Completion::。

 -- Function: read-coding-system PROMPT &optional DEFAULT
     この関数は、文字列PROMPTをプロンプトとしてミニバッファを使ってコー
     ディングシステムを読み取り、コーディングシステム名をシンボルとして
     返す。ユーザーの入力が空であると、DEFAULTは返すべきコーディングシ
     ステムを指定する。それはシンボルか文字列であること。

 -- Function: read-non-nil-coding-system PROMPT
     この関数は、文字列PROMPTをプロンプトとして
     ミニバッファを使ってコーディングシステムを読み取り、
     コーディングシステム名をシンボルとして返す。
     ユーザーが空を入力しようとすると再度問い合わせる。
     *Note Coding Systems::。



File: elisp-ja, Node: Default Coding Systems, Next: Specifying Coding Systems, Prev: User-Chosen Coding Systems, Up: Coding Systems

デフォルトのコーディングシステム
--------------------------------

本節では、特定のファイルや特定のサブプログラムを実行するときのデフォル
トのコーディングシステムを指定する変数と、それらを使った入出力操作を行
う関数について述べます。

これらの変数の目的は、読者が望むデフォルトをいったんこれらに設定してお
けば、再度変更する必要がないようにすることです。Lispプログラムの特定の
操作向けに特定のコーディングシステムを指定するには、これらの変数を変更
しないでください。かわりに、`coding-system-for-read'や
`coding-system-for-write'を使って上書きします（*Note Specifying Coding
Systems::）。

 -- Variable: file-coding-system-alist
     この変数は、特定のファイルの読み書きに使用する
     コーディングシステムを指定する連想リストである。
     各要素は`(PATTERN . CODING)'の形であり、
     PATTERNは特定のファイル名に一致する正規表現である。
     PATTERNに一致するファイル名に当該要素を適用する。

     要素のCDR、CODINGはコーディングシステムであるか、2つのコーディング
     システムを収めたコンスセルであるか、関数シンボルであること。
     CODINGがコーディングシステムであると、ファイルの読み書きの両方にそ
     のコーディングシステムを使う。CODINGが2つのコーディングシステムを
     収めたコンスセルであると、そのCARは復号化に使うコーディングシステ
     ムを指定し、そのCDRは符号化に使うコーディングシステムを指定する。

     CODINGが関数シンボルであると、その関数は、コーディングシステムか、
     2つのコーディングシステムを収めたコンスセルを返すこと。その値は上
     に述べたように使われる。

 -- Variable: process-coding-system-alist
     この変数は、サブプロセスで実行しているプログラムに依存してサブプロ
     セスに使うコーディングシステムを指定する連想リストである。
     `file-coding-system-alist'と同様に働くが、PATTERNはサブプロセスを
     始めるために用いたプログラム名に対して一致を取る点が異なる。この連
     想リストに指定したコーディングシステムは、サブプロセスとの入出力に
     使用するコーディングシステムの初期化に用いれるが、
     `set-process-coding-system'を使って、あとで別のコーディングシステ
     ムを指定できる。

*警告：*` ' データからコーディングシステムを決定する`undecided'のような
コーディングシステムは、非同期サブプロセスの出力に対しては完全に信頼性
のある動作はできない。これは、Emacsが非同期サブプロセスの出力が到着する
たびに一塊で処理するからである。コーディングシステムが文字コード変換や
行末変換を未指定にしていると、Emacsは1つの塊から正しい変換を検出しよう
と試みるが、これがつねに動作するとは限らない。

したがって、非同期サブプロセスでは、可能な限り
文字コード変換と行末変換の両方を指定したコーディングシステムを使います。
つまり、`undecided'や`latin-1'などではなく、
`latin-1-unix'のようなものを使います。

 -- Variable: network-coding-system-alist
     この変数は、ネットワークストリームに使用するコーディングシステムを
     指定する連想リストである。`file-coding-system-alist'と同様に働くが、
     要素内のPATTERNはポート番号か正規表現である点が異なる。それが正規
     表現であると、ネットワークストリームを開くために使用したネットワー
     クサービス名に対して一致をとる。

 -- Variable: default-process-coding-system
     この変数は、なにも指定されていないサブプロセス（やネットワークスト
     リーム）の入出力に使用するコーディングシステムを指定する。

     値は、`(INPUT-CODING . OUTPUT-CODING)'の形の
     コンスセルであること。
     ここで、INPUT-CODINGはサブプロセスからの入力に適用され、
     OUTPUT-CODINGはそれへの出力に適用される。

 -- Function: find-operation-coding-system OPERATION &rest ARGUMENTS
     この関数は、ARGUMENTSを指定してOPERATIONを行うときに（デフォルトで）
     使用されるコーディングシステムを返す。その値はつぎの形である。

          (DECODING-SYSTEM ENCODING-SYSTEM)

     第1要素DECODING-SYSTEMは（OPERATIONが復号化を行う場合には）復号化
     に用いるコーディングシステムであり、ENCODING-SYSTEMは（OPERATIONが
     符号化を行う場合には）符号化に用いるコーディングシステムである。

     引数OPERATIONは、Emacsの入出力基本関数の
     `insert-file-contents'、`write-region'、`call-process'、
     `call-process-region'、`start-process'、
     `open-network-stream'のいずれかであること。

     残りの引数は、これらの入出力基本関数に指定するであろう引数と同じであること。
     基本関数に依存して、引数の1つを"対象"として選ぶ。
     たとえば、OPERATIONがファイル入出力を行う場合、
     ファイル名を指定する引数が対象である。
     サブプロセスの基本関数では、プロセス名が対象である。
     `open-network-stream'では、サービス名やポート番号が対象である。

     この関数は、OPERATIONに応じて当該対象を
     `file-coding-system-alist'や
     `process-coding-system-alist'や
     `network-coding-system-alist'で探す。
     *Note Default Coding Systems::。



