Info file: gnus-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gnus-ja.texi'
using `texinfmt.el' version 2.41 of  1 Mar 2005.

Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
2004, 2005, 2006 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover
     texts being "A GNU Manual", and with the Back-Cover Texts as in
     (a) below.  A copy of the license is included in the section
     entitled "GNU Free Documentation License" in the Emacs manual.

     この文書を、フリーソフトウェア財団発行の GNU フリー文書利用許諾契
     約書第 1.2 版またはそれ以降の版が定める条件の下で複製、配布、ある
     いは変更することを許可します。変更不可部分は指定しません。“A GNU
     Manual”は表表紙テキスト、以下の (a) は裏表紙テキストです。この利
     用許諾契約書の複写は“Emacs manual”の「GNU フリー文書利用許諾契約
     書」という章に含まれています。

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."

     (a) FSF の裏表紙テキスト:「あなたにはこの GNU Manual を GNU ソフト
     ウェアのように複製したり変更する自由があります。複製はフリーソフト
     ウェア財団によって出版されました。(フリーソフトウェア財団は) GNU
     の開発のために必要な資金を集めています。」

     This document is part of a collection distributed under the GNU
     Free Documentation License.  If you want to distribute this
     document separately from the collection, you can do so by adding
     a copy of the license to the document, as described in section 6
     of the license.

     この文書は「GNU フリー文書利用許諾契約書」に基づいて配布された収集
     著作物の一部です。もしあなたがこの文書を収集著作物から分離して配布
     したいときは、契約書の第 6 章に記述されているように、文書に契約書
     の複写を付加することによって、行なうことができます。



INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Gnus-ja: (gnus-ja).           The newsreader Gnus (Japanese).
END-INFO-DIR-ENTRY





File: gnus-ja.info, Node: Running NNDiary, Next: Customizing NNDiary, Prev: Diary Messages, Up: The NNDiary Back End

NNDiary を動かす
................

`nndiary' には二つの動作モードがあります。一つはディフォルトの「伝統型
(traditional)」、もう一つは「自律型 (autonomous)」です。伝統型のモード
では、`nndiary' はそれ自身が新着メールを取得することはありません。日程
メッセージとして扱うために、あなたはメールを基本のメール・バックエンド
から nndiary グループに、移動 (`B m') またはコピー (`B c') しなければな
りません。自律型のモードでは、`nndiary' はそれ自身のメールを取ってきて、
基本のメール・バックエンドとは独立してそれを扱います。

本質的に Gnus は、同時に複数の「マスター」メール・バックエンドを許容す
るようには設計されていなことに注意すべきです。しかし `nndiary' では、こ
れは意味をなします。あなたは本当に、日程メッセージを日程グループに直接
送って、それらを受け取りたいのです。そこで `nndiary' は、まさに「二番目
の第一メール・バックエンド」をサポートします (私が知っている限り、それ
はこの機能を提供する唯一のバックエンドです)。しかしながら制約があって
(いつの日にか解消することを願いますが)、自律型のモードでは再スプールが
できません。

自律型のモードで `nndiary' を使うためには、いくつかのことをやってもらわ
なければなりません:

   * 新着メールを `nndiary' が自分で取り込めるようにします。以下の行を
     `~/.gnus.el' ファイルに記入して下さい:

          (setq nndiary-get-new-mail t)

   * 日程メッセージ (`X-Diary-*' ヘッダーを含んでいる) が、Gnus がそれ
     らを処理する *前* に専用のフォルダーに分配されるように、準備を行な
     わなければなりません。繰り返しますが、Gnus が複数の第一メール・バッ
     クエンドを適切に扱うことが (まだ ?) できないので、これが必要です。
     別々のソースからそれらのメッセージを取り込むことによって、この欠点
     はある程度補われます。

     日程ファイルを `~/.nndiary' (これがディフォルトの `nndiary' のメー
     ルソース・ファイルです) に格納するための procmailrc の項目の例です:

          :0 HD :
          * ^X-Diary
          .nndiary

いったんこれを実施したら、日程メールの取り込みと分割の処理に影響する、
以下の二つのオプションをカスタマイズする必要があるでしょう:

 -- Variable: nndiary-mail-sources
     標準の `mail-sources' 変数の、日程用に特化した代替品です。同じ構文
     (syntax) を使い、ディフォルトは `(file :path "~/.nndiary")' です。

 -- Variable: nndiary-split-methods
     標準の `nnmail-split-methods' 変数の、日程用に特化した代替品です。
     同じ構文 (syntax) を使います。

最終的には `gnus-secondary-select-methods' に、恒久的な `nndiary' 仮想
サーバー (`(nndiary "diary")' が行なうべきであるようなもの) を追加して
も良いでしょう。

うまくいけば、Gnus を再起動すると、ほとんどすべて (`nndiary.el' の
TODO の項を参照) が期待通りに動作するでしょう。自律型のモードでは、`g'
や `M-g' をグループバッファーでタイプすれば新しい日程メールをも取り込ん
で、日程用に特化した規則に従ってそれらを分割するし、`F' は新しい日程グ
ループを見つけてくれる、など。



File: gnus-ja.info, Node: Customizing NNDiary, Prev: Running NNDiary, Up: The NNDiary Back End

NNDiary のカスタマイズ
......................

さあ `nndiary' が立ち上がって動作しています。それをカスタマイズするとき
が来ました。カスタマイズするためのグループは `nndiary' です (へえー)。
どのオプションをカスタマイズし倒したいかを見つけるために、それに目を通
して下さい。あなたが変更したいのは、おそらく以下のたった二つの変数でしょ
う:

 -- Variable: nndiary-reminders
     予定を思い出させてもらいたい時刻のリスト (例えば三週間前、それから
     二日前、それから一時間前、そしてそのとき) です。「思い出させてもら
     う」の意味は、新着メールを取り込んだときに、日程メッセージが真新し
     く未読になって、ポップアップすることであることを思い出して下さい。

 -- Variable: nndiary-week-starts-on-monday
     読んで字の如し。さもなくば日曜日が仮定されます (それがディフォルト
     です)。



File: gnus-ja.info, Node: The Gnus Diary Library, Next: Sending or Not Sending, Prev: The NNDiary Back End, Up: Email Based Diary

Gnus Diary ライブラリー
-----------------------

`nndiary' を手作業で使うこと (ヘッダーを手で書くことなど) は、いささか
うんざりします。幸い `nndiary' の上位階層に書かれた `gnus-diary' という
ライブラリーがあって、たくさんの便利なことをやってくれます。

それを使うためには、以下の行を `~/.gnus.el' ファイルに加えて下さい:

     (require 'gnus-diary)

さらに、どんな `gnus-user-format-function-[d|D]' (*Note Summary Buffer
Lines::) も、使ってはいけません。`gnus-diary' はそれらの両方を提供しま
す (あなたがそれらを使っていたら、すみません)。

* Menu:

* Diary Summary Line Format::   より良い概略行仕様
* Diary Articles Sorting::      メッセージを並べ替える気の利いた方法
* Diary Headers Generation::    手作業でそれをしないで
* Diary Group Parameters::      手作業でそれらを扱わないで



File: gnus-ja.info, Node: Diary Summary Line Format, Next: Diary Articles Sorting, Prev: The Gnus Diary Library, Up: The Gnus Diary Library

日程の概略行仕様
................

標準の概略行仕様 (通常 `From Joe: Subject' のようなもの) で日程メッセー
ジを表示するのは、まったく役に立ちません。たいていはあなたがメッセージ
を書いた人で、おおかた予定の日付を見たいと思っているでしょう。

`gnus-diary' は、概略行仕様で使う二つの追加の利用者定義の書法仕様を提供
します。`D' は次の予定が生じるときのための整形された時刻表示 (例えば
“Sat, Sep 22 01, 12:00”) を表すのに対して、`d' は次の予定が生じるまで
のおおよその残り時間 (例えば“in 6 months, 1 week”) を表します。

ジョーの誕生日が、概略行にどう表示されるかの例です (定期的な予定を指定
すると消されないことを除いて、メッセージが期限切れ消去可能であることに
気を付けて下さい):

        E  Sat, Sep 22 01, 12:00: Joe's birthday (in 6 months, 1 week)

上記のようなものを得るために、普段だったら、あなたは以下の行を日程グルー
プのパラメーターに加えようとするでしょう:

     (gnus-summary-line-format "%U%R%z %uD: %(%s%) (%ud)\n")

しかし `gnus-diary' はそれを自動で行ないます (*Note Diary Group
Parameters::)。それでもあなたは、以下のユーザー・オプション群で提供され
る概略行仕様を、カスタマイズすることができます:

 -- Variable: gnus-diary-summary-line-format
     日程グループのために使われる概略行仕様を定義します (*Note Summary
     Buffer Lines::)。`gnus-diary' はそれを、日程グループのパラメーター
     を自動で更新するために使います。

 -- Variable: gnus-diary-time-format
     日程の概略バッファーに日付を表示するための書法仕様を定義します。こ
     れは利用者定義の書法仕様 `D' で使われます。詳細は変数の説明文を見
     て下さい。

 -- Variable: gnus-diary-delay-format-function
     日程の概略バッファーに遅延 (残り時間) を表示するための整形関数を定
     義します。これは利用者定義の書法仕様 `d' で使われます。現在は英語
     とフランス語のための組み込み関数があり、自分で定義することもできま
     す。詳細は変数の説明文を見て下さい。



File: gnus-ja.info, Node: Diary Articles Sorting, Next: Diary Headers Generation, Prev: Diary Summary Line Format, Up: The Gnus Diary Library

日程記事の並べ替え
..................

`gnus-diary' は並べ替え (*Note Sorting the Summary Buffer::) のために
`gnus-summary-sort-by-schedule'、`gnus-thread-sort-by-schedule' および
`gnus-article-sort-by-schedule' という新しい関数を提供します。これらの
関数によって、最も近い予定から最も遠い方まで、日程の概略バッファーを整
理することができます。

`gnus-diary' は自動的に概略バッファーの「並べ替え (sort)」メニューに
`gnus-summary-sort-by-schedule' を組み込み、他の二つを第一次の (ゆえに
ディフォルトの) 並べ替え関数として、グループパラメーター (*Note Diary
Group Parameters::) に登録します。



File: gnus-ja.info, Node: Diary Headers Generation, Next: Diary Group Parameters, Prev: Diary Articles Sorting, Up: The Gnus Diary Library

日程ヘッダーの生成
..................

`gnus-diary' は、`X-Diary-*' ヘッダーの取り扱いを補佐するために、
`gnus-diary-check-message' という関数を提供します。この関数は、現在のメッ
セージがすべての必要な日程ヘッダーを確実に含むようにして、必要ならば値
を入力するか修正することを要求します。

記事を日程グループに移動またはコピーすることによって自動的にそれが発動
されるようにするために、この関数は `nndiary' バックエンドのフックとして
組み入れられています。それはさらに、通常のメールを日程用のものに変換す
る操作を簡単にするために、`message-mode' と `article-edit-mode' におい
て `C-c D c' キーとして設定もされています。

接頭引数を伴ってこの関数を呼ぶと、それらがあるか、正しいかどうかとは無
関係に、日程ヘッダーの入力を強制します。そうやって、例えばすでに正しく
設定されたメッセージの日程を、とても簡単に変更することができます。



File: gnus-ja.info, Node: Diary Group Parameters, Prev: Diary Headers Generation, Up: The Gnus Diary Library

日程グループのパラメーター
..........................

新しい日程グループを作るか、またはそれを開くと、`gnus-diary' は自動的に
グループパラメーターを検査し、必要なら概略行仕様を日程用に特化した値に
設定し、日程用の並べ替え関数を組み込み、さらにそのグループの投稿様式
(posting-style) に種々の `X-Diary-*' ヘッダーを加えます。そして、日程メッ
セージを送るのは、もっと簡単です。メッセージを用意するために、日程グルー
プで `C-u a' か `C-u m' を使うことによって、これらのヘッダーが自動的に
挿入されるので (まだ適切な値で満たされていませんが)。



File: gnus-ja.info, Node: Sending or Not Sending, Prev: The Gnus Diary Library, Up: Email Based Diary

送信するべきか、しないべきか
----------------------------

さて、以上の説明を読んでくれたものとして、以下は `nndiary' でメールを送
信することに関する、二つの最後の注意事項です:

   * `nndiary' は *本当の* メール・バックエンドです。本当にあなたは本当
     の日程メッセージを本当に送ります。これは、日程メッセージを送ること
     によって、誰にでも (彼らが Gnus と `nndiary' を使っているのならば)
     予定を伝えることができることをも意味します。
   * しかしながら `nndiary' は `request-post' メソッドを持ってもいるの
     で、日程グループで `C-u m' の代わりに `C-u a' を使うことによって、
     メッセージを実際に送信するのではなく、そのグループにローカルに格納
     することもできます。これは個人的な予定のためには、とても役に立ちま
     す。



File: gnus-ja.info, Node: Gnus Unplugged, Prev: Email Based Diary, Up: Select Methods

Gnus の切り離し
===============

いにしえの時代 (およそ 1988年2月頃)、人々はニュースリーダーをネットワー
クに常時接続した大きなマシンで走らせていました。ニュースの配送はニュー
スサーバーによって取り扱われ、すべてのニュースリーダーがすべきことは
ニュースを読むことであったのです。信じられないかもしれませんが。

今日では多くの人々は自宅でニュースやメールを読み、ネットワークに接続す
るためにモデムの類を使います。電話代の請求書が莫大なものに上らないよう
に、すべてのニュースとメールをすすり込んで電話を切り、数時間かけて読ん
でから送りたい返信をすべて送信する、という手段を持つことは良いことでしょ
う。あとはこの手順を繰り返すのです。(訳注: この章の前身は 1997年頃に書
かれました。)

もちろん、これを行なうためにニュースサーバーを使うこともできます。私は
`inn' を `slurp', `pop', `sendmail' と一緒にここ数年使ってきましたが、
しかしこれは退屈な仕事です。もしあるマシン上でニュースを読む人があなた
しかいなければ、ニュースサーバーの機能をニュースリーダーに任せるように
することは理にかなっています。

Gnus を「オフライン」のニュースリーダーとして仕立てるのは極めて簡単です。
実際、エージェントは今やディフォルトで有効になっている (*Note
gnus-agent: Agent Variables.) ので、あなたは何も設定する必要が無いので
す。

もちろん、これをそんなふうに使うには、いくつか新しい命令を覚えなくては
なりません。

* Menu:

* Agent Basics::                これらはどう動くのか
* Agent Categories::            何をダウンロードするかを Gnus エージェントに教える方法
* Agent Commands::              各バッファーでの新しい命令
* Agent Visuals::               概略バッファーが変化するかもしれないエージェントの所業
* Agent as Cache::              エージェントは大きなキャッシュでもある
* Agent Expiry::                古い記事を追い払う方法
* Agent Regeneration::          通信切断や他の事故から回復する方法
* Agent and flags::             エージェントはどうフラグを維持するのか
* Agent and IMAP::              エージェントを IMAP で使う方法
* Outgoing Messages::           ニュースやメールを出すときになにが起こるのか?
* Agent Variables::             カスタマイズは楽し
* Example Setup::               オフライン人間のための `~/.gnus.el' の例
* Batching Agents::             `cron' ジョブでニュースを取得する方法
* Agent Caveats::               あなたが予想することと、それが実際にすること



File: gnus-ja.info, Node: Agent Basics, Next: Agent Categories, Prev: Gnus Unplugged, Up: Gnus Unplugged

エージェントの基礎
------------------

まず、いくつかの用語を片付けておきましょう。

ネットワークとの接続を切っているとき (かつエージェントにそのことを知ら
さてあるとき)、Gnus エージェントは "unplugged" です、と言います。ネット
ワークとの接続が復活したら (かつ Gnus がそのことを知っていれば)、エージェ
ントは "plugged" です。

「ローカル」マシンとは、あなたがそこで作業しているもので、継続的にネッ
トワークに接続されているわけではありません。

「ダウンロード」とは、あなたのローカルマシンに、何かをネットワークから
取ってくることを意味します。「アップロード」はその逆をすることです。

ご存知のように Gnus はあなたがドジを踏むすべての機会を提供します。それ
を柔軟性と言う人もいます。さらに Gnus は大いにカスタマイズ可能で、それ
は利用者が、Gnus がどのように動作するかについて発言権を持っていることを
意味します。他のニュースリーダーは有無を言わずあなたにドジを踏ませるか
もしれませんが、Gnus ではあなたに選択権があります!

Gnus は実際には plugged または unplugged のどちらの状態にもありません。
もっと正確に言えば、サーバーごとにそれぞれの状態を持ちます。これは、い
くつかのサーバーが unplugged でも、他のサーバーは plugged になることが
できるということです。さらに、エージェントがいくつかのサーバーをまとめ
て無視する (それらを常に plugged になっているように見せかける) ようにも
できます。

さて、エージェントを unplugged にしたのに Gnus がネットに接続しているの
を疑問に思ったら、行なうべき次のステップはサーバーがすべてエージェント
化されているかどうかを確かめることです。エージェント化されていないサー
バーがあったら、あなたは犯人を見つけたのです。

もう一つは「オフライン」という状態です。サーバーはときどき接続できなく
なります。Gnus がこのことに気付くと、そのサーバーをオフラインの状態に切
り換えても良いかどうかを尋ねます。Yes と答えたならば (オンラインに戻し
て良いかと Gnus が尋ねた場合以外は)、サーバーはいくらか unplugged だっ
たときのように振る舞います。

エージェントを使った典型的な Gnus の対話操作を見てみましょう:

   * Gnus を `gnus-unplugged' で起動します。これは unplugged で Gnus エー
     ジェントを立ち上げます。このモードでは、すでに取得しているニュース
     記事はすべて読むことができます。

   * 次に、新しいニュースが到着しているかどうかを調べることにします。マ
     シンをネットワークに (PPP か何かを使って) 接続してから Gnus を
     plugged" にするために `J j' を叩き、いつものように新着メールを検査
     するために `g' を使います。Gnus エージェントが unplugged になって
     いるときに新着メールを検査するには、*Note Mail Source
     Specifiers:: を参照して下さい。

   * そうすれば、直ちに新しいニュースを読むこともできるし、ニュースをロー
     カルマシンにダウンロードすることもできます。後者を実行したいときは、
     `g' を押して新しいニュースがあるかどうかを検査し、次に `J s' です
     べてのグループのすべての適格な (訳注: あなたが指定した条件に合致す
     る) 記事を取得します。(どの記事をダウンロードしたいかを Gnus に指
     示するには *Note Agent Categories:: を参照して下さい。)

   * 記事を取得した後で `J j' を押し、Gnus を再び unplugged にして、
     PPP の接続 (か何か) を閉じます。その後でニュースをオフラインで読み
     ます。

   * そして第二ステップに戻ります。

エージェントを初めて使うときは (またはそのくらいの時期に)、以下のいくつ
かの作業をしなければなりません。

   * どのサーバーをエージェントで面倒を見るかを決めます。メールのバック
     エンドをエージェントに面倒を見させるのはおそらく無意味でしょう。サー
     バーバッファーに移動し (グループバッファーで `^')、エージェントに
     扱って欲しいサーバー (複数可) で `J a' を押す (*Note Server Agent
     Commands::) か、またはエージェントに扱って欲しくないのに自動的に追
     加されたサーバーで `J r' を押します。ディフォルトでは
     `gnus-select-method' と `gnus-secondary-select-methods' にあるすべ
     ての `nntp' と `nnimap' サーバーがエージェント化されます。

   * ダウンロード方針を決定します。あなたの方針を実装するために、エージェ
     ント分類、トピックパラメーター、グループパラメーターのどれを使うか
     をいったん決めてしまえば、これはかなり簡単です。あなたが Gnus の初
     心者ならば、たぶん分類で始めるのが最良でしょう、*Note Agent
     Categories::.

     トピックパラメーター (*Note Topic Parameters::) とエージェント分類
     (*Note Agent Categories::) の両方とも、多数のグループに適用する方
     針の設定を用意しています。どれを使うかは完全にあなたの責任です。両
     方を混ぜて使う場合は、トピックパラメーターは分類を無効にすることを
     考慮に入れなければならないでしょう。あなたの方針にそぐわない少数の
     グループがあるのならば、それらの設定を変更するためにグループパラメー
     ター (*Note Group Parameters::) を使うことができます。

   * ええと...、以上です。



File: gnus-ja.info, Node: Agent Categories, Next: Agent Commands, Prev: Agent Basics, Up: Gnus Unplugged

エージェント分類
----------------

ニュースを配送する機構をニュースリーダーに統合する主要な理由の一つは、
どの記事をダウンロードするかについて、もっと強力に制御できるようにする
ことです。莫大な量の記事をダウンロードすることにあまり意味はなく、それ
らを読んでもあまり面白くないことが分かるだけです。何をダウンロードする
かの選択ではもう少し保守的になって、その記事がやっぱり面白そうだとわかっ
たら、主動でダウンロードするための印を付ける方がすぐれています。

何をダウンロードするかを制御するためのより有効な方法の一つは、分類
("category") を作成して、その分類にいくつか (または全部) のグループを割
り当てることです。どんな分類にも属さないグループは「ディフォルト」の分
類に属します。Gnus は分類の作成と管理のための独自のバッファーを持ってい
ます。

もしそうしたければ、グループパラメーター (*Note Group Parameters::) と
トピックパラメーター (*Note Topic Parameters::) を、エージェントを制御
する代替手段に使うことができます。実際に違うのは、グループとトピックパ
ラメーターが何でもかんでも (kitchen sink) 含むのに対して、分類はエージェ
ントに特化している (したがってあまり学ばなくても良い) ということだけで
す。

エージェントパラメーターは複数の違う場所で設定することができるので、ど
のソースが信用できるかを決めるための規則を設けました。この規則は、パラ
メーターのソースが次の順序で調べられることを定めます: グループパラメー
ター、トピックパラメーター、エージェント分類、そして最後はカスタマイズ
できる変数群です。したがって、広い範囲で動作を起こさせるためにこれらの
ソースをすべて混合することができます。どこに設定を置いたのかを忘れてし
まったからといって、私を責めないで下さいよ。

* Menu:

* Category Syntax::             分類とはどんなものか
* Category Buffer::             分類を管理するバッファー
* Category Variables::          カスタマイザ"ら"ス



File: gnus-ja.info, Node: Category Syntax, Next: Category Buffer, Prev: Agent Categories, Up: Agent Categories

分類の文法
..........

分類は、名前、その分類に属するグループのリスト、およびカスタマイズ可能
な変数よりも優先される多くの任意なパラメーターから成ります。エージェン
トパラメーターの完全なリストを以下に示します。

`agent-groups'
     この分類にあるグループのリスト。

`agent-predicate'
     (通常) どの記事をダウンロードするのが適当かという大まかな輪郭を与
     える述語。そして

`agent-score'
     (通常) どの記事をダウンロードするかを決めるときのよりきめの細かい
     スコア規則。(このダウンロードスコア ("download score") は通常のス
     コアとは必ずしも関係が無いことに注意して下さい。)

`agent-enable-expiration'
     このグループの古い記事をエージェントが期限切れ消去すべきかどうかを
     示すブール変数。大抵のグループはディスク空間を浪費しないために期限
     切れ消去されるべきです。いや、実際には gnus.* 階層は期限切れ消去さ
     れるべきではないグループだけを含んでいると言っても、たぶん差し支え
     ありません。

`agent-days-until-old'
     既読の記事を期限切れ消去しても差し支えないことを判断する前に、エー
     ジェントが待っているべき日数を示す整数。

`agent-low-score'
     `gnus-agent-low-score' よりも優先される整数。

`agent-high-score'
     `gnus-agent-high-score' よりも優先される整数。

`agent-short-article'
     `gnus-agent-short-article' よりも優先される整数。

`agent-long-article'
     `gnus-agent-long-article' よりも優先される整数。

`agent-enable-undownloaded-faces'
     ダウンロードされていない記事を `gnus-summary-*-undownloaded-face'
     のフェース群を使って概略バッファーに表示すべきかどうかを示すシンボ
     ル。`nil' 以外ならどんなシンボルでも、ダウンロードされていない記事
     用のフェースを使うようになります。

いったん分類が作られたら、分類の名前を変えることはできません。

それぞれの分類は、その分類の排他的な (他の分類には無い) メンバーである
グループのリストを維持します。排他規則は自動的に執行され、新しい分類に
グループを追加すると、それは古い分類から自動的に取り除かれます。

述語の一番単純な形式は `true' や `false' のような単独の述語からなります。
これらの二つはそれぞれ、すべての可能な記事をダウンロードするか、まった
く何もしないか、です。これらの二つの特別な述語の場合は、追加のスコア規
則は不要です。

`high' や `low' という述語は下で説明されているように、
`gnus-agent-high-score' と `gnus-agent-low-score' との記事のスコアとの
関係により記事をダウンロードします。

何をもってダウンロードすることが適格だと見なされるかについて、さらに細
かい制御を得るために、述語は論理演算子が間に散りばめられた述語の組み合
わせからなることができます。

おそらくいくつかの例が必要でしょう。

以下は簡単な述語です。(これはディフォルトの述語です。実際に他のどの分類
にも含まれないすべてのグループに対して使用されます。)

     short

とっても簡単でしょ? この述語は、記事が短い (「短い」ことを意味する何ら
かの価値がある) 場合に限り真になります。

これはもっと複雑な述語です:

     (or high
         (and
          (not low)
          (not long)))

この意味は、高いスコアを持っているか、あるいはスコアが低くなくてかつ長
くない、という記事をダウンロードする、ということです。様子はわかりまし
たね。

使ってもよい論理演算子は `or', `and' および `not' です。(もし使いたけれ
ば、より“C”風の演算子 `|', `&', `!' を代りに使うことができます。)

以下の述語があらかじめ定義されていますが、これらのどれもあなたのやりた
いことに適さなければ、自分で独自のものを書くこともできます。

それぞれのこれらの述語を評価するとき、名前が付けられた定数は、適切なパ
ラメーターを与えて `gnus-agent-find-parameter' を呼ぶことによって決定さ
れる値に束縛されます。例えば gnus-agent-short-article は
`(gnus-agent-find-parameter group 'agent-short-article)' に束縛されます。
これは、あなたの分類で述語を指定してから、その述語を個々のグループにつ
いて調整できることを意味します。

`short'
     記事が `gnus-agent-short-article' の行数より短かい場合だけ真です。
     ディフォルトは 100 です。

`long'
     記事が `gnus-agent-long-article' の行数より長い場合だけ真です。ディ
     フォルトは 200 です。

`low'
     記事のダウンロードスコアが `gnus-agent-low-score' の値より小さい場
     合だけ真です。ディフォルトは 0 です。

`high'
     記事のダウンロードスコアが `gnus-agent-high-score' の値より大きい
     場合だけ真です。ディフォルトは 0 です。

`spam'
     Gnus エージェントがその記事を spam だと推測した場合だけ真です。こ
     の検出法は今後変更されるかもしれませんが。現時点では、これはチェッ
     クサムを計算し、記事が一致するかどうかを調べているだけです。

`true'
     常に真です。

`false'
     常に偽です。

独自の述語関数を作成したければ、このことを知っておかなければなりません:
関数は引数無しで呼び出されますが、`gnus-headers' と `gnus-score' という
動的な変数が有意な値に束縛されるということを。

例えば、一定の日数以上前に投稿された記事 (例えば
`gnus-agent-expire-days' の日数以上前に投稿されたもの) をダウンロードし
ないと決断することもできます。その場合、以下のような関数を書いて、

     (defun my-article-old-p ()
       "Say whether an article is old."
       (< (time-to-days (date-to-time (mail-header-date gnus-headers)))
          (- (time-to-days (current-time)) gnus-agent-expire-days)))

そして述語はこのように定義すれば良いでしょう:

     (not my-article-old-p)

もしくは `~/.gnus.el' か何かで、あらかじめ定義されている
`gnus-category-predicate-list' の値に、自分の述語を追加することもできま
す。

     (require 'gnus-agent)
     (setq gnus-category-predicate-alist
           (append gnus-category-predicate-alist
                   '((old . my-article-old-p))))

この場合は、次のように述語を指定するだけです:

     (not old)

上のようなものを使うときは、世の中には正しく設定されていないシステム/メー
ラーがあり、記事の日付はいつ投稿されたかを常に確実に示すわけではないこ
とを知っていて下さい。困ったことに、それを少しも気にかけない人もいるん
です。

上記の述語はその分類に属する *すべて* のグループに適用されます。しかし、
分類中の個々のグループのための特定の述語を設定したかったり、単に不精を
決め込んで新しい分類を設定したくないのならば、グループの個々の述語を次
のようにグループパラメーターに入れることができます:

     (agent-predicate . short)

これは agent 分類のディフォルトと等価なグループ/トピックパラメーターで
す。このように単一の語で述語を指定するときは、`agent-predicate' の設定
値はドット対で表記しなければならないことに注意して下さい。

上のものと等価な長い方の例はこうなるでしょう:

     (agent-predicate or high (and (not low) (not long)))

述語の値がドット対で表記されていなくて、その値はリストだと仮定されるの
で、分類の設定で要求される外側の括弧が、ここでは入れられません。

さて、ダウンロードスコアの文法は通常のスコアファイルの文法と同じですが、
例外があります。記事そのものを実際に調べる必要がある要素は厳禁です。つま
り、以下のヘッダーだけがスコア付けできるということです: `Subject',
`From', `Date', `Message-ID', `References',
`Chars', `Lines' および `Xref'。

述語の場合のように、`ダウンロードスコア規則' の設定は、それをグループに
関して使う限りは、そこのすべてのグループに適用できるものならば分類の定
義、グループに特有ならばグループパラメーター、のどちらかにできます。

これら両方の場所で、`ダウンロードスコア規則' は以下の三つの形式の一つを
取ることができます:

  1. スコア規則

     上で書かれているように、スコア付けキーワードの一部分しか使えないこ
     とを除けば、これは普通の Gnus スコアファイルの構文と同じです。

     例:

        * 分類指定

               (("from"
                      ("Lars Ingebrigtsen" 1000000 nil s))
               ("lines"
                      (500 -100 nil <)))

        * グループ/トピックパラメーター指定

               (agent-score ("from"
                                  ("Lars Ingebrigtsen" 1000000 nil s))
                            ("lines"
                                  (500 -100 nil <)))

          ここでも一番外側の括弧が省略されていることに注意して下さい。

  2. エージェントスコアファイル

     これらのスコアファイルは、上で述べられている使用可能なスコア付けキー
     ワード *だけ* を含んでいなければなりません。

     例:

        * 分類指定

               ("~/News/agent.SCORE")

          または、もしかすると

               ("~/News/agent.SCORE" "~/News/agent.group.SCORE")

        * グループパラメーター指定

               (agent-score "~/News/agent.SCORE")

          ここでも前述のように、追加のスコアファイルを指定することがで
          きます。括弧について言わなければいけませんか?

  3. `普通' のスコアファイルの使用

     あるグループのためにあなたが望んだ「ダウンロード」の基準が、「読む」
     基準と同じならば、一つのグループのために二つのスコア規則を維持管理
     したいとは思わないでしょう。そういう場合は、何をダウンロードするか
     を決める際に、エージェントに `普通' のスコアファイルを参照させるこ
     とができます。

     分類の定義やグループパラメーターでこれらの指示を行なうと、エージェ
     ントはあるグループに適用することができるすべてのスコアファイルを読
     み込んで、使うことが許されているスコア付けキーワードの副セットでは
     ない項目を *選別して取り除きます*。

        * 分類指定

               file

        * グループパラメーター指定

               (agent-score . file)



File: gnus-ja.info, Node: Category Buffer, Next: Category Variables, Prev: Category Syntax, Up: Agent Categories

分類バッファー
..............

通常すべての分類は分類バッファーから管理します。これに (グループバッ
ファーで `J c' 命令を使って) 初めて入ると、ディフォルトの分類だけが表示
されます。

このバッファーでは以下の命令を使うことができます:

`q'
     グループバッファーに戻ります (`gnus-category-exit')。

`e'
     選択された分類のパラメーターを一括して設定するために、カスタマイズ
     バッファーを使います (`gnus-category-customize-category')。

`k'
     現在の分類を消去します (`gnus-category-kill')。

`c'
     現在の分類を複製します (`gnus-category-copy')。

`a'
     新しい分類を追加します (`gnus-category-add')。

`p'
     現在の分類の述語を編集します (`gnus-category-edit-predicate')。

`g'
     現在の分類に属するグループのリストを編集します
     (`gnus-category-edit-groups')。

`s'
     現在の分類のダウンロードスコア規則を編集します
     (`gnus-category-edit-score')。

`l'
     すべての分類を表示します (`gnus-category-list')。



File: gnus-ja.info, Node: Category Variables, Prev: Category Buffer, Up: Agent Categories

分類変数
........

`gnus-category-mode-hook'
     分類バッファーで実行するフックです。

`gnus-category-line-format'
     分類バッファーの行様式です (*Note Formatting Variables::)。有効な
     要素は:

     `c'
          分類の名前です。

     `g'
          その分類に属するグループの数です。

`gnus-category-mode-line-format'
     分類モード行の様式です (*Note Mode Line Formatting::)。

`gnus-agent-short-article'
     この値より少ない行数の記事は短いと見なします。ディフォルトは 100
     です。

`gnus-agent-long-article'
     この値より多い行数の記事は長いと見なします。ディフォルトは 200 で
     す。

`gnus-agent-low-score'
     この値より小さいスコアを持つ記事は低スコアだと見なします。ディフォ
     ルトは 0 です。

`gnus-agent-high-score'
     この値より大きいスコアを持つ記事は高スコアだと見なします。ディフォ
     ルトは 0 です。

`gnus-agent-expire-days'
     期限切れ消去する前に、既読記事をエージェントのローカルディスクに留
     めておかなければならない日数 (「期限切れ消去」という名前は同じです
     が、サーバーで期限切れ消去することではありません。単に記事のローカ
     ルな複製を消すことを意味します)。さらに理解すべき大事なことは、記
     事が読まれた時ではなくローカルディスクに記事が書かれた時から計数が
     始まるということです。ディフォルトは 7日です。

`gnus-agent-enable-expiration'
     グループの記事が、ディフォルトで期限切れ消去されるか、無期限に保持
     されるかを決定します。ディフォルトは `ENABLE' で、あなたが望むなら
     ば期限切れ消去をさせないようにしなければならないことを意味します。
     一方、これを `DISABLE' に設定することができます。その場合、選択さ
     れたグループでの期限切れ消去を有効にしなければなりません。



File: gnus-ja.info, Node: Agent Commands, Next: Agent Visuals, Prev: Agent Categories, Up: Gnus Unplugged

エージェント命令
----------------

すべての Gnus エージェント命令は `J' サブマップにあります。`J j'
(`gnus-agent-toggle-plugged') 命令はすべてのモードで動作し、Gnus エージェ
ントの plugged/unplugged 状態を切り替えます。

* Menu:

* Group Agent Commands::        グループを設定してそれらの記事を取得する
* Summary Agent Commands::      手動で記事を選択し、指定した取得する
* Server Agent Commands::       エージェントでサポートされるサーバーの選択



File: gnus-ja.info, Node: Group Agent Commands, Next: Summary Agent Commands, Prev: Agent Commands, Up: Agent Commands

グループエージェント命令
........................

`J u'
     現在のグループの適格な (訳注: あなたが指定した条件に合致する) 記事
     をすべて取得します (`gnus-agent-fetch-groups')。

`J c'
     エージェント分類バッファーに入ります
     (`gnus-enter-category-buffer')。

`J s'
     全グループの適格な (訳注: あなたが指定した条件に合致する) 記事をす
     べて取得します (`gnus-agent-fetch-session')。

`J S'
     順番待ち (queue) グループにある送信可能なメッセージをすべて送信し
     ます (`gnus-group-send-queue')。*Note Drafts::.

`J a'
     現在のグループをエージェント分類に追加します
     (`gnus-agent-add-group')。この命令はプロセス/接頭引数の習慣を理解
     します (*Note Process/Prefix::)。

`J r'
     現在のグループを、もし存在していれば、その分類から消去します
     (`gnus-agent-remove-group')。この命令はプロセス/接頭引数の習慣を理
     解します。(*Note Process/Prefix::)。

`J Y'
     リモートサーバーが unplugged のときに変更されたフラグがあれば同期
     させます。



File: gnus-ja.info, Node: Summary Agent Commands, Next: Server Agent Commands, Prev: Group Agent Commands, Up: Agent Commands

概略エージェント命令
....................

`J #'
     記事にダウンロード印を付けます (`gnus-agent-mark-article')。

`J M-#'
     記事からダウンロード印を消去します (`gnus-agent-unmark-article')。

`@'
     記事をダウンロードするかどうかを切り替えます
     (`gnus-agent-toggle-mark')。ディフォルトではダウンロードの印は
     `%' です。

`J c'
     キャッシュされていない、ダウンロードされていない、またはダウンロー
     ドできないすべての記事を既読にします (`gnus-agent-catchup')。

`J S'
     このグループのすべての望ましい (訳注: あなたが指定した条件に合致す
     る) 記事 (*Note Agent Categories::) をダウンロードします。
     (`gnus-agent-fetch-group')。

`J s'
     このグループのすべてのプロセス印が付いた記事をダウンロードします。
     (`gnus-agent-summary-fetch-series')。

`J u'
     現在のグループのダウンロード可能な記事を、すべてダウンロードします
     (`gnus-agent-summary-fetch-group')。



File: gnus-ja.info, Node: Server Agent Commands, Prev: Summary Agent Commands, Up: Agent Commands

サーバーエージェント命令
........................

`J a'
     現在のサーバーを Gnus エージェントで扱われるサーバーのリストに追加
     します (`gnus-agent-add-server')。

`J r'
     現在のサーバーを Gnus エージェントで扱われるサーバーのリストから削
     除します (`gnus-agent-remove-server')。



File: gnus-ja.info, Node: Agent Visuals, Next: Agent as Cache, Prev: Agent Commands, Up: Gnus Unplugged

エージェントの視覚効果
----------------------

Unplugged のときに概略を開くと、現在エージェントに格納されているヘッダー
よりも多くの記事があることを Gnus がそのグループの active (訳注: 何番か
ら何番までの記事があるかを示す管理情報) の範囲から知っている場合には、
表題が `[Undownloaded article #####]' のようになっているいくつかの記事
を見るかもしれません。それらは見当たらないヘッダーのための穴埋め
(placeholders) です。印を設定することは別として、それらの穴埋めの一つで
できることは多くはありません。最終的に Gnus がグループのヘッダーを取っ
て来る機会を得たときに、それらの穴埋めは実際のヘッダーで自動的に置き換
えられるでしょう。気になるならば、それらの穴埋めを読み飛ばすために、概
略バッファーの動作を操作することができます (`gnus-auto-goto-ignores' 参
照)。

すべての人にとって明白かもしれませんが、オフラインのときに利用できるの
は、plugged だった期間にエージェントに取り込まれたヘッダーと記事だけで
す。言い換えると「plugged だった期間に取り込むことを忘れると、オフライ
ンのセッションを満足できるものにするには足りない」ということです。この
理由のために、エージェントは概略バッファーに二つの視覚効果を加えます。
これらの効果は、オフラインのときにどの記事が利用できるかをいつも知らせ
るために、それぞれの記事のダウンロードの状態を表示します。

第一の視覚効果は `%O' 仕様です。`gnus-summary-line-format' をカスタマイ
ズしてこの指示子を含めると、記事のダウンロードの状態を示すために単一の
文字を表示する場所が加わります。エージェントかキャッシュのどちらかに取
り込まれた記事は、`gnus-downloaded-mark' (ディフォルトは `+') を表示し
ます。それら以外のすべての記事は `gnus-undownloaded-mark' (ディフォルト
は `-') を表示します。エージェント化されていないグループを開くと、空白
(` ') が表示されます。

第二の視覚効果はダウンロードされていないことを示すフェースです。多くの
Gnus の利用者に好感と嫌悪をもたらすであろう、記事のスコアを三段階
(low, normal, high) で表示するフェースがあります。問題は、フェースの選
択が条件検査とフェース名のリスト (`gnus-summary-highlight' 参照) によっ
て制御されることです。それぞれの条件は、それがリストの中に現れる順に検
査されるので、後の条件よりも前の条件が優先されます。これが意味するすべ
ては、ダウンロードされていない記事に可視記事 (ticked) の印を付けても、
その記事は可視記事のフェースではなくて、ダウンロードされていない記事の
フェースで表示し続けられるということです。

(記事を読むたびに同じ記事をダウンロードしないようにするため、または接続
時間を最小にするために) エージェントをキャッシュとして使う場合は、ダウ
ンロードされていない記事のフェースはおそらく良い考えのように思えるでしょ
う。ダウンロードされた記事に対してすべての仕事 (印を付ける、読む、削除
する) を行なえば、いつも通常のフェースが現れるからです。しかし、NOV を
キャッシュすることによってオンライン性能を改善するためにエージェントを
使っている利用者にとっては (Gnus 5.10.2 以降のほとんどの利用者にとって
は)、ダウンロードされていない記事のフェースが見えるかもしれないことは、
まったくひどいものでしょう。これは、それらのどの記事もエージェントに取
り込まれていないので、ダウンロードされていない記事のフェースのために、
すべての普通のフェースが目立たなくなってしまうだろうという問題です。

ダウンロードされていない記事のフェースを使いたい場合は、
`agent-enable-undownloaded-faces' グループパラメーターを `t' に設定して、
ダウンロードされていない記事のフェースを有効にしなければなりません。こ
のパラメーターは他のすべてのエージェントパラメーターと同様に、エージェ
ント分類 (*Note Agent Categories::)、グループトピック (*Note Topic
Parameters::)、あるいは個々のグループ (*Note Group Parameters::) に対し
て設定することができます。

エージェントを使うすべての利用者に共通した一つの問題は、それがディスク
の容量をいかに速く使い尽くすことができるかということです。あなたが多く
のグループでエージェントを使っている場合、事実上ディスク容量を回復する
ことはさらにもっと困難です。一つの解決手段は `gnus-group-line-format'
で用意されている `%F' 形式です。この形式は、エージェントとキャッシュの
両方で取得した記事によって占められる実際のディスク容量を表示します。ど
のグループが最も多い容量を使うかを知ることによって、利用者は記事を「エー
ジェント期限切れ消去」する場合に、どこに努力を集中するべきかがわかりま
す。



File: gnus-ja.info, Node: Agent as Cache, Next: Agent Expiry, Prev: Agent Visuals, Up: Gnus Unplugged

キャッシュとしてのエージェント
------------------------------

Gnus が plugged であるときに、すでにヘッダーや記事がエージェントに格納
されているのならば、それらを再びダウンロードするのは効率的ではありませ
ん。そのため Gnus は通常ヘッダーを一回だけダウンロードしてエージェント
に格納します。それらのヘッダーは後に概略バッファーを生成するときに、
plugged か unplugged にかかわらずに使われます。ディフォルトでは記事は
(それはたくさんのディスク容量を浪費するかもしれないので) エージェントに
キャッシュされませんが、すでにエージェントにダウンロードした記事がある
ならば、Gnus はサーバーから再び記事をダウンロードせずに、手元に格納され
たコピーを使います。

あなたがそう望むのであれば、plugged な期間は常にヘッダーと記事をダウン
ロードするように、エージェント (`gnus-agent-cache' 参照 *Note Agent
Variables::) を設定することができます。Gnus はほとんど確かにもっと遅く
なりますが、サーバーとの同期は保たれます。nntp か nnimap バックエンドを
使っている場合は、たぶんこの最後の点は意味をなさないでしょう。



File: gnus-ja.info, Node: Agent Expiry, Next: Agent Regeneration, Prev: Agent as Cache, Up: Gnus Unplugged

エージェント期限切れ消去
------------------------


エージェントバックエンド `nnagent' は期限切れ消去を扱いません。えーと、
少なくとも他のバックエンドのようにそれを扱いません。その代わりに、
`gnus-agent-expire-days' の日数よりも古い既読記事をすべて消去する、特別
な `gnus-agent-expire' と `gnus-agent-expire-group' 命令があります。こ
れらはあなたがディスク容量を使い切りそうだと思ったときに、いつでも実行
することができます。どちらも特に速くも効率的でもなく、それらの一つをいっ
たん始めてしまったら (`C-g' やその他で) 中断することもあまり良いことで
はありません。

例えば `gnus-request-expire-articles' のような他の関数は、エージェント
をグループに同期させるために `gnus-agent-expire' を実行するかもしれない
ことに注意して下さい。

`agent-enable-expiration' というエージェントのパラメーターを、選択した
グループでの期限切れ消去を抑制するために使うことができます。

`gnus-agent-expire-all' が `nil' でなければ、エージェントの期限切れ消去
コマンド群はすべての記事--未読、既読、可視、保留記事を消去します。もし
`nil' (これがディフォルト) であれば、既読記事のみが消去の対象となり、未
読、可視、さらに保留記事は無期限に保持されます。

期限切れ消去されるはずなのに残っている記事を見つけたならば、もしかする
といくつかの Gnus エージェントファイルが壊れています。起こりうる問題を
修復するために、`gnus-agent-regenerate' と
`gnus-agent-regenerate-group' という特別なコマンドがあります。



File: gnus-ja.info, Node: Agent Regeneration, Next: Agent and flags, Prev: Agent Expiry, Up: Gnus Unplugged

エージェントを作り直す
----------------------

`nnagent' によって使われるローカルのデータ構造は、ある例外的な条件によっ
ておかしくなってしまうかもしれません。これが起こると `nnagent' の機能性
が下がるかもしれないし、失敗しさえするかもしれません。この問題の解決策
は、内部の矛盾をすべて削除することによって、ローカルのデータ構造を修復
することです。

例えば、記事をエージェントにダウンロードしている間にサーバーへの接続が
切れてしまう場合、ローカルのデータ構造は接続が切れる前に記事が首尾良く
ダウンロードされたかどうかを知りません。`gnus-agent-regenerate' または
`gnus-agent-regenerate-group' を実行すると、そのような記事を二回ダウン
ロードしなくても済むようにデータ構造を更新します。

`gnus-agent-regenerate' コマンドは、すべてのエージェント化されたグルー
プで `gnus-agent-regenerate-group' を実行します。どのバッファー上でも
`gnus-agent-regenerate' を実行することができますが、最初にすべての概略
バッファーを閉じることを強く勧めます。

`gnus-agent-regenerate-group' コマンドは、ローカルの NOV (ヘッダー) デー
タベースを修復するために、個々の記事のローカルなコピーを使います。その
後それは、どの記事がローカルに格納されるかを記録しておくための内部デー
タ構造を更新します。引数を与えると、エージェントの中の記事に未読の印を
付けます。



File: gnus-ja.info, Node: Agent and flags, Next: Agent and IMAP, Prev: Agent Regeneration, Up: Gnus Unplugged

エージェントとフラグ
--------------------

エージェントは Gnus のどんなバックエンドでも、例えばサーバーにフラグ
(既読(read)、可視(ticked) など) を格納する nnimap のようなものでも動作
します。しかし悲しいかな、エージェントはどのバックンドがそれらのフラグ
を `.newsrc' ではなく、そのバックエンドのサーバーで維持するかを、実際に
は知りません。そのためエージェントは、unplugged または接続されていない
間に行なったすべてのフラグへの変更を、常に自身のファイルに記録します。

再び接続すると、Gnus は変更されたすべてのフラグを検査して、それらをサー
バーと同期させるかどうかを尋ねます。この挙動は
`gnus-agent-synchronize-flags' でカスタマイズすることができます。

`gnus-agent-synchronize-flags' が `nil' だったら、エージェントは自動的
にフラグを同期させることはしません。それがディフォルトの `ask' だったら、
エージェントはあなたが再接続したときにあなたが何らかの変更を行なってい
たかどうかを調べて、もしそうだったら、それらを同期させたいかどうかを尋
ねます。それら以外の値だった場合は、すべてのフラグは自動的に同期させら
れます。

再接続したときに自動でフラグを同期させたくないなら、手動でそれを行なう
こともできます。これにはグループバッファーの `J Y' キーに割り当てられた
`gnus-agent-synchronize-flags' コマンドを使って下さい。

技術的注釈: すべてのローカルなフラグをサーバーに「押し込む」同期のアル
ゴリズムは動作しませんが、利用者によって変更されたフラグだけを変更して、
サーバー側で見えるフラグを一つずつ更新することは可能です。したがって、
あなたが記事の一つのフラグをセットして、そのグループを抜け出てから再度
そのグループを選択してそのフラグを消せば、あなたが「同期」の操作を行なっ
たときに、そのフラグはセットされてサーバーからは削除されます。順番待ち
(queue) に入れられたフラグに関する動作は、エージェントディレクトリーに
あるサーバー毎の `flags' ファイルの中で見つかるでしょう。それらはあなた
がフラグを同期させたときに空になります。



File: gnus-ja.info, Node: Agent and IMAP, Next: Outgoing Messages, Prev: Agent and flags, Up: Gnus Unplugged

エージェントを IMAP で使う方法
------------------------------

エージェントは nnimap を含む Gnus のどんなバックエンドでも動作します。
しかし NNTP と IMAP にはいくつかの概念の違いがあるので、この章ではサー
バーとの接続が絶たれたモードでの IMAP のクライアントとして、Gnus エージェ
ントをより円滑に使えるようにするための、いくつかの情報を提供します。

サーバーとの接続が絶たれているときの IMAP クライアントにあなたが期待す
るであろういくつかの機能は、現在のエージェントには盛り込まれていません。
それらは以下の通りです:

   * Unplugged のときの nnimap グループへのコピーと移動。

   * Unplugged のときの nnimap グループの作成と削除。



File: gnus-ja.info, Node: Outgoing Messages, Next: Agent Variables, Prev: Agent and IMAP, Up: Gnus Unplugged

差出用メッセージ
----------------

Gnus が unplugged のとき、ディフォルトではすべての差出用メッセージ (メー
ルとニュースの両方) は下書きグループ“queue”(*Note Drafts::) に格納さ
れます。投稿した後でも、そこでそのメッセージを見たり編集するのは意のま
まです。

送出するメールが queue される (順番待ちになる) 状況を制御することは可能
です (`gnus-agent-queue-mail', *Note Agent Variables:: 参照)。Gnus が
unplugged のとき、外に送り出すニュースは常に queue されるだけです。

下書きグループから、そこで使える特別な命令を使ってメッセージを送信する
こともできるし、グループバッファー内で `J S' を使って、下書きグループ内
のすべての送信可能なメッセージを送信することもできます。ニュースの投稿
は Gnus が plugged のときだけできますが、メールはいつでも送信することが
できます。

Unplugged のときにメールの送信ができなくて、かつ unplugged のときにうっ
かり `J S' を叩いてしまうことが心配ならば、Gnus にあなたの行動を確認さ
せることができます (`gnus-agent-prompt-send-queue', *Note Agent
Variables:: 参照)。



File: gnus-ja.info, Node: Agent Variables, Next: Example Setup, Prev: Outgoing Messages, Up: Gnus Unplugged

エージェント変数
----------------

`gnus-agent'
     エージェントが有効になっているかどうか。ディフォルトは `t' です。
     最初に有効にされると、いくつかのバックエンドを自動的にエージェント
     化するために、エージェントは `gnus-agent-auto-agentize-methods' を
     使います。サーバーバッファーでエージェントのコマンドを使うことによっ
     て、どのバックエンドをエージェント化するかを変更することができます。

     サーバーバッファーに入るには、グループバッファーで `^'
     (`gnus-group-enter-server-mode') を使って下さい。

`gnus-agent-directory'
     Gnus エージェントがファイルを格納する場所です。ディフォルトは
     `~/News/agent/' です。

`gnus-agent-handle-level'
     この変数の値より高いレベル (*Note Group Levels::) のグループは、エー
     ジェントからは無視されます。ディフォルトは
     `gnus-level-subscribed' で、これはディフォルトでは、購読しているグ
     ループのみがエージェントの処理の対象となるということです。

`gnus-agent-plugged-hook'
     ネットワークに接続されたときに実行されるフックです。

`gnus-agent-unplugged-hook'
     ネットワークから切断されたときに実行されるフックです。

`gnus-agent-fetched-hook'
     記事を取り込み終わったときに実行されるフックです。

`gnus-agent-cache'
     Plugged のときに、ローカルに格納されている NOV と記事を使うかどう
     かを制御する変数で、例えばエージェントをキャッシュとして使うには必
     須です。ディフォルトでは非-`nil' で、エージェントをキャッシュとし
     て使います。

`gnus-agent-go-online'
     `gnus-agent-go-online' が `nil' だったら、エージェントはオフライン
     状態のサーバーをオンライン状態にしません。`ask' だったら、それがディ
     フォルトですが、エージェントは再接続するときにオフライン状態のサー
     バーをオンライン状態にしたいかどうかを尋ねます。それ以外の値だった
     ら、オフライン状態のサーバーは自動的にオンライン状態になります。

`gnus-agent-mark-unread-after-downloaded'
     `gnus-agent-mark-unread-after-downloaded' が 非-`nil' だったら、ダ
     ウンロードした後で記事に未読の印を付けます。これは通常、新しくダウ
     ンロードされた記事を明確に未読にするための安全な行為です。ディフォ
     ルトは `t' です。

`gnus-agent-synchronize-flags'
     `gnus-agent-synchronize-flags' が `nil' だったら、エージェントは決
     して自動的にフラグを同期させません。それが `ask' だったら (それが
     ディフォルトです)、エージェントはすべての変更を検査して、再び接続
     したときにそれらを同期させるかどうかを尋ねます。`nil' でも `ask'
     でもなかったら、すべてのフラグが自動的に同期させられます。

`gnus-agent-consider-all-articles'
     `gnus-agent-consider-all-articles' が非-`nil' だったら、エージェン
     トはすべての記事について、それらをダウンロードする必要があるかどう
     かをエージェントの述語に決定させます。`nil' だった場合、それがディ
     フォルトですが、エージェントは未読の記事をダウンロードするかどうか
     だけを述語に決定させます。これを有効にするのならば、後でエージェン
     トが期限切れ消去する記事を何度も繰り返しダウンロードしないように、
     エージェントの期限切れ消去の設定 (*Note Category Variables::) を見
     直す必要があるでしょう。

`gnus-agent-max-fetch-size'
     エージェントは、取得した記事を個々のファイルに入れるための解析を行
     なう前に、それらを一時的なバッファーへ取り込みます。最大のバッファー
     サイズを超過しないようにするために、記事がすべて取得されるまで、エー
     ジェントは取得と解析を交互に行ないます。
     `gnus-agent-max-fetch-size' は、繰り返しがどれくらい頻繁に起きるか
     を制御するための、サイズの限界を規定します。大きな値は性能を向上さ
     せます。小さな値は、万が一取得している間に接続が切れた場合に、遅れ
     時間を最小にします (グループの状態を更新するために
     `gnus-agent-regenerate-group' を実行する必要があるかもしれません。
     でも、接続が切れる前に解析されたすべての記事は、unplugged の期間に
     利用することができるでしょう。)。繰り返しに遭遇することは珍しいの
     で、ディフォルトは 10M です

`gnus-server-unopen-status'
     エージェント変数ではないかもしれないけれどエージェントに密接に関連
     するこの変数は、Gnus がサーバーに接続できないときに何をするかを指
     示します。エージェントが活性化されると、ディフォルトの `nil' では、
     サーバーとの接続を絶つかエージェントを unplugged にするかを利用者
     に尋ねます。エージェントが不活性化されると、Gnus はいつも単にサー
     バーとの接続を絶ちます。この変数の他の選択肢には `denied' と
     `offline' があり、後者はエージェントを使う場合だけ有効です。

`gnus-auto-goto-ignores'
     おおかたの人は、エージェント変数ではないけれども密接に関連するもう
     一つの変数をここで探すでしょう。この変数は、ダウンロードされていな
     い (ヘッダーだけがエージェントに格納された)、そして取り込まれてい
     ない (記事もヘッダーも格納されていない) 記事の周りでどう移動するか
     を概略バッファーに伝えます。

     有効な値は `nil' (どの記事にも移動する)、
     `undownloaded' (unplugged のときは取り込まれていない記事を無視する)、
     `always-undownloaded' (取り込まれていない記事を常に無視する)、
     `unfetched' (ヘッダーが取り込まれていない記事を無視する) です。

`gnus-agent-queue-mail'
     `gnus-agent-queue-mail' を `always' にすると、Gnus はメールを
     いきなり送信してしまうのではなく、常に queue (順番待ち) に入れます。
     `t' だったら Gnus は unplugged のときだけメールを queue に入れます。
     `nil' だったら queue に入れません。ディフォルトは `t' です。

`gnus-agent-prompt-send-queue'
     `gnus-agent-prompt-send-queue' が非-`nil' だったら、unplugged であ
     るのにもかかわらず `J S' を叩いた場合に、Gnus は本当にそれを行なっ
     ても良いかどうかを確認します。ディフォルトは `nil' です。

`gnus-agent-auto-agentize-methods'
     あなたが以前にエージェントを使ったことが無い (もっと技術的には
     `~/News/agent/lib/servers' が無い場合)、Gnus はほんの少数のサーバー
     を自動的にエージェント化します。この変数はどのバックエンドを自動で
     エージェント化すべきかを制御します。一般に、エージェント化すること
     が有用なのは遠隔バックエンドに対してだけです。自動的にエージェント
     化することは、サーバーに対して `J a' を実行するのと同じ効果があり
     ます (*Note Server Agent Commands::)。もしファイルが存在するならば、
     それらを追加したり削除するためにサーバーを手動で操作しなければなり
     ません。この変数は最初に Gnus を起動したときだけ適用されます。ディ
     フォルトは `(nntp nnimap)' です。



File: gnus-ja.info, Node: Example Setup, Next: Batching Agents, Prev: Agent Variables, Up: Gnus Unplugged

設定例
------

あなたがこのマニュアルを読みたくなくて、ごく標準的な設定を行なっている
のならば、`~/.gnus.el' ファイルとして何か以下のようなものを使って始めて
も良いでしょう。

     ;;; Gnus がどのようにニュースを取得するかを定義します。ここ
     ;;; では ISP のサーバーから NNTP で取ってくることにします。
     (setq gnus-select-method '(nntp "news.your-isp.com"))

     ;;; Gnus がどのようにメールを読むかを定義します。
     ;;; ISP の POP サーバーからメールを読むことにします。
     (setq mail-sources '((pop :server "pop.your-isp.com")))

     ;;; Gnus がメールをどのように格納するかを指定します。
     ;;; nnml グループを使うことにします。
     (setq gnus-secondary-select-methods '((nnml "")))

     ;;; Gnus をオフラインニュースリーダーにします。
     ;;; (gnus-agentize) ; 旧式の設定。
     ;;; (setq gnus-agent t) ; 現在のディフォルト。

基本的にはこれだけで良いはずです。これを `~/.gnus.el' ファイルに入れて、
必要に応じて編集し、PPP (や何か) を起動して、`M-x gnus' とタイプして下
さい。

あなたが Gnus を走らせたのが初めてであれば、自動的にわずかなディフォル
トのニュースグループが読めるようになります。おそらくもっとたくさんのグ
ループを購読したくなるでしょう。そのためには、`A A' 命令でグループの完
全なリストを NNTP サーバーに問い合わせなければなりません。これは普通は
とても時間がかかりますが、一度だけしか実行する必要はありません。

読み込みと解析にしばらく時間を費やした後で、グループの一覧が現れます。
そうしたら、読みたいグループを `u' 命令で購読できるようにして下さい。読
みたいグループを全部購読できるようにしたら、`l' で killed (削除された)
グループをすべて画面から消去しましょう。(`A k' で killed グループはすべ
て戻ってきます。)

今やすぐにグループを読むこともできるし、`J s' 命令で記事をダウンロード
することもできます。あとはこのマニュアルの残りを読んで、他の億千万の項
目からカスタマイズしたいことを見つけ出して下さい。



File: gnus-ja.info, Node: Batching Agents, Next: Agent Caveats, Prev: Example Setup, Up: Gnus Unplugged

一括エージェント処理
--------------------

Gnus エージェントに記事を取得させるのは (そしてあなたの書いた何かのメッ
セージを投稿するのは)、いったんものごとを正しく設定してしまえば非常に簡
単です。以下のシェルスクリプトは必要なことをすべてやってくれるでしょう。

以下の呪文をコマンドラインで使うことによって、完全なバッチコマンドを走
らせることができます:

     #!/bin/sh
     emacs -batch -l ~/.emacs -l ~/.gnus.el gnus-agent-batch >/dev/null 2>&1



File: gnus-ja.info, Node: Agent Caveats, Prev: Batching Agents, Up: Gnus Unplugged

エージェントの問題点
--------------------

Gnus エージェントは、よくある他のオフラインニュースリーダーのようには動
作しません。これらは架空の人々からの良くある質問です:

"Plugged のときに記事を読んだら、それはエージェントに入るのですか?"

     *いいえ*。この動作をお望みなら `gnus-select-article-hook' に関数
     `gnus-agent-fetch-selected-article' を加えて下さい。

"Plugged のときに記事を読んで、エージェントに記事が存在している場合、"
     もう一回ダウンロードされるのですか?

     *いいえ*、ただし `gnus-agent-cache' が `nil' でなかったら、ですが。

要約すると、Gnus が unplugged のときはローカルに保存された記事を見るだ
けです。Plugged のときは ISP と話し、かつローカルに持っている記事も使う
でしょう。



File: gnus-ja.info, Node: Scoring, Next: Various, Prev: Select Methods, Up: Top

スコア
******

ほかの人たちは「削除ファイル」("kill files") を使いますが、ここ Gnus タ
ワーにいる私たちは削除よりもスコアの方が好きです。彼らとけんかをするよ
りは切り替えてしまう方がましでしょう。それらは完全に違うことをするので、
真っ直ぐに座って注意を払って下さい!

すべての記事はディフォルトのスコア (`gnus-summary-default-score') の値
を持っていて、ディフォルトでは 0 です。このスコアは対話的に、またはスコ
アファイル (score file) によって、上げられるか下げられるかします。
`gnus-summary-mark-below' よりも低いスコアを持っている記事には既読の印
が付きます。

Gnus は概略バッファーを作成する前に、現在のグループに適用されるどんな
「スコアファイル」も読み込みます。

現在の記事に基づいてスコアのエントリーを挿入する、複数の概略バッファー
の命令があります。例えば、Gnus に特定の表題の記事のスコアを下げたり上げ
たりするように求めることができます。

二種類のスコア・エントリーがあります: 永続的なものと一時的なものです。
一時的なスコア・エントリーは、自分自身で期限切れ消去するエントリーです。
例えば一週間以上使われていないエントリーは、スコアファイルの大きさを小
さくしておくために静かに削除されます。

* Menu:

* Summary Score Commands::      現在のグループのためのスコア・エントリーを追加する
* Group Score Commands::        一般的なスコア命令
* Score Variables::             あなたのスコアをカスタマイズする
* Score File Format::           スコアファイルには何が入っているか
* Score File Editing::          手でスコアファイルを編集することもできる
* Adaptive Scoring::            Big Sister Gnus はあなたが何を読んだか知っている
* Home Score File::             新しいスコア・エントリーがどこへ行くかを指示する方法
* Followups To Yourself::       人があなたに返答したときに Gnus に気付かせる
* Scoring On Other Headers::    標準ではないヘッダーにスコアを付ける
* Scoring Tips::                効果的にスコアを付ける方法
* Reverse Scoring::             歳をとった問題児は問題ではない
* Global Score Files::          地を覆い、耳を切り裂くスコアファイル
* Kill Files::                  それらはまだここにあるが、無視することができる
* Converting Kill Files::       消去ファイルをスコアファイルに翻訳する
* Advanced Scoring::            スコアの規則を作るために論理表現を使う
* Score Decays::                スコアを減衰させるのは役に立つこともある



File: gnus-ja.info, Node: Summary Score Commands, Next: Group Score Commands, Prev: Scoring, Up: Scoring

概略スコア命令
==============

スコア・エントリーを変更するスコア命令は、実際に本当のスコアファイルを
修正するわけではありません。それはあまりに非効率です。Gnus は以前にロー
ドされたスコアファイルのキャッシュを保持していて、その一つが「現在のス
コアファイルの連想リスト」だと見なされます。スコア命令は単にこのリスト
にエントリーを挿入し、グループから出るときに、このリストは保存されます。

現在のスコアファイルは、実際にそのようなスコアファイルが存在しない場合
でも、ディフォルトでグループのローカルスコアファイルになります。スコア
命令を何か他のスコアファイル (例えば `all.SCORE') に挿入するには、まず
このスコアファイルを現在のものにしなければなりません。

以下はスコアファイルを実際に変更しない、一般的なスコア命令です:

`V s'
     現在の記事のスコアを設定します (`gnus-summary-set-score')。

`V S'
     現在の記事のスコアを表示します (`gnus-summary-current-score')。

`V t'
     現在の記事に使われているすべてのスコア規則を表示します
     (`gnus-score-find-trace')。`*Score Trace*' バッファーにおいて、現
     在の行のスコア規則に対応するスコアファイルを編集するには `e' を、
     スコアファイルの清書 (`gnus-score-pretty-print') と編集を行なうた
     めには `f' をタイプして下さい。

`V w'
     スコアで使われている語のリストを表示します
     (`gnus-score-find-favourite-words')。

`V R'
     現在の概略でスコアの処理を実行します (`gnus-summay-rescore')。
     Gnus には内緒でスコアファイルをいじり回して、その効果を見たいとき
     に役立つでしょう。

`V c'
     違うスコアファイルを現在のものにします
     (`gnus-score-change-score-file')。

`V e'
     現在のスコアファイルを編集します
     (`gnus-score-edit-current-scores')。`gnus-score-mode' バッファーが
     現れるしょう (*Note Score File Editing::)。

`V f'
     スコアファイルを編集して、このスコアファイルを現在のものにします
     (`gnus-score-edit-file')。

`V F'
     キャッシュされているスコアを捨てます (`gnus-score-flush-cache')。
     これはスコアファイルを編集した後で役に立ちます。

`V C'
     視覚的に快適な方法でスコアファイルをカスタマイズします
     (`gnus-score-customize')。

以下の命令はローカルスコアファイルを変更します:

`V m'
     スコアの入力を求めて、それよりも低いスコアのすべての記事に既読の印
     を付けます (`gnus-score-set-mark-below')。

`V x'
     スコアの入力を求めて、そのスコアより低いすべての記事を削除するため
     のスコア規則を現在のスコアファイルに付け加えます
     (`gnus-score-set-expunge-below')。

スコア・エントリーを実際に作るためのキー操作は、非常に規則正しい様式に
のっとっているので、それらすべての (何百もある) 命令を列挙する必要は無
いでしょう。

  1. 最初にタイプするキーは、スコアを増やすときは `I' (i の大文字) で、
     スコアを下げるときは `L' です。
  2. 二番目のキーは、どのヘッダーでスコアを付けるかを指定します。以下の
     キーを使うことができます:

     `a'
          著者 (author) の名前でスコアを付けます。

     `s'
          表題 (subject) の行でスコアを付けます。

     `x'
          `Xref' 行、すなわちクロスポスト行でスコアを付けます。

     `r'
          `References' 行でスコアを付けます。

     `d'
          日付 (date) でスコアを付けます。

     `l'
          行数 (number of lines) でスコアを付けます。

     `i'
          `Messsage-ID' ヘッダーでスコアを付けます。

     `e'
          NNTP サーバーが追加のヘッダーのデータを overview で捕捉してい
          れば、その「追加」のヘッダー (すなわち (`gnus-extra-headers'
          に設定されているもの) の一つでスコアを付けます。

     `f'
          フォローアップ (followup) でスコアを付けます--これは著者名と
          合致するかどうかを調べて、この著者へのフォローアップでスコア
          を加えます。(このキーを使うことは、`ADAPT' ファイルの生成をも
          たらします。)

     `b'
          記事の本文でスコアを付けます。

     `h'
          ヘッダーでスコアを付けます。

     `t'
          スレッドでスコアを付けます。(このキーを使うことは、`ADAPT' ファ
          イルの生成をもたらします。)

  3. 三番目のキーは合致の型です。どの合致の型が有効なのかは、どのヘッダー
     でスコアを付けようとしているかに依ります。

     `文字列 (strings)'

          `e'
               正確な (exact) 合致です。

          `s'
               文字列の一部の (substring) 合致です。

          `f'
               大雑把な (fuzzy) 合致です (*Note Fuzzy Matching::)。

          `r'
               正規表現 (regexp) の合致です。

     `日付 (date)'

          `b'
               日付の前 (before) です。

          `a'
               日付の後 (after) です。

          `n'
               その日付です。

     `数値 (number)'

          `<'
               数値より小さいものです。

          `='
               数値と等しいものです。

          `>'
               数値より大きいものです。

  4. 普通はこれで最後の四つ目のキーは、これが一時的な (すなわち期限切れ
     消去される) スコア・エントリーか、永続的な (すなわち期限切れ消去で
     ない) スコア・エントリーか、またはスコアファイルに追加せずにただち
     にスコア付けを行なうか、のどれかを指定します。

     `t'
          一時的な (temporary) スコア・エントリーです。

     `p'
          永続的な (permanent) スコア・エントリーです。

     `i'
          ただちに (immediate) スコア付けを行ないます。

  5. もし `e' (追加の (extra)) ヘッダーでスコア付けを行なっていると、それでス
     コア付けをしたいヘッダーの名前を尋ねられるでしょう。これ
     は `gnus-extra-headers' にある名前でなければなりません。
     `TAB' による補完ができます。

そういうわけで、現在の著者への、正確な合致に基づいて、永続的なスコアを、
増やしたい、という場合のキーは `I a e p' です。表題への、文字列の一部合
致に基づいて、一時的なスコア・エントリーを作り、そのスコアを下げたい、
という場合のキーは `L s s t' です。ずいぶん簡単ですね。

ものごとを少し複雑にするためにショートカット・キーがあります。二番目か
三番目のキーに大文字を使うと、Gnus は残る一つか二つのキーにディフォルト
値を使います。ディフォルトは「文字列の一部」と「一時的」です。ですから
`I A' は `I a s t' と同じで、`I a R' は `I a r t' と同じです。

これらの関数は、数値接頭引数とシンボル接頭引数を受け付けます (*Note
Symbolic Prefixes::)。数値接頭引数はどのくらい記事のスコアを下げる (も
しくは上げる) かを指定します。シンボル接頭引数 `a' は、現在のスコアファ
イルの代わりに `all.SCORE' ファイルをその命令のために使うことを指示しま
す。

`gnus-score-mimic-keymap' はこれらの命令がキーマップであるかのように振
る舞うかどうかを指定します。



File: gnus-ja.info, Node: Group Score Commands, Next: Score Variables, Prev: Summary Score Commands, Up: Scoring

グループスコア命令
==================

残念ながら、まだたくさんはありません。

`W e'
     すべてのグループに適用される all.SCORE ファイルを編集します。
     `gnus-score-mode' のバッファーが現れるでしょう (*Note Score File
     Editing::)。

`W f'
     何度もスコア連想リストを再読み込みすることを避けるために、Gnus は
     それらのキャッシュを保持しています。この命令はキャッシュを空っぽに
     します (`gnus-score-flush-cache')。

以下のようなやり方で、コマンド行からスコア付けをすることができます:

     & emacs -batch -l ~/.emacs -l ~/.gnus.el -f gnus-batch-score



File: gnus-ja.info, Node: Score Variables, Next: Score File Format, Prev: Group Score Commands, Up: Scoring

スコア変数
==========

`gnus-use-scoring'
     `nil' であれば、Gnus はスコアファイルを調べず、一般的にはスコア関
     連の仕事をまったくしません。これはディフォルトで `t' です。

`gnus-kill-killed'
     この変数が `nil' であれば、Gnus はすでに削除 (kill) の処理を実行さ
     れた記事に決してスコアファイルを適用しません。これはたくさんの時間
     を節約する一方、削除ファイルをグループに適用していて、削除ファイル
     を変更し、もっと多くの記事を削除するためにそれを再実行しても、それ
     は動作しないということにもなります。それをするためにはこの変数を
     `t' にしなければなりません。(これはディフォルトで `t' です。)

`gnus-kill-files-directory'
     すべての削除 (kill) とスコアのファイルはこのディレクトリーに格納さ
     れます。その値は、ディフォルトでは環境変数 `SAVEDIR' によって初期
     化されます。ディフォルトは `~/News/' です。

`gnus-score-file-suffix'
     スコアファイルの名前を得るためにグループ名に加える接尾語です (ディ
     フォルトは `SCORE' です)。

`gnus-score-uncacheable-files'
     通常すべてのスコアファイルは、スコアファイルの過剰な再読み込みを避
     けるためにキャッシュされます。しかし、このために Emacs が大きく肥
     大化するようならば、再び必要とされそうもないスコアファイルを取り除
     くためにこの正規表現を使うことができます。`all.SCORE' のキャッシュ
     をやめてしまうのは間違った考えですが、
     `comp.infosystems.www.authoring.misc.ADAPT' をキャッシュしないのは
     良い考えかもしれません。実際のところ、この変数のディフォルトは
     `ADAPT$' で、適応スコアファイルはキャッシュされません。

`gnus-save-score'
     もし本当に複雑なスコアファイルを持っていて、たくさんの一括
     (batch) スコア付けを行なうのであれば、この変数を `t' に設定しても
     良いでしょう。これは Gnus にスコアを `.newsrc.eld' ファイルに保存
     させます。

     これを `t' に設定しないと、手動で付けたスコア (`V s'
     (`gnus-summary-set-score') で設定したようなもの) は訪れたグループ
     群を横切って保持されることはありません。

`gnus-score-interactive-default-score'
     スコアを上げ/下げするために、すべての対話的スコア上げ/下げ命令によっ
     て使われるスコアです。ディフォルトは 1000 で、過剰に思えるかもしれ
     ませんが、適応スコア付けをするための十分な余地を確保するためです。
     手で入力したデータを、適応スコア付けからの小さな変更で上書きされた
     くはないのです。

`gnus-summary-default-score'
     記事のスコアのディフォルトで、ディフォルトでは 0 になっています。

`gnus-summary-expunge-below'
     この変数より低いスコアを持つ記事は概略の行に表示されません。ディフォ
     ルトは `nil' で、どの記事も隠されないということです。これは各概略
     バッファーにおけるローカル変数で、`gnus-summary-mode-hook' によっ
     て設定されなければなりません。

`gnus-score-over-mark'
     ディフォルトのスコアより大きなスコアを持つ記事に対して (概略行の三
     桁目で) 使われる印です。ディフォルトは `+' です。

`gnus-score-below-mark'
     ディフォルトのスコアより小さなスコアを持つ記事に対して (概略行の三
     桁目で) 使われる印です。ディフォルトは `-' です。

`gnus-score-find-score-files-function'
     現在のグループのためのスコアファイルを見つけるために使われる関数で
     す。この関数はグループ名を引数として呼ばれます。

     あらかじめ定義されている使用可能な関数は:

     `gnus-score-find-single'
          グループ自身のスコアファイルだけを適用します。

     `gnus-score-find-bnews'
          すべての合致するスコアファイルを bnews 構文を使って適用します。
          これがディフォルトです。例えば、現在のグループが
          `gnu.emacs.gnus' ならば、`gnu.all.SCORE', `not.alt.SCORE' と
          `gnu.all.SCORE' がすべて適用されます。要するに、スコアファイ
          ル名の `all' が `.*' に変換され、それから正規表現の合致がなさ
          れます。

          これは、すべてのグループに適用したいスコア・エントリーがいく
          つかある場合は、それらのエントリーを `all.SCORE' ファイルに入
          れるということです。

          Gnus は、より一般的なスコアファイルを、より特定のスコアファイ
          ルより前に適用しようとするものの、スコアファイルはややランダ
          ムな順番で適用されます。これはスコアファイル名の要素の数を調
          べることによって行なわれます---`all' 要素を取り除いて。

     `gnus-score-find-hierarchical'
          すべての親グループから、順にすべてのスコアファイルを適用しま
          す。これは `all.SCORE' のようなスコアファイルを持つことはでき
          ないけれど、`SCORE', `comp.SCORE' および `comp.emacs.SCORE'
          を、それぞれのサーバーに対して持つことができるということです。

     この変数は関数のリストであることもできます。その場合、これらすべて
     の関数がグループ名を引数として呼ばれ、返されたすべてのスコアファイ
     ルのリストが適用されます。これらの関数は、直接スコア連想リストのリ
     ストのリストを返すこともできます。その場合、それらのファイルでない
     スコア連想リストを返す関数は、返される最後のスコアファイルがローカ
     ルスコアファイルであることを確実にするために、おそらく「本当の」ス
     コアファイル関数よりも前に置かれるべきでしょう。ふぅ。

     例えば、サーバーを特定しない全体スコアファイルを使って、階層的に
     (親グループから順に) スコア付けを行なうならば、次の値を使えば良い
     でしょう。

          (list (lambda (group) ("all.SCORE"))
                'gnus-score-find-hierarchical)

`gnus-score-expiry-days'
     この変数は、使われていないスコアファイルエントリーが期限切れ消去さ
     れるまでに、どのくらいの日数が経過すべきかを指定します。この変数が
     `nil' であると、スコアファイルエントリーは削除されません。ディフォ
     ルトは 7 です。

`gnus-update-score-entry-dates'
     この変数が `nil' でないと、一時的に合致したスコア・エントリーは日
     付が更新されます。(これは Gnus が期限切れ消去を操作している方法で
     す--すべての合致しないエントリーは古くなりすぎるのに対して、合致す
     るエントリーは新鮮で若いままです。) しかし、この変数を `nil' に設
     定すると、合致するエントリーでさえも古くなって、ああ、そう、あの冷
     酷な死神と直面することになるでしょう。

`gnus-score-after-write-file-function'
     スコアファイルが書かれた直後に、その名前を引数として呼ばれる関数で
     す。

`gnus-score-thread-simplify'
     この変数が `nil' でないと、記事の表題は表題でスコア付けを行なうた
     めに、スレッドと同じやり方で (現在の
     `gnus-simplify-subject-functions' の値に従って) 単純化されます。ス
     コア・エントリーが「文字列の一部への合致」か「正確な合致」を使って
     いると、その合致もこのやり方で単純化されます。



File: gnus-ja.info, Node: Score File Format, Next: Score File Editing, Prev: Score Variables, Up: Scoring

スコアファイル様式
==================

スコアファイルは普通は単一の様式だけを含む `emacs-lisp' ファイルです。
無頓着な利用者はこれを編集しないで下さい。すべては概略バッファーから変
更することができます。

にもかかわらず、それを自分でいじってみたくなったのなら、例があります:

     (("from"
       ("Lars Ingebrigtsen" -10000)
       ("Per Abrahamsen")
       ("larsi\\|lmi" -50000 nil R))
      ("subject"
       ("Ding is Badd" nil 728373))
      ("xref"
       ("alt.politics" -1000 728372 s))
      ("lines"
       (2 -100 nil <))
      (mark 0)
      (expunge -1000)
      (mark-and-expunge -10)
      (read-only nil)
      (orphan -10)
      (adapt t)
      (files "/hom/larsi/News/gnu.SCORE")
      (exclude-files "all.SCORE")
      (local (gnus-newsgroup-auto-expire t)
             (gnus-summary-make-false-root empty))
      (eval (ding)))

この例はたいていのスコアファイルの要素を説明しています。別のやり方につ
いては、*Note Advanced Scoring:: を見て下さい。

これがとても Lisp コードのように見えるとしても、実際はここにあるものは
何も `eval' (評価) されません。しかしこの様式を読み込むために Lisp リー
ダーが使われるので、意味的に有効でないとしても、文法的には正当なもので
す。

この連想リストでは六つのキーがサポートされています:

`文字列 (STRING)'
     キーが文字列だったら、それは合致が実行されるヘッダーの名前です。ス
     コア付けはこれら八つのヘッダーだけで行なうことができます: `From',
     `Subject', `References', `Message-ID', `Xref', `Lines', `Chars' お
     よび `Date' です。これらのヘッダーに加えて、Gnus に、記事全体を取
     得して記事のより大きな部分で合致を行なわせる三つの文字列があります:
     `Body' は記事の本文で合致を行ない、`Head' は記事のヘッダーで合致を
     行ない、`All' は記事全体で合致を行ないます。これら最後の三つのキー
     を使うと、グループに入る速度を *かなり* 遅くしてしまうことに気を付
     けて下さい。スコアを付けることができる最後の「ヘッダー」は
     `Followup' です。これらのスコア・エントリーは、これらのスコア・エ
     ントリーに合致する記事へのすべてのフォローアップのための追加が行な
     われている、新しいスコア・エントリーに帰着するでしょう。

     このキーに続くのは任意の数のスコア・エントリーで、それぞれのスコア・
     エントリーは一つから四つまでの要素を持ちます。

       1. 最初の要素は「合致要素」です。これはたいていのヘッダーでは文
          字列ですが、Lines と Chars ヘッダーでは整数でなければなりませ
          ん。

       2. もし二番目の要素があるなら、それは数値の「スコア要素」でなけ
          ればなりません。この数値は負の無限大から正の無限大までの間の
          整数でなければなりません。合致が成功すると、この数値が記事の
          スコアに加えられます。この要素が存在していない場合は、代わり
          に `gnus-score-interactive-default-score' の数値が使われます。
          ディフォルトは 1000 です。

       3. もし三番目の要素があるなら、それは数値の「日付要素」でなけれ
          ばなりません。この日付は最後にこのスコア・エントリーが合致し
          た時刻を示し、それはスコア・エントリーを期限切れ消去するため
          の機構を提供します。この要素が存在していないと、スコア・エン
          トリーは永続になります。日付は紀元前 1年12月31日からの経過し
          た日数で表されます。

       4. もし四番目の要素があるなら、それはシンボルの「型要素」でなけ
          ればなりません。この要素は、このスコア・エントリーが記事に合
          致するかどうかを調べるために、どの関数が使われるべきかを指定
          します。

          "From, Subject, References, Xref, Message-ID"
               たいていのヘッダー型のために、`r' と `R' (正規表現
               (regexp))、`s' と `S' (文字列の一部(substring)) 型、`e'
               と `E' (正確な合致(exact match))、および `w' (語の合致
               ((word match)) 型があります。もしこの要素が無いと、Gnus
               は文字列の一部の合致が用いられるべきであると仮定します。
               `R', `S', `E' は、合致が大文字と小文字を区別する方法で行
               なわれる点で他のものと異なります。これらすべての一文字型
               は、本当は `regexp', `exact', `word' 型の短縮形で、この
               方が好みならば代わりに使うことができます。

          "Extra"
               overview ヘッダーの標準の文字列に的を絞って
               `gnus-extra-headers' を使っていれば、それらのヘッダーの
               値でスコアを付けることができます。この場合スコア・エント
               リーの五番目の要素が、スコアを付けるヘッダーの名前になり
               ます。NNTP サーバーが overview で `NNTP-Posting-Host' を
               捕捉しているならば、`all.SCORE' ファイルの以下のエントリー
               は、単一のホストを起源とする spam の攻撃に対して有効です:

                    ("111.222.333.444" -1000 nil s
                     "NNTP-Posting-Host")

          "Lines, Chars"
               これらの二つのヘッダーは別の合致の型を使います: `<', `>',
               `=', `>=', `<=' です。

               これらの述語は

                    (PREDICATE HEADER MATCH)

               の評価が `nil' ではない場合に真です。例えば、上級合致
               `("lines" 4 <)' (*Note Advanced Scoring::) は結果として
               以下の式になります:

                    (< header-value 4)

               言い換えると、4 を合致として `<' を `Lines' で使っている
               ときは、記事が 4 行よりも少ないときにスコアが加算される
               ということです。(混乱して、それが反対ではないかと考えが
               ちです。でも、そうではないのです。私が思うに。)

               合致を `Lines' で行なっていると、いくつかのバックエンド
               (`nndir' のようなもの) は `Lines' ヘッダーを作成しないの
               で、すべての記事が 0 行であるとして扱われてしまうことに
               気を付けて下さい。これは、少しの行しかない記事のスコアを
               下げている場合に、変な結果を導くことがあり得ます。

          "Date"
               Date (日付) ヘッダーには三つのなんとなくばかげている合致
               の型があります: `before', `at', `after' です。私は本当に
               これが役立つような機会を想像できないのですが、この関数を
               提供しないのもなんとなくばかげています。そうした場合のた
               めにあるのです。いつ必要になるかは誰にもわかりません。転
               ばぬ先の杖。羹(あつもの)に懲りて膾(なます)を吹く。本をカ
               バーで判断しては行けません。初めてのデートでエッチしては
               いけません。(しかし、私は少なくとも一人、引用しますが、
               「この関数は欠かせないものであることがわかった」と言った
               人がいると聞いています。)

               もっと役に立つ合致の型は「正規表現」です。それによって、
               日付の文字列に正規表現を使って合致させることができます。
               日付はまず ISO8601 の短縮様式 (compact format) に標準化
               されます---YYYYMMDD`T'HHMMSS です。例えば、すべての年の
               4月1日に投稿されたすべての記事に合致させたいのであれば、
               合致文字列として `....0401.........' を使うことができま
               す。(日付は元々の標準時で保存されているので、その記事が
               投稿された場所での 4月1日に投稿された記事に合致すること
               に注意して下さい。“Time zones”は家族全員の健全な楽しみ
               ですね? (訳注: いくつかある“Time zones”というタイトル
               の曲のことを言っているのかもしれません。))

          "Head, Body, All"
               これらの三つの合致のキーは `From' ヘッダー (など) と同じ
               合致の型を使います。

          "Followup"
               この合致のキーはやや特別で、それは `From' ヘッダーに合致
               し、合致した記事だけでなくその記事へのすべてのフォローアッ
               プのスコアにも影響します。これは例えば、あなた自身の記事
               へのフォローアップのスコアを増やしたり、良く知られた問題
               児へのフォローアップ記事のスコアを下げたりするのに使われ
               ます。`From' ヘッダーが使うのと同じ型の合致を使います。
               (この合致キーを使うと、`ADAPT' ファイルを作ることになり
               ます。)

          "Thread"
               この合致キーは `Followup' 合致キーと同じ方針に沿って動作
               します。`Message-ID' X で始まっているスレッド (または副
               スレッド) にスコアを付けたいのであれば、`thread' 合致を
               付け加えて下さい。これは `Reference' ヘッダーに X を持つ
               それぞれの記事に、新しい `thread' 合致を追加します。(こ
               れらの新しい `thread' 合致はこれらの合致する記事の
               `Message-ID' を使います。) これはスレッドのいくつかの記
               事が完全な `References' ヘッダーを持っていなかったとして
               も、スレッド全体のスコアを上げ/下げできることを保証しま
               す。これを使うと、スレッドの記事に決定的でないスコアが付
               くかもしれないということに注意して下さい。(この合致キー
               を使うと、`ADAPT' ファイルを作ることになります。)

`mark'
     このエントリーの値は数値でなければなりません。この数値より低いスコ
     アのどんな記事にも既読の印が付きます。

`expunge'
     このエントリーの値は数値でなければなりません。この数値より低いスコ
     アのどんな記事も概略バッファーから削除されます。

`mark-and-expunge'
     このエントリーの値は数値でなければなりません。この数値より低いスコ
     アのどんな記事にも既読の印が付き、概略バッファーから削除されます。

`thread-mark-and-expunge'
     このエントリーの値は数値でなければなりません。スコアの総計がこの数
     値より低いスレッドのすべての記事には既読の印が付き、概略バッファー
     から削除されます。`gnus-thread-score-function' はスレッドのスコア
     の総計をどのように計算するかを指定します。

`files'
     このエントリーの値は任意の数のファイル名でなければなりません。それ
     らのファイルもスコアファイルであるとみなされ、これがされたのと同じ
     方法で読み込まれます。

`exclude-files'
     このエントリーの手がかりは任意の数のファイル名でなければなりません。
     これらのファイルが何らかの理由で普通は読み込まれるようになっていた
     としても、読み込まれません。

`eval'
     このエントリーの値は `eval' (評価) されます。この要素はグローバル
     スコアファイルを扱っているときは無視されます。

`read-only'
     読み込み専用スコアファイルは更新されたり保存されたりしません。グロー
     バルスコアファイルはこのアトムを使用するべきです (*Note Global
     Score Files::)。(注意: 「グローバル」はここでは本当に「全体的」と
     いう意味です。個人的なすべてのグループに適用するスコアファイルのこ
     とではありません。)

`orphan'
     このエントリーの値は数値でなければなりません。親記事を持たない記事
     のスコアにこの数値が加えられます。`comp.lang.c' のような流通量の多
     いニュースグループを追いかけていると想像して下さい。おそらくほんの
     少しのスレッドだけを追いたいでしょう。さらに新しいスレッドは見たい
     でしょう。

     以下の二つのスコアファイルエントリーによって、それをすることができ
     ます:

                  (orphan -500)
                  (mark-and-expunge -100)

     最初にこのグループに入ったときは、新しいスレッドだけを見るでしょう。
     そうしたら、興味を持ったスレッドのスコアを上げ (`I T' または `I
     S' で)、残りを無視 (`C y') して下さい。次にグループに入ったときは、
     興味を持ったスレッドの新しい記事と、まったく新しいスレッドを見るこ
     とになります。

     すなわち orphan (孤児) スコアアトムは、普通のスコア規則では自動的
     に発見できない、興味深いスレッドが少し存在しする、流通量が多いグルー
     プのためにあります。

`adapt'
     このエントリーは適応スコア付けを制御します。これが `t' だったら、
     ディフォルトの適応スコア規則が使われます。`ignore' だったら、この
     グループでは適応スコア付けは行なわれません。もしリストだったら、そ
     のリストが適応スコア規則として用いられます。もしそれが存在しないか
     `t' や `ignore' 以外の何かだったら、ディフォルトの適応スコア規則が
     使われます。たいていのグループで適応スコア付けを使いたいのであれば、
     `gnus-use-adaptive-scorint' を `t' に設定し、適応スコア付けをした
     くないグループに `(adapt ignore)' を挿入すればよいでしょう。少しの
     グループでだけ適応スコアを行ないたいのであれば、
     `gnus-use-adaptive-scoring' を `nil' に設定し、それを行ないたいグ
     ループのスコアファイルに `(adaptive t)' を挿入しましょう。

`adapt-file'
     すべての適応スコア・エントリーは、このエントリーによって名づけられ
     たファイルに入ります。さらにそれはグループに入るときにも適用されま
     す。このアトムは、多くのグループで同じ適応スコアファイルを用いるこ
     とによって、複数のグループに一度に適応スコアを付けたいときに便利で
     しょう。

`local'
     このエントリーの値は `(VAR VALUE)' の形式の対のリストでなければな
     りません。それぞれの VAR は現在の概略バッファーでバッファーローカ
     ルになり、指定された値 (VALUE) に設定されます。これは少し風変わり
     ですが、フックがあまり好きでないならば、いくつかのグループで変数を
     設定するのに便利な方法です。VALUE は評価されないことに注意して下さ
     い。



