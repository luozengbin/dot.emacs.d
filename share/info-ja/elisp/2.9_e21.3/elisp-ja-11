Info file: elisp-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp-ja.texi'
using `texinfmt.el' version 2.41 of  1 Mar 2005.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Elisp-ja: (elisp-ja).	　　　　　　Emacs-Lisp 2.9日本語マニュアル.
END-INFO-DIR-ENTRY




Emacs Lispリファレンスマニュアル2.9版であり、Emacs 21.3版に対応します。

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
              2000, 2002 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.  A copy of the license is included in the section
entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have freedom to copy and modify
this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."




File: elisp-ja, Node: Button-Down Events, Next: Repeat Events, Prev: Drag Events, Up: Input Events

ボタン押し下げイベント
----------------------

クリックイベントとドラッグイベントは、ユーザーがマウスボタンを離したと
きに発生します。ボタンを離すまではクリックとドラッグを区別する方法がな
いため、ボタンを離すまで発生しえません。

ボタンを押し下げたらただちに動作を始めたい場合には、読者は"ボタン押し下
げ"（button-down）イベントを処理する必要があります。 (1) (*Note
Button-Down Events-Footnotes::) ボタンを押し下げるとただちに発生します。
それらは、シンボルEVENT-TYPEの名前に接頭辞`down-'があることを除けば、ク
リックイベント（*Note Click Events::）とまったく同じリストで表現されま
す。接頭辞`down-'は、`C-'や`M-'のような修飾キー接頭辞に続きます。

関数`read-key-sequence'は、
コマンドバインディングを持たないボタン押し下げイベントを無視します。
したがって、Emacsのコマンドループもそれらを無視します。
つまり、読者がボタン押し下げイベントでなにかをしたいのでなければ、
読者はボタン押し下げイベントを定義する必要はありません。
ボタン押し下げイベントを定義する理由は、
ボタンが離されるまで（モーションイベントを読んで）マウスの動きを
追跡するためです。
*Note Motion Events::。


File: elisp-ja  Node: Button-Down Events-Footnotes, Up: Button-Down Events

(1) 「ボタン押し下げ」は、「ドラッグ」の対句。



File: elisp-ja, Node: Repeat Events, Next: Motion Events, Prev: Button-Down Events, Up: Input Events

繰り返しイベント
----------------

マウスを動かさずに同一のマウスボタンを素早く連続して押し下げると、
Emacsは2回目以降の押し下げに対して特別な"繰り返し"（repeat）マウスイベ
ントを生成します。

もっとも一般的な繰り返しイベントは"ダブルクリック"（double-click）イベ
ントです。ボタンを2回クリックすると、Emcasはダブルクリックイベントを生
成します。（他のすべてのクリックイベントのように）読者がボタンを離した
ときにイベントが生成されます。

ダブルクリックイベントのイベント型には、接頭辞`double-'が含まれます。し
たがって、metaを押し下げて2番目のボタンをダブルクリックすると、Lispプロ
グラムには`M-double-mouse-2'が送られます。ダブルクリックイベントにバイ
ンディングがなければ、対応する普通のクリックイベントを用いて実行します。
したがって、実際に利用したくない限りは、読者はダブルクリック機能に注意
する必要はありません。

ユーザーがダブルクリックすると、Emacsはまず普通のクリックイベントを生成
し、つぎにダブルクリックイベントを生成します。したがって、ダブルクリッ
クイベントのコマンドバインディングでは、すでに普通のクリックコマンドが
動作済みであると仮定して設計する必要があります。普通のクリックの結果を
もとに望みのダブルクリックの結果を得るようにします。

普通のクリックの意味にダブルクリックの意味を『追加』するようにすると便
利です。ダブルクリックのユーザーインターフェイスはこのようにすることを
勧めます。

ボタンをクリックして、ふたたびボタンを押し下げてそのままマウスを動かす
と、最終的にボタンを離した時点で、"ダブルドラッグ"（double-drag）イベン
トが生成されます。そのイベント型には`drag'のかわりに`double-drag'が含ま
れます。ダブルドラッグイベントにバインディングがなければ、Emacsは普通の
ドラッグイベントとしてバインディングを探します。

ダブルクリックイベントやダブルドラッグイベントを生成するまえに、ユーザー
がボタンを2回目に押し下げたとき、Emacsは"ダブルダウン"（double-down）イ
ベントを生成します。このイベント型には`down'のかわりに`double-down'が含
まれます。ダブルダウンイベントにバインディングがなければ、Emacsは普通の
ボタン押し下げイベントとしてバインディングを探します。どちらでもバイン
ディングがみつからなければ、ダブルダウンイベントは無視します。

まとめると、ボタンをクリックしてただちに再度ボタンを押し下げると、
Emacsは、はじめのクリックに対してボタン押し下げイベントとクリックイベン
トを生成し、再度ボタンを押し下げるとダブルダウンイベントを生成し、最後
にダブルクリックイベントかダブルドラッグイベントを生成します。

ボタンを2回クリックしてから再度押し下げる操作を素早く行うと、Emacsは、
トリプルダウン"（triple-down）イベントに続けて"トリプルクリック
（triple-click）イベントか"トリプルドラッグ"（triple-drag）イベントを生
成します。これらのイベント型には`double'のかわりに`triple'が含まれます。
トリプルのイベントにバインディングがなければ、Emacsは対応するダブルのイ
ベントを使います。

ボタンを3回以上クリックしてから再度押し下げると、3回目以降の押し下げに
対するイベントはすべてトリプルのイベントです。Emacsは、クアドラプル（4
回）、クインタプル（5回）、…などのイベントは生成しません。しかし、イベ
ントリストを調べれば、ボタンを何回押したか正確にわかります。

 -- Function: event-click-count EVENT
     この関数は、イベントEVENTにおいてボタンが連続して押された回数を返
     す。EVENTが、ダブルダウンイベント、ダブルクリックイベント、ダブル
     ドラッグイベントであると、値は2である。EVENTがトリプルのイベントで
     あると、値は3かそれ以上である。EVENTが（繰り返しイベントではない）
     普通のマウスイベントであると、値は1である。

 -- Variable: double-click-time
     繰り返しイベントが生成されるためには、同じスクリーン位置において連
     続してマウスボタンを押し下げ、しかも、各押し下げの間隔は
     `double-click-time'の値未満（ミリ秒）である必要がある。
     `double-click-time'に`nil'を設定すると、連続したクリックの検出を禁
     止する。`t'を設定すると時間制限をなくし、Emacsは連続したクリックの
     検出を位置だけで行う。



File: elisp-ja, Node: Motion Events, Next: Focus Events, Prev: Repeat Events, Up: Input Events

モーションイベント
------------------

Emacsは、ボタン操作を伴わないマウスの移動を表す"マウスモーション
（mouse motion）イベントを生成することがあります。マウスモーションイベ
ントはつぎのようなリストで表現されます。

     (mouse-movement (WINDOW BUFFER-POS (X . Y) TIMESTAMP))

リストの2番目の要素は、クリックイベント（*Note Click Events::）と同様に、
マウスの現在位置を表します。

スペシャルフォーム`track-mouse'により、
その本体の内側ではモーションイベントの生成を可能にできます。
フォーム`track-mouse'の外側では、
Emacsはマウスの移動のみに対するイベントを生成しないので、
それらのイベントは現れません。
*Note Mouse Tracking::。



File: elisp-ja, Node: Focus Events, Next: Misc Events, Prev: Motion Events, Up: Input Events

フォーカスイベント
------------------

ウィンドウシステムは、どのウィンドウにキーボード入力を与えるかを
ユーザーが制御するための一般的な方法を提供します。
ウィンドウを選ぶことを"フォーカス"（focus）と呼びます。
ユーザーがEmacsのフレームを切り替える操作を行うと、
"フォーカスイベント"（focus event）が生成されます。
グローバルキーマップにあるフォーカスイベントの普通の定義は、
Emcasの新たなフレームを選択するようになっていて、
これはユーザーが期待することです。
*Note Input Focus::。

Lispでは、フォーカスイベントはつぎのようなリストで表現されます。

     (switch-frame NEW-FRAME)

ここで、NEW-FRAMEは切り替え先のフレームです。

Xのほとんどのウィンドウマネージャは、マウスをウィンドウへ入れるだけで当
該ウィンドウにフォーカスが設定されるようになっています。フレームにマウ
スが入るとカーソルの形状を変更するので、Emacsでもそのようにします。しか
し、Lispプログラムにとっては、なんらかの入力が到着するまではフォーカス
の変更について知る必要がありません。そのため、ユーザーが実際にキーボー
ドのキーを打つか新たなフレームでマウスボタンを押し下げたときだけ、
Emacsはフォーカスイベントを生成します。フレーム間でマウスを動かしただけ
では、フォーカスイベントは生成されません。

キー列の途中にフォーカスイベントが現れると、キー列を乱します。そのため、
Emacsはキー列の途中にはフォーカスイベントを生成しません。ユーザーがキー
列の途中で、つまり、プレフィックスキーのあとでフォーカスを変更すると、
複数イベントのキー列のまえかうしろにフォーカスイベントを移動し、途中に
は現れないようにEmacsはイベントの順序を並び替えます。



File: elisp-ja, Node: Misc Events, Next: Event Examples, Prev: Focus Events, Up: Input Events

ウィンドウシステムのその他のイベント
------------------------------------

ウィンドウシステム内で起きたことを表す他のイベントもあります。

`(delete-frame (FRAME))'
     この種のイベントは、Emacsのフレームであるウィンドウを削除するコマ
     ンドをユーザーがウィンドウマネージャに与えたことを表す。

     イベント`delete-frame'の標準定義はフレームFRAMEの削除である。

`(iconify-frame (FRAME))'
     この種のイベントは、ウィンドウマネージャを用いてユーザーがフレーム
     FRAMEをアイコン化したことを表す。これに対する標準定義は`ignore'で
     ある。というのは、フレームはすでにアイコンになっているので、Emacs
     が行うことはなにもないからである。このイベント型の目的は、必要なら
     ばその種のイベントを読者が追跡できるようにしておくことである。

`(make-frame-visible (FRAME))'
     この種のイベントは、ウィンドウマネージャを用いてユーザーがアイコン
     化したフレームFRAMEを開いたことを表す。これに対する標準定義は
     `ignore'である。というのは、フレームはすでに見えるようになっている
     ので、Emacsが行うことはなにもないからである。

`(mouse-wheel POSITION DELTA)'
     この種のイベントは、（MSインテリマウスなどの）マウスのホイールを動
     かすと生成される。その典型的な効果はスクロールやズーミングである。

     要素DELTAはホイールの回転方向と回転量である。その絶対値はホイール
     を回すごとに増加する数である。負のDELTAは、逆転、つまり、ユーザー
     へ近付く方向への回転を表し、正のDELTAは、順転、つまり、ユーザーか
     ら遠ざかる方向への回転を表す。

     要素POSITIONはイベントの発生位置を表し、マウスクリックイベントで使
     われる形式と同じである。

     この種のイベントは、ある種のシステムでのみ生成される。

`(drag-n-drop POSITION FILES)'
     この種のイベントは、Emacsの外側のアプリケーションで一群のファイル
     を選択し、それらをEmacsのフレームにドラッグ＆ドロップしたときに生
     成される。

     要素POSITIONはイベントの発生位置を表し、マウスクリックイベントで使
     われる形式と同じであり、要素FILESはドラッグ＆ドロップされたファイ
     ル名のリストである。このイベントを扱う通常の処理は、それらのファイ
     ルを訪問することである。

     現状では、この種のイベントは、ある種のシステムでのみ生成される。

これらのイベントがキー列の途中、つまり、プレフィックスキーのうしろに現
れると、複数イベントのキー列のまえかうしろに当該イベントを移動し、途中
には現れないようにEmacsはイベントの順序を並び替えます。



File: elisp-ja, Node: Event Examples, Next: Classifying Events, Prev: Misc Events, Up: Input Events

イベントの例
------------

ユーザーが同じ場所でマウスの左ボタンを押し下げてから離すと、つぎのよう
なイベント列が生成されます。

     (down-mouse-1 (#<window 18 on NEWS> 2613 (0 . 38) -864320))
     (mouse-1      (#<window 18 on NEWS> 2613 (0 . 38) -864180))

コントロールキーを押し下げた状態で、ユーザーがマウスの2番目のボタンを押
し下げ、マウスをつぎの行へドラッグすると、つぎのような2つのイベントが生
成されます。

     (C-down-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219))
     (C-drag-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219)
                     (#<window 18 on NEWS> 3510 (0 . 28) -729648))

メタキーとシフトキーを押し下げた状態で、ユーザーがマウスの2番目のボタン
をウィンドウのモード行で押し下げ、マウスを別のウィンドウへドラッグする
と、つぎのような2つのイベントが生成されます。

     (M-S-down-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844))
     (M-S-drag-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844)
                       (#<window 20 on carlton-sanskrit.tex> 161 (33 . 3)
                        -453816))



File: elisp-ja, Node: Classifying Events, Next: Accessing Events, Prev: Event Examples, Up: Input Events

イベントの分類
--------------

各イベントには"イベント型"（event type）があって、キーバインディング処
理のためにイベントを分類します。キーボードイベントでは、イベント型はイ
ベントの値に等しいです。したがって、文字に対するイベント型は文字であり、
ファンクションキーに対するイベント型はシンボルそのものです。リストであ
るイベントでは、イベント型はリストのCARにあるシンボルです。したがって、
イベント型はつねにシンボルか文字です。

イベント型が同じであるイベントは、キーバインディングに関する限り同じで
す。つまり、それらは同じコマンドを実行します。しかし、これは、それらが
必ずしも同じことを行うという意味ではありません。イベント全体を調べてな
にを行うかを決定するコマンドもあります。たとえば、マウスイベントの生起
位置を使って、バッファのどの部分を処理するかを決めるコマンドもあります。

イベントをおおまかに分類すると有用な場合もあります。
たとえば、他の修飾キーやマウスボタンには関係なしに、
METAキーが使われているイベントかどうか調べたいことがあるでしょう。

関数`event-modifiers'や`event-basic-type'は、そのような情報を便利に与え
るためのものです。

 -- Function: event-modifiers EVENT
     この関数は、EVENTにある修飾子のリストを返す。修飾子はシンボルであ
     り、`shift'、`control'、`meta'、`alt'、`hyper'、`super'である。さ
     らに、マウスイベントシンボルの修飾子リストには、必ず、`click'、
     `drag'、`down'の1つが含まれる。

     引数EVENTは、イベントオブジェクト全体であるか、単なるイベント型で
     ある。

     例を示す。

          (event-modifiers ?a)
               => nil
          (event-modifiers ?\C-a)
               => (control)
          (event-modifiers ?\C-%)
               => (control)
          (event-modifiers ?\C-\S-a)
               => (control shift)
          (event-modifiers 'f5)
               => nil
          (event-modifiers 's-f5)
               => (super)
          (event-modifiers 'M-S-f5)
               => (meta shift)
          (event-modifiers 'mouse-1)
               => (click)
          (event-modifiers 'down-mouse-1)
               => (down)

     クリックイベントに対する修飾子リストには`click'が明示的に含まれる
     が、イベントシンボルの名前自体には`click'は含まれない。

 -- Function: event-basic-type EVENT
     この関数は、EVENTにあるキーやマウスボタンを返す。たとえばつぎのと
     おり。

          (event-basic-type ?a)
               => 97
          (event-basic-type ?A)
               => 97
          (event-basic-type ?\C-a)
               => 97
          (event-basic-type ?\C-\S-a)
               => 97
          (event-basic-type 'f5)
               => f5
          (event-basic-type 's-f5)
               => f5
          (event-basic-type 'M-S-f5)
               => f5
          (event-basic-type 'down-mouse-1)
               => mouse-1

 -- Function: mouse-movement-p OBJECT
     この関数は、OBJECTがマウス移動のイベントならば`nil'以外を返す。

 -- Function: event-convert-list LIST
     この関数は、修飾子名と基本イベント型のリストをそれらが示すイベント
     型に変換する。たとえばつぎのとおり。

          (event-convert-list '(control ?a))
               => 1
          (event-convert-list '(control meta ?a))
               => -134217727
          (event-convert-list '(control super f1))
               => C-s-f1



File: elisp-ja, Node: Accessing Events, Next: Strings of Events, Prev: Classifying Events, Up: Input Events

イベントの参照
--------------

本節では、マウスボタンイベントやモーションイベント内のデータを参照する
ための便利な関数について述べます。

つぎの2つの関数は、以下の形式のリストであるマウスボタンイベントの開始位
置や終了位置を返します。

     (WINDOW BUFFER-POSITION (X . Y) TIMESTAMP)

 -- Function: event-start EVENT
     イベントEVENTの開始位置を返す。

     EVENTがクリックイベントやボタン押し下げイベントであると、
     イベントの位置を返す。
     EVENTがドラッグイベントであると、ドラッグの開始位置を返す。

 -- Function: event-end EVENT
     イベントEVENTの終了位置を返す。

     EVENTがドラッグイベントであると、ユーザーがマウスボタンを離したと
     きの位置を返す。EVENTがクリックイベントかボタン押し下げイベントで
     あると、実際の値は開始位置であり、その種のイベントにある唯一の位置
     情報である。

つぎの5つの関数は、上に述べた位置情報のリストを引数として、そのさまざま
な部分を返す。

 -- Function: posn-window POSITION
     POSITION内のウィンドウを返す。

 -- Function: posn-point POSITION
     POSITIONのバッファ内位置を返す。これは整数である。

 -- Function: posn-x-y POSITION
     POSITION内のピクセル単位のxy座標をコンスセル`(X . Y)'として返す。

 -- Function: posn-col-row POSITION
     POSITIONの（文字単位の）行（row）とコラム（col）の座標をコンスセル
     `(COL . ROW)'として返す。これらは実際にはPOSITION内のXとYの値から
     計算される。

 -- Function: posn-timestamp POSITION
     POSITION内の時刻情報を返す。

つぎの関数はスクロールバーでのイベントを解読するのに便利です。

 -- Function: scroll-bar-event-ratio EVENT
     スクロールバー内でのイベントから、スクロールバーに対する縦方向の位
     置を返す。その値は2つの整数を含むコンスセル`(PORTION . WHOLE)'であ
     り、その比は位置の割合を表す。

 -- Function: scroll-bar-scale RATIO TOTAL
     この関数は（実質的には）RATIOにTOTALを掛け、結果を整数に丸める。引
     数RATIOは数ではなく`(NUM . DENOM)'であり、典型的には
     `scroll-bar-event-ratio'が返す値である。

     この関数はスクロールバー内での位置をバッファ内での位置へ換算するの
     に便利である。つぎのように行う。

          (+ (point-min)
             (scroll-bar-scale
                (posn-x-y (event-start event))
                (- (point-max) (point-min))))

     スクロールバー内でのイベントには、xy座標のかわりに比を表す2つの整
     数があることに注意。



File: elisp-ja, Node: Strings of Events, Prev: Accessing Events, Up: Input Events

キーボードイベントを文字列で保持する
------------------------------------

文字列が使われるほとんどの場面では、文字列にはテキスト文字、つまり、バッ
ファやファイルにある文字と同じ種類のものが入っていると考えています。文
字列にはキーボード文字が入っているとみなして使うLispプログラムもありま
す。たとえば、文字列には、キー列やキーボードマクロの定義が入っているの
です。しかし、キーボード文字を文字列に保持するのは複雑であり、それは歴
史的な互換性を保つためにするのであり、また、つねに可能とは限りません。

新しいプログラムでは、キーボードイベントを文字列に保持しないで、このよ
うな複雑さを避けるように推奨します。つぎのようにします。

   * キー列に対しては、それらを`lookup-key'や`define-key'に対する
     引数以外にも使うつもりならば、文字列のかわりにベクトルを使う。
     たとえば、`read-key-sequence'のかわりに`read-key-sequence-vector'を
     `this-command-keys'のかわりに`this-command-keys-vector'を使う。

   * メタ文字を含むキー列は、それらを`define-key'に直接渡す場合であって
     も、ベクトルで書く。

   * 文字列である可能性があるキー列の内容を調べるときには、
     `listify-key-sequence'（*Note Event Input Misc::）を使って、それを
     リストに変換しておく。

複雑さの原因は、キーボード入力に含まれる修飾ビットにあります。メタ修飾
子以外の修飾ビットを文字列に入れることは不可能であり、メタ修飾子は特別
な場合として唯一許されているのです。

初期のGNU Emacsでは、メタ文字を128から255の範囲のコードで表現していまし
た。その当時、基本文字コードは0から127でしたから、キーボード文字のすべ
てのコードは文字列に収まったのです。多くのLispプログラムでメタ文字を表
すために文字列定数内で`\M-'を使い、特に、`define-key'や類似の関数に対す
る引数に使われ、キー列やイベント列はつねに文字列で表現されていました。

127を超える大きな基本文字コードと追加の修飾ビットを扱えるようにしたとき、
メタ文字の表現方法を変更せざるをえませんでした。現在、メタ修飾子を表す
文字内のビットは2**27 であり、そのような数を文字列に入れることはできま
せん。

文字列定数で`\M-'を使っているプログラムを扱えるように、文字列にメタ文字
を入れるための特別な規則があります。以下は、文字列を入力文字の列として
解釈するための規則です。

   * キーボード文字の値が0から127の範囲にあれば、無変更で文字列に入れる。

   * コードが2**27 から2**27+127, の範囲にあるこれらの文字のメタ変種は
     文字列に入れられるが、それらの数値を変更する必要がある。ビット
     2**27 のかわりに2**7 ビットに変更し、128から255の範囲の値にする。
     ユニバイト文字列だけにこれらのコードを入れられる。

   * 256以上の非ASCII文字はマルチバイト文字列だけに入れられる。

   * その他のキーボード文字イベントは文字列に収められない。これには、
     128から255の範囲のキーボードイベントも含む。

キーボード入力文字の文字列を作る`read-key-sequence'などの関数はつぎの規
則に従います。つまり、文字列に収まらないイベントであるときには、文字列
のかわりにベクトルを作ります。

読者が文字列で`\M-'の入力構文を使うと、それらは128から255の範囲のコード
になります。対応するキーボードイベントを文字列に保存するように変更した
ときに得られるコードと同じです。したがって、文字列内のメタイベントは、
それらがどのように文字列に収められたかに関わらず、整合性のある動作をし
ます。

しかし、本節のはじめに述べた推奨方法に従ってこれらのことがらを避けるほ
うが、ほとんどのプログラムはよりよく動作するでしょう。



File: elisp-ja, Node: Reading Input, Next: Special Events, Prev: Input Events, Up: Command Loop

入力の読み取り
==============

エディタコマンドループは、
関数`read-key-sequence'を使ってキー列を読み取ります。
なお、関数`read-key-sequence'は関数`read-event'を使います。
これらやイベント入力を扱う他の関数は、Lispプログラムからも使えます。
*Note Temporary Displays::の`momentary-string-display'、
および、*Note Waiting::の`sit-for'を参照してください。
端末の入力モードの制御や端末入力のデバッグに関する関数や変数については、
*Note Terminal Input::。
入力イベントを読むときにそれらを変換したり修正する機能については、
*Note Translating Input::。

上位レベルの入力機能については、*Note Minibuffers::を参照してください。

* Menu:

* Key Sequence Input::		How to read one key sequence.
* Reading One Event::		How to read just one event.
* Quoted Character Input::	Asking the user to specify a character.
* Event Input Misc::	How to reread or throw away input events.



File: elisp-ja, Node: Key Sequence Input, Next: Reading One Event, Prev: Reading Input, Up: Reading Input

キー列の入力
------------

コマンドループは、`read-key-sequence'を呼ぶことでキー列の入力を読み取り
ます。Lispプログラムからこの関数を呼び出してもよく、たとえば、
`describe-key'は、説明対象とするキーを読むためにこの関数を使います。

 -- Function: read-key-sequence PROMPT
     この関数は、キー列を読み取り文字列かベクトルとして返す。完全なキー
     列を収集し終えるまで、つまり、現在活性なキーマップにおいて、非プレ
     フィックスコマンドを指定するのに十分になるまで、イベントを読み続け
     る。

     イベントがすべて文字であり、かつ、それらが文字列に収まるならば、
     `read-key-sequence'は文字列（*Note Strings of Events::）を返す。さ
     もなければ、ベクトルを返す。ベクトルならば、任意の種類のイベント、
     つまり、文字、シンボル、リストを保持できるからである。文字列やベク
     トルの要素は、キー列のイベントである。

     引数PROMPTは、プロンプトとしてエコー領域に表示する文字列であるか、
     あるいは、プロンプトを表示しないことを意味する`nil'である。

     以下の例では、プロンプト`?'がエコー領域に表示され、ユーザーは`C-x
     C-f'と打つ。

          (read-key-sequence "?")

          ---------- Echo Area ----------
          ?C-x C-f
          ---------- Echo Area ----------

               => "^X^F"

     関数`read-key-sequence'は中断を抑止する。
     この関数が動作中に`C-g'を打っても、他の文字と同様に扱い、
     `quit-flag'を設定しない。
     *Note Quitting::。

 -- Function: read-key-sequence-vector PROMPT
     これは`read-key-sequence'と同様であるが、
     つねにベクトルとしてキー列を返し、文字列としてはけっして返さない。
     *Note Strings of Events::。

入力文字が大文字であって、それらにキーバインディングがないとき、
対応する小文字にキーバインディングがあれば、
`read-key-sequence'は文字を小文字に変換します。
`lookup-key'はこのような変換を行わないことに注意してください。

関数`read-key-sequence'は、ある種のマウスイベントも変換します。バインディ
ングのないドラッグイベントをクリックイベントに変換したり、バインディン
グのないボタン押し下げイベントを完全に無視します。さらに、フォーカスイ
ベントとその他のウィンドウイベントを並び替えて、それらが他のイベントの
キー列の途中に現れないようにします。

マウスイベントが、モード行やスクロールバーなどのウィンドウの特別な部分
で生起しても、特別なイベント型はなく、マウスボタンや修飾キーの組み合わ
せを普通どおりに表したシンボルです。ウィンドウのどの部分かに関する情報
は、イベント内の別の部分、つまり、座標に入っています。しかし、
`read-key-sequence'は、その情報をシンボル`mode-line'、`vertical-line'、
`horizontal-scroll-bar'、`vertical-scroll-bar'を用いた仮想的な『プレ
フィックスキー』に変換します。ウィンドウの特別な部分におけるマウスクリッ
クの意味は、これらの仮想的なプレフィックスキーを用いてキー列を定義する
ことで定義できます。

たとえば、`read-key-sequence'を呼び出してから、ウィンドウのモード行でク
リックすると、つぎのような2つのイベントを得ます。

     (read-key-sequence "Click on the mode line: ")
          => [mode-line
              (mouse-1
               (#<window 6 on NEWS> mode-line
                (40 . 63) 5959987))]

 -- Variable: num-input-keys
     この変数の値は、現在のEmacsセッションにおいて、これまでに処理され
     たキー列の個数である。これには、端末から読み取ったキー列、および、
     実行したキーボードマクロから読み取ったキー列が含まれる。

 -- Variable: num-nonmacro-input-events
     この変数は、端末からこれまでに受け取った入力イベントの総個数を保持
     する。キーボードマクロで生成されたものは含まない。



File: elisp-ja, Node: Reading One Event, Next: Quoted Character Input, Prev: Key Sequence Input, Up: Reading Input

単一イベントの読み取り
----------------------

コマンド入力用の最低レベルの関数は、単一イベントを読み取る関数です。

 -- Function: read-event &optional PROMPT SUPPRESS-INPUT-METHOD
     この関数は、必要ならばイベントの到着を待って、コマンド入力のつぎの
     イベントを読み取って返す。イベントは、ユーザーか（実行中の）キーボー
     ドマクロから直接得る。

     PROMPTが`nil'以外であると、
     これはプロンプトとしてエコー領域に表示される文字列であること。
     さもなければ、`read-event'は
     入力待ちであることを示すメッセージを表示せずに、
     そのかわりに、現在のコマンドを実行するに至ったイベントや
     現在のコマンドが読み取ったイベントをプロンプトとして表示する。
     *Note The Echo Area::。

     SUPPRESS-INPUT-METHODが`nil'以外であると、
     このイベントの読み取りに関しては現在の入力方式を使わない。
     入力方式の処理をせずにイベントを読みたいときには、
     つねにこのようにすること。
     `input-method-function'を束縛してはならない（下記参照）。

     変数`cursor-in-echo-area'が`nil'以外であると、`read-event'は、エコー
     領域に表示されたメッセージの末尾にカーソルを一時的に移動する。さも
     なければ、`read-event'はカーソルを移動しない。

     `read-event'がヘルプ文字と定義されたイベントを受け取ると、
     それを返さずに`read-event'がイベントを直接処理してしまう場合がある。
     *Note Help Functions::。
     "特殊イベント"（special event）と呼ばれる他のイベントも
     `read-event'が直接処理する（*Note Special Events::）。

     `read-event'を呼んで右矢印のファンクションキーを押すとつぎのようになる。

          (read-event)
               => right

 -- Function: read-char
     この関数はコマンド入力の文字を読み取りそれを返す。文字を得るまで、
     文字以外のイベントはすべて破棄する。

     最初の例では、ユーザーは文字`1'（ASCIIコード49）を打つ。2番目の例
     は、`eval-expression'を使ってミニバッファから`read-char'を呼び出す
     キーボードマクロの定義である。`read-char'はキーボードマクロの直後
     の文字、つまり、`1'を読む。そして、`eval-expression'はその戻り値を
     エコー領域に表示する。

          (read-char)
               => 49

          ;; これを評価するために読者はM-:を使うと仮定する
          (symbol-function 'foo)
               => "^[:(read-char)^M1"
          (execute-kbd-macro 'foo)
               -| 49
               => nil

`read-event'は、あれば現在の入力方式も起動します。
`input-method-function'が`nil'以外であれば、それは関数であるはずです。
`read-event'が修飾ビットのない（SPCを含む）印字文字を読み取ると、引数と
してイベントを渡してその関数を呼び出します。

 -- Variable: input-method-function
     これが`nil'以外であると、その値は現在の入力方式関数を指定する。

     *注意：*` ' この変数を`let'で束縛しないこと。この変数はしばしばバッ
     ファローカルであり、入力を読む周囲で束縛すると（読者がこれをもっと
     も束縛*しそうな*ところ）、Emacsが入力を待っているときにバッファが
     非同期に切り替わると、誤ったバッファに値を復元してしまうことがある。

入力方式関数は、入力として使われるイベントのリストを返すべきです。（リ
ストが`nil'であると入力がなかったことを意味し、`read-event'は別のイベン
トを待つ。）これらのイベントは、`unread-command-events'内のイベントより
まえに処理されます。入力方式関数が返したイベントは、それらが修飾ビット
がない印字文字であっても、入力方式関数に再度渡されることはありません。

入力方式関数が`read-event'や`read-key-sequence'を呼び出すときには、
`input-method-function'を`nil'に束縛して再帰呼び出しを防ぐべきです。

キー列の2番目以降のイベントを読むときには、入力方式関数を呼び出しません。
したがって、それらの文字は、入力方式処理の対象ではありません。入力方式
の処理では、`overriding-local-map'と`overriding-terminal-local-map'の値
を検査するのがよいです。これらの変数のいずれかが`nil'以外であるときには、
入力方式ではその引数をリストに入れ、それ以上処理せずにそのリストを返す
べきです。



File: elisp-ja, Node: Quoted Character Input, Next: Event Input Misc, Prev: Reading One Event, Up: Reading Input

クォートした文字の入力
----------------------

ユーザーに文字入力を促して、コントロール文字やメタ文字を文字そのものや
文字の8進数コードで手軽に入力できるようにするには、関数
`read-quoted-char'を使います。コマンド`quoted-insert'は、この関数を使っ
ています。

 -- Function: read-quoted-char &optional PROMPT
     この関数は`read-char'に似ているが、最初に読んだ文字が8進数字文字
     （0-7）であると、任意個数の8進数字文字を読み取り（8進数字文字以外
     が現れると止める）、その数値の文字コードが表す文字を返す。

     最初の文字を読むと中断を抑制するので、
     ユーザーは`C-g'を入力できる。
     *Note Quitting::。

     PROMPTを与えると、それはユーザーへのプロンプトを表す文字列を指定す
     る。プロンプト文字列はつねにエコー領域に表示され、あとに`-'が続く。

     つぎの例では、ユーザーは8進数177（10進数では127）を打つ。

          (read-quoted-char "What character")

          ---------- Echo Area ----------
          What character-177
          ---------- Echo Area ----------

               => 127



File: elisp-ja, Node: Event Input Misc, Prev: Quoted Character Input, Up: Reading Input

その他のイベント入力機能
------------------------

本節では、イベントを処理せずに『まえもって覗き見』する方法、処理待ちの
入力の有無の検査方法、処理待ちの入力の破棄方法について述べます。関数
`read-passwd'も参照してください（*Note Reading a Password::）。

 -- Variable: unread-command-events
     この変数は、コマンド入力として読まれることを待っているイベントのリ
     ストを保持する。イベントはリストに現れる順に使われ、使われると1つ
     1つ取り除かれる。

     関数でイベントを読んだあとにそれを使わない場面があるため、この変数
     が必要になる。この変数にイベントを保存すると、コマンドループやコマ
     ンド入力を読む関数によって通常どおり処理される。

     たとえば、数値前置引数を実現する関数は、任意個数の数字文字を読み取
     る。数字文字でないイベントをみつけたら、そのイベントを読み戻して、
     コマンドループが通常どおりに読めるようにする必要がある。同様に、イ
     ンクリメンタルサーチでは、この機能を使って探索においては意味を持た
     ないイベントを読み戻す。なぜなら、そのようなイベントは探索を終了さ
     せ、通常どおり実行される必要があるからである。

     `unread-command-events'に入れられるように
     キー列からイベントを確実に簡単に取り出す方法は
     `listify-key-sequence'を使うことである（*Note Strings of Events::）。

     もっとも最近に読み戻したイベントが最初に再度読まれるように、普通は
     このリストの先頭にイベントを追加する。

 -- Function: listify-key-sequence KEY
     この関数は、文字列やベクトルであるKEYを個々のイベントのリストに変
     換する。この結果は`unread-command-events'に入れられる。

 -- Variable: unread-command-char
     この変数は、コマンド入力として読まれる文字を保持する。値「-1」は、
     『空』を意味する。

     この変数はほとんど廃れており、かわりに`unread-command-events'を使
     うべきである。Emacs 18版以前向けに書かれたプログラムを扱うためだけ
     に存在する。

 -- Function: input-pending-p
     この関数は、現在、コマンド入力があるかどうかを調べる。ただちに返る
     が、入力があれば値`t'を、さもなければ`nil'を返す。入力がないのに
     `t'を返すことが稀にある。

 -- Variable: last-input-event
 -- Variable: last-input-char
     この変数は、コマンドの一部として、あるいは、Lispプログラムが明示的
     に読み取った最後の端末入力イベントを記録する。

     以下の例で、Lispプログラムは文字`1'（ASCIIコード49）を読む。
     それが`last-input-event'の値になるが、
     （この式を評価するコマンドは`C-x C-e'と仮定するので）
     `last-command-event'の値は`C-e'のままである。

          (progn (print (read-char))
                 (print last-command-event)
                 last-input-event)
               -| 49
               -| 5
               => 49

     Emacs 18版との互換性のために、別名`last-input-char'が存在する。

 -- Function: discard-input
     この関数は端末入力バッファの内容を廃棄し、定義中のキーボードマクロ
     を取り消す。これは`nil'を返す。

     以下の例で、フォームを評価しはじめてから、ユーザーは何文字か打つ。
     `sleep-for'が待機を終えると、
     `discard-input'は待機中に打たれた文字をすべて破棄する。

          (progn (sleep-for 2)
                 (discard-input))
               => nil



File: elisp-ja, Node: Special Events, Next: Waiting, Prev: Reading Input, Up: Command Loop

特殊イベント
============

特殊イベントは、読まれるとただちに非常に低レベルで処理されます。関数
`read-event'はこれらのイベントをそれ自身で処理してしまい、それらを返す
ことはありません。

このように処理されるイベントは表示されることはなく、キー列に組み込まれ
ることもなく、`last-command-event'や`(this-command-keys)'の値に現れるこ
ともありません。特殊イベントが数値引数を破棄することはなく、
`unread-command-events'で読み戻すことはできません。特殊イベントがキーボー
ドマクロに現れることはなく、読者がキーボードマクロを定義しているときに、
特殊イベントがキーボードマクロに記録されることはありません。

しかし、それらのイベントは、読まれた直後には`last-input-event'に現れま
すから、これからイベントの定義で実際のイベントを見ることができます。

`iconify-frame'、`make-frame-visible'、`delete-frame'のイベント型は、通
常このように処理されます。特殊イベントをどのように処理するか、どのイベ
ントが特殊イベントであるかを定義するキーマップは変数
`special-event-map'にあります（*Note Active Keymaps::）。



File: elisp-ja, Node: Waiting, Next: Quitting, Prev: Special Events, Up: Command Loop

時間待ちと入力待ち
==================

待機関数は、指定時間経過するか入力がくるまで待つように設計してあります。
たとえば、ユーザーに表示を眺める時間を与えるために計算途中で休止したい
でしょう。`sit-for'は、休止してスクリーンを更新し、入力がくるとただちに
戻ります。一方、`sleep-for'はスクリーンを更新せずに休止します。

 -- Function: sit-for SECONDS &optional MILLISEC NODISP
     この関数は（処理待ちのユーザーからの入力がなければ）再表示を行い、
     SECONDS秒休止するか、入力がくるまで待つ。入力がこずに（*Note
     Event Input Misc::の`input-pending-p'を参照）指定時間だけ休止した
     場合は、戻り値は`t'である。さもなければ、戻り値は`nil'である。

     引数SECONDSは整数である必要はない。それが浮動小数点数であると、
     `sit-for'は秒の小数も待つ。秒単位しか扱えないシステムもあり、その
     ようなシステムではSECONDSを秒に切り下げる。

     省略可能な引数MILLISECは、ミリ秒単位の追加待ち時間を指定する。
     これはSECONDSで指定した時間に加えられる。
     秒未満を扱えないシステムでは、
     MILLISECに0以外を指定するとエラーになる。

     入力がくると再表示をつねに取り止め、再表示開始まえに入力がくると、
     いっさい再表示しない。したがって、処理待ちの入力があると、再表示を
     強制する方法はない。しかし、処理待ちの入力がなければ、`(sit-for
     0)'で再表示を強制できる。

     NODISPが`nil'以外であると、`sit-for'は再表示はしないが、入力がくる
     とただちに（あるいは指定時間だけ経過すると）戻る。

     フレームをアイコンにしたりアイコンにしたフレームを開くと
     イベントが生成されるため、`sit-for'は戻る。
     *Note Misc Events::。

     `sit-for'の普通の目的は、読者が表示したテキストを読む時間をユーザー
     に与えることである。

 -- Function: sleep-for SECONDS &optional MILLISEC
     この関数は表示を更新せずに単にSECONDS秒だけ休止する。
     入力にはいっさい注意を払わない。
     `nil'を返す。

     引数SECONDSは整数である必要はない。それが浮動小数点数であると、
     `sleep-for'は秒の小数も待つ。秒単位しか扱えないシステムもあり、そ
     のようなシステムではSECONDSを秒に切り下げる。

     省略可能な引数MILLISECは、ミリ秒単位の追加待ち時間を指定する。
     これはSECONDSで指定した時間に加えられる。
     秒未満を扱えないシステムでは、
     MILLISECに0以外を指定するとエラーになる。

     遅延を保証したい場合に`sleep-for'を使う。

現在時刻を取得する関数については*Note Time of Day::。



File: elisp-ja, Node: Quitting, Next: Prefix Command Arguments, Prev: Waiting, Up: Command Loop

中断
====

Lisp関数が動作中に`C-g'を打つと、Emacsがなにを行っていても"中断"を引き
起こします。つまり、もっとも内側の活性なコマンドループに制御が戻ります。

コマンドループがキーボード入力を待っているときに`C-g'を打っても、中断を
引き起こさずに、普通の入力文字として動作します。もっとも単純な場合、
`C-g'はコマンド`keyboard-quit'を実行しますが、その効果は中断を引き起こ
すことですから、読者には区別できないはずです。しかし、プレフィックスキー
に続けて`C-g'を打つと、それらは組み合わされて未定義キーになります。その
効果は、前置引数を含めてプレフィックスキーを取り消します。

ミニバッファでは、`C-g'には別の定義があって、
ミニバッファを強制終了させます。
つまり、ミニバッファから抜け出て中断します。
（単に中断したのでは、ミニバッファ*内で*
コマンドループに戻るだけである。）
コマンドループで入力を読んでいるときに`C-g'で直接中断しない理由は、
このようにミニバッファでその意味を再定義できるようにするためです。
ミニバッファでは、プレフィックスキーに続く`C-g'は再定義してなく、
プレフィックスキーと前置引数を取り消すという通常の効果を持ちます。
`C-g'がつねに直接中断するのでは、このようにすることさえ不可能です。

`C-g'が直接に中断するときには、変数`quit-flag'に`t'を設定します。Emacs
はこの変数を適切なときに検査し`nil'でないと中断します。したがって、
`quit-flag'に`nil'以外を設定すると中断を引き起こします。

Cのコードのレベルでは、どこでも中断できるわけではありません。
`quit-flag'を検査している特別な箇所だけです。このようにするのは、それ以
外の箇所で中断するとEmacsの内部状態に矛盾をきたす可能性があるからです。
中断は安全な場所まで延期されるので、中断によってEmcasがクラッシュするこ
とはありません。

`read-key-sequence'や`read-quoted-char'などのある種の関数は、
入力を待っている場合であっても中断を完全に抑制します。
中断するかわりに、`C-g'は入力として働きます。
`read-key-sequence'の場合、コマンドループにおいて
`C-g'の特別なふるまいをもたらします。
`read-quoted-char'の場合、
`C-q'で`C-g'をクォートできるようになります。

変数`inhibit-quit'に`nil'以外の値を束縛することでLisp関数のある部分にお
いて中断を抑制できます。そうすると、`C-g'はそれでもいつもどおり
`quit-flag'を`t'にしますが、その通常の結果である中断は抑制されます。最
終的にフォーム`let'の終りで束縛が解除されるなどして`inhibit-quit'が再度
`nil'になります。その時点でも`quit-flag'が`nil'以外であると要求した中断
がただちに起こります。このふるまいは、プログラムの『臨界領域』では中断
が起こらないことを保証する理想的なものです。

（`read-quoted-char'などの）ある種の関数では、`C-g'は特別に処理され中断
を引き起こしません。`inhibit-quit'に`t'を束縛して入力を読み取り、
`inhibit-quit'が再度`nil'になるまえに`quit-flag'を`nil'にすることでその
ようにします。これを`read-quoted-char'の定義の以下の抜粋で示しましょう。
最初の入力文字のあとで通常の中断を許す方法も示しています。

     (defun read-quoted-char (&optional prompt)
       "...DOCUMENTATION..."
       (let ((message-log-max nil) done (first t) (code 0) char)
         (while (not done)
           (let ((inhibit-quit first)
                 ...)
	(and prompt (message "%s-" prompt))
	(setq char (read-event))
	(if inhibit-quit (setq quit-flag nil)))
           ...変数`code'に設定する...)
         code))

 -- Variable: quit-flag
     `inhibit-quit'が`nil'であれば、この変数が`nil'以外であるとEmacsは
     ただちに中断する。`C-g'は、`inhibit-quit'に関わらず、通常、
     `quit-flag'に`nil'以外を設定する。

 -- Variable: inhibit-quit
     この変数は、`quit-flag'が`nil'以外の値に設定されたときに
     Emacsが中断すべきかどうかを決定する。
     `inhibit-quit'が`nil'以外であると、
     `quit-flag'に特別な意味はない。

 -- コマンド: keyboard-quit
     この関数は`(signal 'quit nil)'で`quit'条件を通知する。これは中断と
     同じことを行う。（*Note Errors::の`signal'を参照。）

中断として使う`C-g'以外の特殊文字を使えます。
*Note Terminal Input::の関数`set-input-mode'を参照してください。



File: elisp-ja, Node: Prefix Command Arguments, Next: Recursive Editing, Prev: Quitting, Up: Command Loop

前置コマンド引数
================

Emacsのほとんどのコマンドは、"前置引数"（prefix argument）、つまりコマ
ンド自身のまえに指定された数を利用できます。（前置引数とプレフィックス
キーを混同しないこと。）前置引数はつねに値で表現され、`nil'であると現在
は前置引数がないことを表します。各コマンドは、前置引数を使ってもよいし、
無視してもかまいません。

前置引数には2つの表現方法があります。"生"（raw）と"数値"（numeric）です。
エディタコマンドループでは、内部的には生の表現を使い、その情報を保持す
るLisp変数もそのようにしますが、コマンドではどちらの表現を要求してもか
まいません。

生の前置引数の値にはつぎの可能性があります。

   * 前置引数がないことを意味する`nil'。その数値としての値は1であるが、
     多くのコマンドでは`nil'と整数1を区別する。

   * それ自身が表す整数。

   * 整数を要素とする1要素のリスト。この形式の前置引数は、数字文字なし
     の1個以上の`C-u'の結果である。リスト内の数値は整数であるが、そのよ
     うなリストと整数のみを区別するコマンドもある。

   * シンボル`-'。数字文字なしに`M--'や`C-u -'を打ったことを表す。これ
     に等価な数値は-1であるが、整数-1とシンボル`-'を区別するコマンドも
     ある。

いろいろな前置引数でつぎの関数を呼び出す例を示します。

     (defun display-prefix (arg)
       "Display the value of the raw prefix arg."
       (interactive "P")
       (message "%s" arg))

以下は、生の前置引数で`display-prefix'を呼び出した結果です。

             M-x display-prefix  -| nil

     C-u     M-x display-prefix  -| (4)

     C-u C-u M-x display-prefix  -| (16)

     C-u 3   M-x display-prefix  -| 3

     M-3     M-x display-prefix  -| 3      ; （`C-u 3'と同じ）

     C-u -   M-x display-prefix  -| -

     M--     M-x display-prefix  -| -      ; （`C-u -'と同じ）

     C-u - 7 M-x display-prefix  -| -7

     M-- 7   M-x display-prefix  -| -7     ; （`C-u -7'と同じ）

Emacsは、前置引数を保持するために2つの変数、`prefix-arg'と
`current-prefix-arg'を使います。他のコマンド向けに前置引数を設定する
`universal-argument'などのコマンドは、前置引数を`prefix-arg'に保持しま
す。対照的に、`current-prefix-arg'には現在のコマンドに対して前置引数を
運ぶ役割があり、この変数に設定しても以後のコマンドに対する前置引数には
なんの効果もありません。

通常、コマンドは、`interactive'宣言により、「生」か「数値」のいずれの表
現の前置引数を使うか指定します。（*Note Using Interactive::。）あるいは、
変数`current-prefix-arg'にある前置引数の値を関数から直接見てもかまいま
せんが、これは見通しのよい方法ではありません。

 -- Function: prefix-numeric-value ARG
     この関数は、有効な生の前置引数の値ARGからそれに等価な数値を返す。
     引数は、シンボル、数、リストのいずれかである。それが`nil'であると、
     戻り値は1である。`-'であると、戻り値は-1である。数であると、その数
     を返す。リストであると、リストの（数であるはずの）CARを返す。

 -- Variable: current-prefix-arg
     この変数は、*現在の*コマンドに対する生の前置引数を保持する。コマン
     ドが直接この変数を調べてもよいが、前置引数を参照する普通の方法は
     `(interactive "P")'を使うことである。

 -- Variable: prefix-arg
     この変数の値は、*つぎの*編集コマンド向けの生の前置引数である。後続
     のコマンド向けの前置引数を指定する`universal-argument'などのコマン
     ドは、この変数に設定することで動作する。

 -- Variable: last-prefix-arg
     まえのコマンドで使われた生の前置引数の値。

つぎのコマンドは、後続のコマンド向けの前置引数を設定するためのものです。
それ以外の目的には呼ばないでください。

 -- コマンド: universal-argument
     このコマンドは入力を読み取り、後続のコマンド向けの前置引数を指定す
     る。なにをしているか理解していない限り、読者自身でこのコマンドを呼
     ばないこと。

 -- コマンド: digit-argument ARG
     このコマンドは、後続のコマンド向けの前置引数に追加する。引数ARGは、
     このコマンドが呼び出されるまえの生の前置引数であり、前置引数を更新
     する計算に使われる。なにをしているか理解していない限り、読者自身で
     このコマンドを呼ばないこと。

 -- コマンド: negative-argument ARG
     このコマンドは、後続のコマンド向けの数値前置引数に追加する。引数
     ARGは、このコマンドが呼び出されるまえの生の前置引数であり、その値
     の符号を変えて新たな前置引数とする。なにをしているか理解していない
     限り、読者自身でこのコマンドを呼ばないこと。



File: elisp-ja, Node: Recursive Editing, Next: Disabling Commands, Prev: Prefix Command Arguments, Up: Command Loop

再帰編集
========

Emacsが動作を始めると、Emacsのコマンドループに自動的に入ります。このトッ
プレベルのコマンドループからはけっして抜けることはなく、Emacsが動いてい
る限り動作し続けます。Lispプログラムからコマンドループを起動することも
できます。そうすると、活性なコマンドループが複数作られることになるので、
それを"再帰編集"（recursive editing）と呼びます。再帰編集レベルには、そ
れを起動したコマンドを一時休止させ、当該コマンドを再開するまでユーザー
にどんな編集でも許す効果があります。

再帰編集中に利用可能なコマンドは、トップレベルのコマンドループと同じも
のでありキーマップで定義されます。再帰編集を抜けるための数個の特別なコ
マンドがあり、完了すると再帰編集レベルから抜ける別のコマンドもあります。
（再帰編集を抜けるコマンドはつねに利用可能であるが、再帰編集中でないと
なにも行わない。）

再帰編集を含むすべてのコマンドループでは、コマンドループから実行したコ
マンドのエラーによってコマンドループから抜け出さないように汎用目的のエ
ラーハンドラを設定します。

ミニバッファでの入力は、特別な種類の再帰編集です。これには、ミニバッファ
やミニバッファ用ウィンドウを表示するなどの特別な処理がありますが、読者
が考えるよりは少ないのです。ミニバッファでは特別なふるまいをするキーも
ありますが、それらはミニバッファのローカルマップによるものです。ウィン
ドウを切り替えると、Emacsの普通のコマンドを使えます。

再帰編集レベルを起動するには、関数`recursive-edit'を呼び出します。
この関数にはコマンドループが含まれています。
さらに、`exit'を伴った`catch'の呼び出しもあり、
これにより、`exit'へ投げることで
再帰編集レベルから抜け出せるようになっています
（*Note Catch and Throw::）。
`t'以外の値を投げると、`recursive-edit'は、
呼び出し側の関数へ普通に戻ります。
コマンド`C-M-c'（`exit-recursive-edit'）は、これを行います。
値`t'を投げると`recursive-edit'に中断を引き起こし、
1つ上のレベルのコマンドループへ制御を戻します。
これを"強制終了"（aborting）と呼び、
`C-]'（`abort-recursive-edit'）で行えます。

ミニバッファを使う場合を除いて、ほとんどのアプリケーションでは再帰編集
を使うべきではありません。カレントバッファのメジャーモードを一時的な特
別なメジャーモードに変更するほうが、一般にはユーザーにとってより便利で
す。ただし、当該メジャーモードには、まえのモードに戻るコマンドを用意し
ておきます。（rmailのコマンド`e'は、この方式を使っている。）あるいは、
『再帰的に』編集する別のテキストをユーザーに与えたい場合には、特別なモー
ドの新たなバッファを作成してそれを選択します。当該モードには、処理を終
えてまえのバッファに戻るコマンドを定義しておきます。（rmailのコマンド
`m'は、このようにする。）

再帰編集はデバッグに便利です。
ブレークポイントの一種として関数定義に
`debug'の呼び出しを挿入しておくと、
その箇所に達したときにいろいろと調べられます。
`debug'は再帰編集を起動しますが、デバッガとしての機能も提供します。

`query-replace'で`C-r'を打ったり、`C-x q'（`kbd-macro-query'）を使った
ときにも再帰編集レベルが使われます。

 -- Function: recursive-edit
     この関数はエディタコマンドループを起動する。Emacsの初期化過程で自
     動的に呼び出され、ユーザーが編集できるようにする。Lispプログラムか
     ら呼ばれると、再帰編集レベルに入る。

     以下の例では、関数`simple-rec'は、まず1単語分ポイントを進め、
     エコー領域にメッセージを表示して再帰編集に入る。
     そうすると、ユーザーは望むことはなんでもできるようになり、
     （再帰編集を）抜けるために`C-M-c'を打つと、
     `simple-rec'の実行を継続する。

          (defun simple-rec ()
            (forward-word 1)
            (message "Recursive edit in progress")
            (recursive-edit)
            (forward-word 1))
               => simple-rec
          (simple-rec)
               => nil

 -- コマンド: exit-recursive-edit
     この関数は、（ミニバッファでの入力を含む）もっとも内側の再帰編集か
     ら抜ける。その関数定義は実質的には`(throw 'exit nil)'である。

 -- コマンド: abort-recursive-edit
     この関数は、再帰編集から抜けたあとで`quit'を通知することで、
     （ミニバッファでの入力を含む）もっとも内側の再帰編集を
     要請したコマンドを強制終了する。
     その関数定義は実質的には`(throw 'exit t)'である。
     *Note Quitting::。

 -- コマンド: top-level
     この関数は、すべての再帰編集を抜ける。すべての計算を抜け出てメイン
     のコマンドループへ直接戻るため、値は返さない。

 -- Function: recursion-depth
     この関数は再帰編集の現在の深さを返す。活性な再帰編集がなければ0を
     返す。



File: elisp-ja, Node: Disabling Commands, Next: Command History, Prev: Recursive Editing, Up: Command Loop

コマンドを禁止する
==================

"コマンドを禁止する"とは、コマンドを実行するまえにユーザーの確認を必要
とするようにコマンドに印を付けることです。コマンドを禁止するのは、初心
者に混乱をもたらす可能性のあるコマンドに対してや、コマンドの誤用を防ぐ
ためです。

コマンドを禁止する低レベルの機構は、コマンドのLispシンボルに`nil'以外の
属性`disabled'を入れることです。これらの属性は、通常、ユーザーの
`.emacs'ファイルにてつぎのようなLisp式で設定します。

     (put 'upcase-region 'disabled t)

数個のコマンドにはデフォルトでこれらの属性がありますから、
`.emacs'ファイルで属性を取り除きます。

属性`disabled'の値は文字列であり、コマンドを禁止したことを表すメッセー
ジです。たとえばつぎのとおりです。

     (put 'delete-region 'disabled
          "Text deleted this way cannot be yanked back!\n")

禁止したコマンドを対話的に起動するとどうなるかについて詳しくは*Note 使
用禁止コマンド: (emacs)Disabling。コマンドを禁止しても、Lispプログラム
から関数として呼び出すことにはなんの影響もありません。

 -- コマンド: enable-command COMMAND
     これ以降、特別な確認なしにCOMMANDを実行可能にする。さらに（ユーザー
     が了承すれば）ユーザーの`.emacs'ファイルを変更して、将来のセッショ
     ンでもそのようにする。

 -- コマンド: disable-command COMMAND
     これ以降、COMMANDの実行には特別な確認を必要とするようにする。さら
     に（ユーザーが了承すれば）ユーザーの`.emacs'ファイルを変更して、将
     来のセッションでもそのようにする。

 -- Variable: disabled-command-hook
     禁止したコマンドをユーザーが対話的に起動したとき、
     禁止したコマンドのかわりにこのノーマルフックを実行する。
     フック関数では、`this-command-keys'を使って
     コマンドを実行するためにユーザーがなにを入力したかを調べ、
     コマンドそのものを探し出せる。
     *Note Hooks::。

     デフォルトでは、`disabled-command-hook'には、ユーザーに処理を進め
     るかどうかを問い合わせる関数が入っている。



File: elisp-ja, Node: Command History, Next: Keyboard Macros, Prev: Disabling Commands, Up: Command Loop

コマンド履歴
============

コマンドループでは、実行した複雑なコマンドの履歴を管理していて、それら
のコマンドを簡単に繰り返せるようにしています。"複雑なコマンド"とは、ミ
ニバッファを使って引数を読むコマンドです。これには、任意の`M-x'コマンド、
任意の`M-:'コマンド、ミニバッファから引数を読み取る`interactive'指定を
持つ任意のコマンドが含まれます。コマンド自身の実行中に明示的にミニバッ
ファを使っても、複雑なコマンドとはみなしません。

 -- Variable: command-history
     この変数の値は、最近使った複雑なコマンドのリストであり、各要素は評
     価すべきフォームを表す。編集セッション中は、すべての複雑なコマンド
     を集積するが、（変数`history-length'で指定される）最大サイズに達す
     ると新しい要素を追加するたびに古い要素を削除する。

          command-history
          => ((switch-to-buffer "chistory.texi")
              (describe-key "^X^[")
              (visit-tags-table "~/emacs/src/")
              (find-tag "repeat-complex-command"))

この履歴リストは、実際にはミニバッファ履歴（*Note Minibuffer History::）
の特別な場合です。要素は文字列ではなく式なのです。

まえのコマンドを編集したり取り出すための専用コマンドがたくさんあります。
コマンド`repeat-complex-command'と`list-command-history'は、ユーザーマ
ニュアル（*Note ミニバッファコマンドの繰り返し: (emacs)Repetition.）に
説明してあります。ミニバッファ内では、通常のミニバッファ履歴コマンドを
使えます。



File: elisp-ja, Node: Keyboard Macros, Prev: Command History, Up: Command Loop

キーボードマクロ
================

"キーボードマクロ"は、コマンドとみなせる入力イベントのまとまった列であ
り、キーの定義から構成されます。Lispにおけるキーボードマクロの表現は、
イベントを含んだ文字列やベクトルです。キーボードマクロとLispマクロ
（*Note Macros::）を混同しないでください。

 -- Function: execute-kbd-macro KBDMACRO &optional COUNT
     この関数はキーボードマクロKBDMACROをイベント列として実行する。
     KBDMACROが文字列かベクトルであると、その中のイベントをユーザーが入
     力した場合とまったく同様に実行する。列は単一のキーイベントである必
     要は*ない*。通常、キーボードマクロの定義は、複数のキー列を連結した
     ものである。

     KBDMACROがシンボルであると、KBDMACROのかわりにその関数定義を用いる。
     それがさらに別のシンボルであると、この処理を繰り返す。最終的な結果
     は、文字列かベクトルであること。結果がシンボルでも文字列でもベクト
     ルでもないと、エラーを通知する。

     引数COUNTは繰り返し回数であり、
     KBDMACROをその回数だけ実行する。
     COUNTを省略するか`nil'であると、KBDMACROを1回実行する。
     COUNTが0であると、
     KBDMACROの実行をエラーに出会うか探索に失敗するまで繰り返す。

     `execute-kbd-macro'を使った例については*Note Reading One Event::。

 -- Variable: executing-macro
     この変数は、現在実行中のキーボードマクロの定義である文字列やベクト
     ルを保持する。これが`nil'であると、現在実行中のマクロはない。コマ
     ンドでこの変数を検査することで、マクロ実行で起動されたときのふるま
     いを変更できる。読者自身はこの変数に設定しないこと。

 -- Variable: defining-kbd-macro
     この変数は、キーボードマクロを定義中かどうかを表す。コマンドでこの
     変数を検査することで、マクロ定義中のふるまいを変更できる。コマンド
     `start-kbd-macro'と`end-kbd-macro'がこの変数に設定する。読者自身は
     設定しないこと。

     この変数は現在の端末に対してつねにローカルであり、
     バッファに対してローカルにはならない。
     *Note Multiple Displays::。

 -- Variable: last-kbd-macro
     この変数は、もっとも最近に定義されたキーボードマクロの定義である。
     その値は、文字列かベクトル、あるいは、`nil'である。

     この変数は現在の端末に対してつねにローカルであり、
     バッファに対してローカルにはならない。
     *Note Multiple Displays::。




File: elisp-ja, Node: Keymaps, Next: Modes, Prev: Command Loop, Up: Top

キーマップ
**********

入力イベントとコマンドとのバインディング（対応）は、"キーマップ
（keymap）と呼ばれるデータ構造に記録されています。キーマップの各バイン
ディング（あるいは"バインド"（bind））は、個々のイベント型を別のキーマッ
プかコマンドに対応付けます。イベント型のバインディングがキーマップであ
ると、後続の入力イベントを探すためにそのキーマップを使います。コマンド
がみつかるまで、これを繰り返します。この処理全体を"キー探索"（key
lookup）と呼びます。

* Menu:

* Keymap Terminology::	Definitions of terms pertaining to keymaps.
* Format of Keymaps::		What a keymap looks like as a Lisp object.
* Creating Keymaps::		Functions to create and copy keymaps.
* Inheritance and Keymaps::	How one keymap can inherit the bindings
				   of another keymap.
* Prefix Keys::                 Defining a key with a keymap as its definition.
* Active Keymaps::	        Each buffer has a local keymap
                                   to override the standard (global) bindings.
				   A minor mode can also override them.
* Key Lookup::                  How extracting elements from keymaps works.
* Functions for Key Lookup::    How to request key lookup.
* Changing Key Bindings::       Redefining a key in a keymap.
* Key Binding Commands::        Interactive interfaces for redefining keys.
* Scanning Keymaps::            Looking through all keymaps, for printing help.
* Menu Keymaps::		Defining a menu as a keymap.



File: elisp-ja, Node: Keymap Terminology, Next: Format of Keymaps, Prev: Keymaps, Up: Keymaps

キーマップの用語
================

"キーマップ"（keymap）は、イベント型を定義に対応させる表です。（この定
義は任意のLispオブジェクトであるが、コマンドループによる実行においては、
特定の型のみが意味を持つ）。与えられたイベント（あるいはイベント型）と
キーマップから、Emacsはイベントの定義を得ることができます。イベントは、
文字、ファンクションキー、マウス操作です（*Note Input Events::）。

ある単位を構成する入力イベントの列を"キー列"（key sequence）、あるいは、
略して"キー"（key）と呼びます。単一イベントから成る列はつねにキー列であ
り、複数イベント列もキー列です。

キーマップは、任意のキー列に対するバインディング、つまり、定義を決定し
ます。キー列が単一イベントから成るとき、そのバインディングはキーマップ
内の当該イベントの定義です。複数のイベントから成るキー列のバインディン
グは、繰り返し処理で探します。つまり、最初のイベントのバインディングを
探すと、それはキーマップであるはずです。続いて、そのキーマップから2番目
のイベントのバインディングを探します。これをキー列のすべてのイベントを
使い尽くすまで行います

キー列のバインディングがキーマップであると、そのキー列を"プレフィックス
キー"（prefix key）と呼びます。さもなければ、（追加できるイベントがない
ので）"完全なキー"（complete key）と呼びます。バインディングが`nil'であ
ると、キーは"未定義"であるといいます。プレフィックスキーの例は、`C-c'、
`C-x'、`C-x 4'です。定義されている完全なキーの例は、`X'、RET、`C-x 4
C-f'です。未定義な完全なキーの例は、`C-x C-g'と`C-c 3'です。詳しくは、
*Note Prefix Keys::。

キー列のバインディングを探す際の規則では、
（最後のイベントのまえまでにみつかる）途中のバインディングは
すべてキーマップであると仮定します。
これが満たされないと、イベントの列があるまとまりを構成せず、
1つのキー列になりません。
いいかえれば、有効なキー列の末尾からいくつかのイベントを取りさると、
つねにプレフィックスキーになる必要があります。
たとえば、`C-f C-n'はキー列ではありません。
`C-f'はプレフィックスキーではないので、
`C-f'で始まる列はキー列ではありません。

複数イベントから成るキー列の候補は、プレフィックスキーのバインディング
に依存します。したがって、キーマップが異なればそれらは異なり、バインディ
ングを変更するとそれらは変わります。しかし、単一イベントから成る列は、
プレフィックスに依存しないので、つねにキー列です。

ある時点には、複数個の主キーマップが活性です。つまり、キーバインディン
グの探索に使われます。それらは、すべてのバッファが共有する"グローバルマッ
プ"（global map）、特定のメジャーモードに関連付けられた"ローカルマップ
（local keymap）、現在オンにしてあるマイナモードに属する"マイナモードキー
マップ"（minor mode keymaps）です。（すべてのマイナモードにキーマップが
あるわけではない。）ローカルキーマップのバインディングは、対応するグロー
バルなバインディングを隠します（つまり優先する）。マイナモードキーマッ
プは、ローカルとグローバルの両方のキーマップを隠します。詳しくは*Note
Active Keymaps::。



File: elisp-ja, Node: Format of Keymaps, Next: Creating Keymaps, Prev: Keymap Terminology, Up: Keymaps

キーマップの形式
================

キーマップは、そのCARがシンボル`keymap'であるリストです。リストの残りの
要素がキーマップのキーバインディングを定義します。オブジェクトがキーマッ
プであるかどうか検査するには、関数`keymapp'（下記参照）を使います。

キーマップでは、シンボル`keymap'のうしろに、さまざまな種類の要素が現れ
ます。

`(TYPE . BINDING)'
     イベント型TYPEに対する1つのバインディングを指定する。
     普通の各バインディングは、文字やシンボルである特定の"イベント型"に
     適用される。
     *Note Classifying Events::。

`(t . BINDING)'
     "デフォルトのキーバインディング"を指定する。キーマップの他の要素に
     一致しない任意のイベントには、そのバインディングとして指定した
     BINDINGを与える。デフォルトのバインディングにより、すべてを列挙せ
     ずに可能なすべてのイベントにバインドできる。デフォルトのバインディ
     ングを有するキーマップは、任意の低優先順位のキーマップを隠してしま
     う。

`VECTOR'
     キーマップの要素がベクトルであると、当該ベクトルをASCII文字全体、
     つまり、コード0から127に対するバインディングとみなす。ベクトルのN
     番目の要素は、コードNの文字に対するバインディングである。これは、
     多くのバインディングを記録するコンパクトな方法である。このようなベ
     クトルのキーマップを"完全なキーマップ"（full keymap）と呼ぶ。それ
     以外のキーマップを"疎なキーマップ"（sparse keymaps）と呼ぶ。

     キーマップにベクトルがあると、ベクトルの要素が`nil'であってもベク
     トルが各ASCII文字のバインディングをつねに定義する。そのような
     `nil'のバインディングは、ASCII文字に対してはキーマップのデフォルト
     のキーバインディングを無効にする。しかし、ASCII文字以外のイベント
     に対しては、デフォルトのバインディングが意味を持つ。`nil'のバイン
     ディングが低優先順位のキーマップを隠すことは*ない*。つまり、ローカ
     ルマップが`nil'のバインディングを与えると、Emacsはグローバルマップ
     のバインディングを使う。

`STRING'
     バインディングに加えて、
     キーマップでは、要素として文字列を持つこともできる。
     これを"全面プロンプト文字列"（overall prompt string）と呼び、
     キーマップをメニューとして使うことを可能にする。
     *Note Menu Keymaps::。

キーマップは、メタ文字に対するバインディングを直接には記録していません。
そのかわりに、キー探索においては、メタ文字は2文字から成る列とみなし、
先頭文字はESC（あるいは、`meta-prefix-char'の現在値）です。
つまり、キー`M-a'は実際には`ESC a'と表現され、
そのグローバルなバインディングは
`esc-map'の`a'でみつかります（*Note Prefix Keys::）。

Lispモードに対するローカルキーマップの例を示します。これは疎なキーマッ
プです。DEL、TAB、`C-c C-l'、`M-C-q'、`M-C-x'に対するバインディングを定
義しています。

     lisp-mode-map
     =>
     (keymap
      ;; TAB
      (9 . lisp-indent-line)
      ;; DEL
      (127 . backward-delete-char-untabify)
      (3 keymap
         ;; C-c C-l
         (12 . run-lisp))
      (27 keymap
          ;; M-C-qはESC C-qとみなされる
          (17 . indent-sexp)
          ;; M-C-xはESC C-xとみなされる
          (24 . lisp-send-defun)))

 -- Function: keymapp OBJECT
     この関数は、OBJECTがキーマップであれば`t'を返し、さもなければ
     `nil'を返す。より正確には、この関数は、そのCARが`keymap'であるリス
     トかどうかを検査する。

          (keymapp '(keymap))
              => t
          (keymapp (current-global-map))
              => t



File: elisp-ja, Node: Creating Keymaps, Next: Inheritance and Keymaps, Prev: Format of Keymaps, Up: Keymaps

キーマップの作成
================

ここでは、キーマップを作成するための関数について述べます。

 -- Function: make-keymap &optional PROMPT
     この関数は新たに完全なキーマップ
     （つまり、すべてのASCII文字に対する定義を収めた
     長さ128のベクトル）を作成しそれを返す。
     新たなキーマップでは、すべてのASCII文字に対するバインディングは
     `nil'であり、それ以外の種類のイベントに対するバインディングはない。

          (make-keymap)
              => (keymap [nil nil nil ... nil nil])

     PROMPTを指定すると、それはキーマップに対する全面プロンプト文字列に
     なる。全面プロンプト文字列はメニューキーマップ（*Note Menu
     Keymaps::）に有用である。

 -- Function: make-sparse-keymap &optional PROMPT
     この関数は、新たに空の疎なキーマップを作成しそれを返す。新たなキー
     マップにはイベントに対するバインディングはいっさいない。引数
     PROMPTは、`make-keymap'の場合同様、プロンプト文字列を指定する。

          (make-sparse-keymap)
              => (keymap)

 -- Function: copy-keymap KEYMAP
     この関数はKEYMAPのコピーを返す。KEYMAPにバインディングとして直接現
     れる任意のキーマップも任意のレベルまで再帰的にコピーされる。しかし、
     文字に対する定義が、その関数定義がキーマップであるようなシンボルに
     出会うと再帰的なコピーを行わないため、同じシンボルが新たなコピーに
     も現れる。

          (setq map (copy-keymap (current-local-map)))
          => (keymap
               ;; (これはメタ文字を意味する)
               (27 keymap
                   (83 . center-paragraph)
                   (115 . center-line))
               (9 . tab-to-tab-stop))

          (eq map (current-local-map))
              => nil
          (equal map (current-local-map))
              => t



File: elisp-ja, Node: Inheritance and Keymaps, Next: Prefix Keys, Prev: Creating Keymaps, Up: Keymaps

継承とキーマップ
================

キーマップでは、"親キーマップ"（parent keymap）と呼ぶ別のキーマップのバ
インディングを継承できます。そのようなキーマップはつぎのようになります。

     (keymap BINDINGS... . PARENT-KEYMAP)

このキーマップは、キーを探索する時点においてPARENT-KEYMAPが有するすべて
のバインディングを継承しますが、それらにはBINDINGSが追加されたり優先し
ます。

`define-key'や他のキーバインディング関数でPARENT-KEYMAPのバインディング
を変更すると、それらの変更は、BINDINGSで隠されない限り継承側のキーマッ
プからも見えます。その逆は真ではありません。`define-key'で継承側のキー
マップを修正すると、それはBINDINGSに影響するだけでPARENT-KEYMAPには影響
しません。

親キーマップを用いたキーマップを作成する正しい方法は、
`set-keymap-parent'を使うことです。
親キーマップを用いたキーマップを直接作成するようなコードがある場合には、
`set-keymap-parent'を用いるようにプログラムを変更してください。

 -- Function: keymap-parent KEYMAP
     この関数は、キーマップKEYMAPの親キーマップを返す。
     KEYMAPに親がなければ`keymap-parent'は`nil'を返す。

 -- Function: set-keymap-parent KEYMAP PARENT
     キーマップKEYMAPの親キーマップとしてPARENTを設定し、PARENTを返す。
     PARENTが`nil'であると、この関数はKEYMAPに親キーマップをいっさい与
     えない。

     KEYMAPに（プレフィックスキー用のバインディングである）サブマップが
     あれば、それらもPARENTが指定するプレフィックスキーを反映する新たな
     親マップを受け取る。

`text-mode-map'からキーマップを継承する方法を示します。

     (let ((map (make-sparse-keymap)))
       (set-keymap-parent map text-mode-map)
       map)



File: elisp-ja, Node: Prefix Keys, Next: Active Keymaps, Prev: Inheritance and Keymaps, Up: Keymaps

プレフィックスキー
==================

"プレフィックス"（prefix key）とは、そのバインディングがキーマップであ
るキー列のことです。そのキーマップが、プレフィックスキー以降のキーでな
にをするかを定義します。たとえば、`C-x'はプレフィックスキーであり、変数
`ctl-x-map'に保持されたキーマップを使います。このキーマップは、`C-x'で
始まるキー列に対するバインディングを定義します。

Emacsの標準プレフィックスキーのなかには、Lisp変数にも保持されたキーマッ
プを使うものがあります。

   * `esc-map'は、プレフィックスキーESC用のグローバルマップである。した
     がって、すべてのメタ文字のグローバルな定義はここにある。このキーマッ
     プは`ESC-prefix'の関数定義でもある。

   * `help-map'は、プレフィックスキー`C-h'に対するグローバルキーマップ
     である。

   * `mode-specific-map'は、プレフィックスキー`C-c'に対するグローバルキー
     マップである。このキーマップは実際にはグローバルでありモード固有で
     はないが、その名前は、`C-h b'（`display-bindings'）の出力において
     `C-c'に関する有用な情報を与える。というのは、このプレフィックスキー
     の主な用途は、モード固有のバインディングのためだからである。

   * `ctl-x-map'は、プレフィックスキー`C-x'に対して使われるグローバルキー
     マップである。このキーマップは、シンボル`Control-X-prefix'の関数セ
     ルに現れる。

   * `mule-keymap'は、プレフィックスキー`C-x RET'に対して使われるグロー
     バルキーマップである。

   * `ctl-x-4-map'は、プレフィックスキー`C-x 4'に対して使われるグローバ
     ルキーマップである。

   * `ctl-x-5-map'は、プレフィックスキー`C-x 5'に対して使われるグローバ
     ルキーマップである。

   * `2C-mode-map'は、プレフィックスキー`C-x 6'に対して使われるグローバ
     ルキーマップである。

   * `vc-prefix-map'は、プレフィックスキー`C-x v'に対して使われるグロー
     バルキーマップである。

   * `facemenu-keymap'は、プレフィックスキー`M-g'に対して使われるグロー
     バルキーマップである。

   * Emacsには、他にも、`C-x @'、`C-x a i'、`C-x ESC'、`ESC ESC'のプレ
     フィックスキーがある。これらは、特別な名前を持たないキーマップを使
     う。

プレフィックスキーのキーマップバインディングは、当該プレフィックスキー
に続くイベントを探すために使われます。（その関数定義がキーマップである
シンボルでもよい。効果は同じであるが、シンボルはプレフィックスキーに対
する名前として働く。）したがって、`C-x'のバインディングはシンボル
`Control-X-prefix'であり、その関数セルがコマンド`C-x'用のキーマップを保
持している。（`ctl-x-map'の値も同じキーマップである。）

プレフィックスキーの定義は、任意の活性なキーマップにあってかまいません。
プレフィックスキーとしての`C-c'、`C-x'、`C-h'、ESCの
定義はグローバルマップにあるので、これらのプレフィックスキーは
つねに利用できます。
メジャーモードやマイナモードでは、
プレフィックスキーの定義をローカルキーマップや
マイナモードキーマップに入れることで、
キーをプレフィックスとして再定義できます。
*Note Active Keymaps::。

複数の活性なキーマップにおいて、キーがプレフィックスと定義されていると、
さまざまな定義は実質的には併合されます。マイナモードキーマップで定義さ
れたコマンドが最優先で、つぎにローカルマップのプレフィックス定義、そし
てグローバルマップのプレフィックス定義が続きます。

以下の例では、ローカルキーマップにおいて、`C-p'を`C-x'に等価なプレフィッ
クスキーにします。続いて`C-p C-f'のバインディングを`C-x C-f'のように関
数`find-file'にします。キー列`C-p 6'はどの活性なキーマップでもみつかり
ません。

     (use-local-map (make-sparse-keymap))
         => nil
     (local-set-key "\C-p" ctl-x-map)
         => nil
     (key-binding "\C-p\C-f")
         => find-file

     (key-binding "\C-p6")
         => nil

 -- Function: define-prefix-command SYMBOL
     この関数は、SYMBOLをプレフィックスキーのバインディングとして使える
     ように準備する。つまり、完全なキーマップを作成し、SYMBOLの関数定義
     にそのキーマップを保存する。以後、SYMBOLにキー列をバインドすると、
     当該キー列をプレフィックスキーに入る。

     この関数は、変数としてのSYMBOLにも値としてキーマップを設定する。
     SYMBOLを返す。




File: elisp-ja, Node: Active Keymaps, Next: Key Lookup, Prev: Prefix Keys, Up: Keymaps

活性なキーマップ
================

Emacsには、通常、たくさんのキーマップがあります。ある時点では、それらの
数個が"活性"になっていて、ユーザー入力の解釈に関与します。それらは、グ
ローバルキーマップ、カレントバッファのローカルキーマップ、オンになって
いるマイナモードのキーマップです。

"グローバルキーマップ"（global keymap）は、`C-f'のようなカレントバッファ
に依存せずに定義されたキーのバインディングを保持します。変数
`global-map'はこのキーマップを保持していて、このキーマップはつねに活性
です。

各バッファには別のキーマップ、つまり、
バッファの"ローカルキーマップ"（local keymap）があり、
キーに対する新しい定義や無効にする定義を保持しています。
カレントバッファのローカルキーマップは、
`overriding-local-map'で無効にしない限り、つねに活性です。
テキスト属性により、バッファの特定部分に対する
代替ローカルマップを指定できます。
*Note Special Properties::を参照してください。

各マイナモードもキーマップを持てます。その場合、マイナモードがオンであ
ると当該キーマップは活性です。

変数`overriding-local-map'が`nil'以外であると、バッファのローカルキーマッ
プとそのすべてのマイナモードキーマップに取ってかわるローカルキーマップ
を指定します。

キーが入力されるとどのコマンドを実行するかを決定するために、
すべての活性なキーマップを一緒に使います。
Emacsは、キーマップの1つでバインディングがみつかるまで、
優先順位が高いほうからこれらのキーマップを1つ1つ探索します。
1つのキーマップで探索する処理のことを
"キー探索"（key lookup）といいます。
*Note Key Lookup::を参照してください。

通常、Emacsはまず`minor-mode-map-alist'で指定される順にマイナモードキー
マップでキーを探します。キーに対するバインディングがなければ、Emacsはロー
カルキーマップで探します。そこにもバインディングがなければ、Emacsはグロー
バルキーマップで探します。しかし、`overriding-local-map'が`nil'以外であ
れば、Emacsはまずそのキーマップで探してから、グローバルキーマップで探し
ます。

同じメジャーモードを使う各バッファは、通常、同じローカルキーマップを使
うので、キーマップはモードにローカルであると考えることができます。（た
とえば`local-set-key'を使って）バッファのローカルキーマップを修正すると、
当該キーマップを共有している別のバッファでもその修正が見えます。

Lispモードや他の数個のメジャーモードで使われるローカルキーマップは、そ
れらのモードがまだ使われていなくても存在します。そのようなローカルキー
マップは、`lisp-mode-map'などの変数の値です。使用頻度の低いほとんどのメ
ジャーモードでは、セッションで始めてそのモードを使ったときにローカルキー
マップを作成します。

ミニバッファにもローカルキーマップがあります。
それにはさまざまな補完コマンドや脱出コマンドが含まれます。
*Note Intro to Minibuffers::。

Emacsには、別の用途のキーマップもあります。
`read-key-sequence'でイベントを変換するためのものです。
*Note Translating Input::。

標準的なキーマップの一覧については*Note Standard Keymaps::。

 -- Variable: global-map
     この変数は、Emacsがキーボード入力をコマンドに対応させるためのデフォ
     ルトのグローバルキーマップを保持する。グローバルキーマップは、通常、
     このキーマップである。デフォルトのグローバルキーマップは、すべての
     印字文字に`self-insert-command'をバインドする完全なキーマップであ
     る。

     グローバルマップのバインディングを修正することは実用的ですが、この
     変数には、動作開始時のキーマップ以外の値は設定しないこと。

 -- Function: current-global-map
     この関数は、現在のグローバルキーマップを返す。`global-map'を変更し
     ていなければ、これは`global-map'の値と同じである。

          (current-global-map)
          => (keymap [set-mark-command beginning-of-line ...
                      delete-backward-char])

 -- Function: current-local-map
     この関数は、カレントバッファのローカルキーマップを返す。
     なければ`nil'を返す。
     つぎの例では、（lisp対話モードを使っている）バッファ`*scratch*'の
     キーマップは疎なキーマップであり、
     ASCIIコード27のESCに対する指定も別の疎なキーマップである。

          (current-local-map)
          => (keymap
              (10 . eval-print-last-sexp)
              (9 . lisp-indent-line)
              (127 . backward-delete-char-untabify)
              (27 keymap
                  (24 . eval-defun)
                  (17 . indent-sexp)))

 -- Function: current-minor-mode-maps
     この関数は、現在オンになっているマイナモードのキーマップのリストを
     返す。

 -- Function: use-global-map KEYMAP
     この関数は、キーマップKEYMAPを新たな現在のグローバルキーマップとす
     る。これは`nil'を返す。

     グローバルキーマップを変更することは、とうてい普通のことではない。

 -- Function: use-local-map KEYMAP
     この関数は、キーマップKEYMAPをカレントバッファの新たなローカルキー
     マップとする。KEYMAPが`nil'であると、バッファにはローカルキーマッ
     プがなくなる。`use-local-map'は`nil'を返す。ほとんどのメジャーモー
     ドコマンドは、この関数を使う。

 -- Variable: minor-mode-map-alist
     この変数は、変数の値に応じて活性になっている／いないキーマップを記
     述する連想リストである。その要素はつぎの形である。

          (VARIABLE . KEYMAP)

     変数VARIABLEの値が`nil'以外であれば、
     キーマップKEYMAPは活性である。
     典型的には、VARIABLEはマイナモードをオン／オフする変数である。
     *Note Keymaps and Minor Modes::。

     `minor-mode-map-alist'の要素と`minor-mode-alist'の要素とは、異なる
     構造であることに注意してほしい。キーマップは要素のCDRである必要が
     あり、要素のCADRがキーマップであるようなリストではだめである。
     CADRは、（リストの）キーマップであるか、関数定義がキーマップである
     シンボルである。

     複数のマイナモードキーマップが活性な場合、それらの優先順位は、
     `minor-mode-map-alist'での順番である。読者は、互いに干渉しないよう
     にマイナモードを設計する必要がある。正しくできていれば、順序は関係
     ないはずである。

     マイナモードについて詳しくは*Note Keymaps and Minor Modes::を参照。
     `minor-mode-key-binding'（*Note Functions for Key Lookup::）も参照のこと。

 -- Variable: minor-mode-overriding-map-alist
     この変数は、メジャーモードから特定のマイナモード向けのキーバインディングを
     無効にするためのものである。
     この連想リストの要素は、`minor-mode-map-alist'の要素と同じ形で、
     `(VARIABLE . KEYMAP)'である。

     `minor-mode-overriding-map-alist'の要素として変数が現れると、当該
     要素が指定するキーマップで、`minor-mode-map-alist'内の同じ変数で指
     定したキーマップを完全に置き換える。

     `minor-mode-overriding-map-alist'は、すべてのバッファにおいて、自
     動的にバッファにローカルになる。

 -- Variable: overriding-local-map
     `nil'以外の値であると、この変数は、バッファのローカルキーマップ、
     ならびに、すべてのマイナモードキーマップのかわりに用いるキーマップ
     を保持する。このキーマップは、現在のグローバルキーマップを除く、他
     のすべての活性なキーマップを無効にする。

 -- Variable: overriding-terminal-local-map
     `nil'以外であると、この変数は、`overriding-local-map'、および、バッ
     ファのローカルキーマップとすべてのマイナモードキーマップのかわりに
     用いるキーマップを保持する。

     この変数はつねに現在の端末に対してローカルであり、バッファに対して
     ローカルにはならない。*Note Multiple Displays::。これはインクリメ
     ンタルサーチモードの実装に使われている。

 -- Variable: overriding-local-map-menu-flag
     この変数が`nil'以外であれば、`overriding-local-map'や
     `overriding-terminal-local-map'の値は、メニューバーの表示に影響す
     る。デフォルト値は`nil'であり、そのため、それらのマップはメニュー
     バーには影響しない。

     これら2つのキーマップ変数は、メニューバーの表示に影響しないときで
     あっても、メニューバーを用いて入力したキー列の実行には影響すること
     に注意してほしい。そのため、メニューバーのキー列が到着したら、その
     キー列を探索し実行するまえに、これらの変数をクリアすべきである。こ
     れらの変数を使うモードでは、典型的にはつぎのようにする。つまり、モー
     ドで処理できないイベントは『読み戻し』てモードから抜ける。

 -- Variable: special-event-map
     この変数は特殊イベント用のキーマップを保持する。
     イベント型のバインディングがこのキーマップにあれば、
     そのイベントは特殊イベントであり、
     `read-event'が当該イベントのバインディングを直接実行する。
     *Note Special Events::。



